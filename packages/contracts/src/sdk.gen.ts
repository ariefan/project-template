// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { AllUserRolesListData, AllUserRolesListResponses, AuditLogsExportData, AuditLogsExportResponses, AuditLogsGetData, AuditLogsGetResponses, AuditLogsListData, AuditLogsListResponses, AvailableContextsListData, AvailableContextsListResponses, ContextSwitchSwitchData, ContextSwitchSwitchResponses, CurrentUserContextGetData, CurrentUserContextGetResponses, ExampleCommentsBatchCreateData, ExampleCommentsBatchCreateResponses, ExampleCommentsBatchSoftDeleteData, ExampleCommentsBatchSoftDeleteResponses, ExampleCommentsCreateData, ExampleCommentsCreateResponses, ExampleCommentsDeleteData, ExampleCommentsDeletePermanentData, ExampleCommentsDeletePermanentResponses, ExampleCommentsDeleteResponses, ExampleCommentsGetData, ExampleCommentsGetResponses, ExampleCommentsListData, ExampleCommentsListResponses, ExampleCommentsRestoreData, ExampleCommentsRestoreResponses, ExampleCommentsUpdateData, ExampleCommentsUpdateResponses, ExamplePostsBatchCreateData, ExamplePostsBatchCreateResponses, ExamplePostsBatchRestoreData, ExamplePostsBatchRestoreResponses, ExamplePostsBatchSoftDeleteData, ExamplePostsBatchSoftDeleteResponses, ExamplePostsBatchUpdateData, ExamplePostsBatchUpdateResponses, ExamplePostsCreateData, ExamplePostsCreateResponses, ExamplePostsDeleteData, ExamplePostsDeletePermanentData, ExamplePostsDeletePermanentResponses, ExamplePostsDeleteResponses, ExamplePostsGetData, ExamplePostsGetResponses, ExamplePostsListCursorData, ExamplePostsListCursorResponses, ExamplePostsListData, ExamplePostsListDeletedData, ExamplePostsListDeletedResponses, ExamplePostsListResponses, ExamplePostsRestoreData, ExamplePostsRestoreResponses, ExamplePostsUpdateData, ExamplePostsUpdateResponses, FilesConfirmUploadData, FilesConfirmUploadResponses, FilesDeleteData, FilesDeletePermanentData, FilesDeletePermanentResponses, FilesDeleteResponses, FilesDirectUploadData, FilesDirectUploadResponses, FilesDownloadData, FilesDownloadResponses, FilesGetData, FilesGetResponses, FilesInitiateUploadData, FilesInitiateUploadResponses, FilesListData, FilesListResponses, FilesUpdateData, FilesUpdateResponses, GlobalRolesCreateData, GlobalRolesCreateResponses, GlobalRolesDeleteData, GlobalRolesDeleteResponses, GlobalRolesGetData, GlobalRolesGetResponses, GlobalRolesListData, GlobalRolesListResponses, GlobalRolesUpdateData, GlobalRolesUpdateResponses, HealthCheckData, HealthCheckResponses, JobsCancelData, JobsCancelResponses, JobsGetData, JobsGetResponses, JobsListData, JobsListResponses, MigrationGetStatusData, MigrationGetStatusResponses, NotificationPreferencesRoutesGetPreferencesData, NotificationPreferencesRoutesGetPreferencesResponses, NotificationPreferencesRoutesUpdatePreferencesData, NotificationPreferencesRoutesUpdatePreferencesResponses, NotificationsDeleteData, NotificationsDeleteResponses, NotificationsGetData, NotificationsGetResponses, NotificationsGetUnreadCountData, NotificationsGetUnreadCountResponses, NotificationsListData, NotificationsListResponses, NotificationsMarkAllReadData, NotificationsMarkAllReadResponses, NotificationsMarkReadData, NotificationsMarkReadResponses, NotificationsMarkUnreadData, NotificationsMarkUnreadResponses, NotificationsPreviewEmailData, NotificationsPreviewEmailResponses, NotificationsRestoreData, NotificationsRestoreResponses, NotificationsSendData, NotificationsSendResponses, ReportExportsExportData, ReportExportsExportResponses, ReportExportsPreviewExportData, ReportExportsPreviewExportResponses, ReportExportsStreamExportData, ReportExportsStreamExportResponses, ReportJobsCancelData, ReportJobsCancelResponses, ReportJobsDownloadData, ReportJobsDownloadResponses, ReportJobsGetData, ReportJobsGetResponses, ReportJobsListData, ReportJobsListResponses, ReportJobsRetryData, ReportJobsRetryResponses, ReportTemplatesCloneData, ReportTemplatesCloneResponses, ReportTemplatesCreateData, ReportTemplatesCreateResponses, ReportTemplatesDeleteData, ReportTemplatesDeleteResponses, ReportTemplatesGetData, ReportTemplatesGetResponses, ReportTemplatesListData, ReportTemplatesListResponses, ReportTemplatesTestData, ReportTemplatesTestResponses, ReportTemplatesUpdateData, ReportTemplatesUpdateResponses, ScheduledReportsCreateData, ScheduledReportsCreateResponses, ScheduledReportsDeleteData, ScheduledReportsDeleteResponses, ScheduledReportsGetData, ScheduledReportsGetHistoryData, ScheduledReportsGetHistoryResponses, ScheduledReportsGetResponses, ScheduledReportsListData, ScheduledReportsListResponses, ScheduledReportsPauseData, ScheduledReportsPauseResponses, ScheduledReportsResumeData, ScheduledReportsResumeResponses, ScheduledReportsRunNowData, ScheduledReportsRunNowResponses, ScheduledReportsUpdateData, ScheduledReportsUpdateResponses, TenantRolesCreateData, TenantRolesCreateResponses, TenantRolesDeleteData, TenantRolesDeleteResponses, TenantRolesGetData, TenantRolesGetResponses, TenantRolesListData, TenantRolesListResponses, TenantRolesUpdateData, TenantRolesUpdateResponses, UserPermissionsGetData, UserPermissionsGetResponses, UserTenantRolesAssignData, UserTenantRolesAssignResponses, UserTenantRolesListData, UserTenantRolesListResponses, UserTenantRolesRemoveData, UserTenantRolesRemoveResponses, WebhooksCreateData, WebhooksCreateResponses, WebhooksDeleteData, WebhooksDeleteResponses, WebhooksGetData, WebhooksGetDeliveryData, WebhooksGetDeliveryResponses, WebhooksGetResponses, WebhooksListData, WebhooksListDeliveriesData, WebhooksListDeliveriesResponses, WebhooksListEventTypesData, WebhooksListEventTypesResponses, WebhooksListResponses, WebhooksRetryDeliveryData, WebhooksRetryDeliveryResponses, WebhooksRotateSecretData, WebhooksRotateSecretResponses, WebhooksTestData, WebhooksTestResponses, WebhooksUpdateData, WebhooksUpdateResponses } from './types.gen';
import { zAllUserRolesListData, zAllUserRolesListResponse, zAuditLogsExportData, zAuditLogsExportResponse, zAuditLogsGetData, zAuditLogsGetResponse, zAuditLogsListData, zAuditLogsListResponse, zAvailableContextsListData, zAvailableContextsListResponse, zContextSwitchSwitchData, zContextSwitchSwitchResponse, zCurrentUserContextGetData, zCurrentUserContextGetResponse, zExampleCommentsBatchCreateData, zExampleCommentsBatchCreateResponse, zExampleCommentsBatchSoftDeleteData, zExampleCommentsBatchSoftDeleteResponse, zExampleCommentsCreateData, zExampleCommentsCreateResponse, zExampleCommentsDeleteData, zExampleCommentsDeletePermanentData, zExampleCommentsDeletePermanentResponse, zExampleCommentsDeleteResponse, zExampleCommentsGetData, zExampleCommentsGetResponse, zExampleCommentsListData, zExampleCommentsListResponse, zExampleCommentsRestoreData, zExampleCommentsRestoreResponse, zExampleCommentsUpdateData, zExampleCommentsUpdateResponse, zExamplePostsBatchCreateData, zExamplePostsBatchCreateResponse, zExamplePostsBatchRestoreData, zExamplePostsBatchRestoreResponse, zExamplePostsBatchSoftDeleteData, zExamplePostsBatchSoftDeleteResponse, zExamplePostsBatchUpdateData, zExamplePostsBatchUpdateResponse, zExamplePostsCreateData, zExamplePostsCreateResponse, zExamplePostsDeleteData, zExamplePostsDeletePermanentData, zExamplePostsDeletePermanentResponse, zExamplePostsDeleteResponse, zExamplePostsGetData, zExamplePostsGetResponse, zExamplePostsListCursorData, zExamplePostsListCursorResponse, zExamplePostsListData, zExamplePostsListDeletedData, zExamplePostsListDeletedResponse, zExamplePostsListResponse, zExamplePostsRestoreData, zExamplePostsRestoreResponse, zExamplePostsUpdateData, zExamplePostsUpdateResponse, zFilesConfirmUploadData, zFilesConfirmUploadResponse, zFilesDeleteData, zFilesDeletePermanentData, zFilesDeletePermanentResponse, zFilesDeleteResponse, zFilesDirectUploadData, zFilesDirectUploadResponse, zFilesDownloadData, zFilesDownloadResponse, zFilesGetData, zFilesGetResponse, zFilesInitiateUploadData, zFilesInitiateUploadResponse, zFilesListData, zFilesListResponse, zFilesUpdateData, zFilesUpdateResponse, zGlobalRolesCreateData, zGlobalRolesCreateResponse, zGlobalRolesDeleteData, zGlobalRolesDeleteResponse, zGlobalRolesGetData, zGlobalRolesGetResponse, zGlobalRolesListData, zGlobalRolesListResponse, zGlobalRolesUpdateData, zGlobalRolesUpdateResponse, zHealthCheckData, zHealthCheckResponse, zJobsCancelData, zJobsCancelResponse, zJobsGetData, zJobsGetResponse, zJobsListData, zJobsListResponse, zMigrationGetStatusData, zMigrationGetStatusResponse, zNotificationPreferencesRoutesGetPreferencesData, zNotificationPreferencesRoutesGetPreferencesResponse, zNotificationPreferencesRoutesUpdatePreferencesData, zNotificationPreferencesRoutesUpdatePreferencesResponse, zNotificationsDeleteData, zNotificationsDeleteResponse, zNotificationsGetData, zNotificationsGetResponse, zNotificationsGetUnreadCountData, zNotificationsGetUnreadCountResponse, zNotificationsListData, zNotificationsListResponse, zNotificationsMarkAllReadData, zNotificationsMarkAllReadResponse, zNotificationsMarkReadData, zNotificationsMarkReadResponse, zNotificationsMarkUnreadData, zNotificationsMarkUnreadResponse, zNotificationsPreviewEmailData, zNotificationsPreviewEmailResponse, zNotificationsRestoreData, zNotificationsRestoreResponse, zNotificationsSendData, zNotificationsSendResponse, zReportExportsExportData, zReportExportsExportResponse, zReportExportsPreviewExportData, zReportExportsPreviewExportResponse, zReportExportsStreamExportData, zReportExportsStreamExportResponse, zReportJobsCancelData, zReportJobsCancelResponse, zReportJobsDownloadData, zReportJobsDownloadResponse, zReportJobsGetData, zReportJobsGetResponse, zReportJobsListData, zReportJobsListResponse, zReportJobsRetryData, zReportJobsRetryResponse, zReportTemplatesCloneData, zReportTemplatesCloneResponse, zReportTemplatesCreateData, zReportTemplatesCreateResponse, zReportTemplatesDeleteData, zReportTemplatesDeleteResponse, zReportTemplatesGetData, zReportTemplatesGetResponse, zReportTemplatesListData, zReportTemplatesListResponse, zReportTemplatesTestData, zReportTemplatesTestResponse, zReportTemplatesUpdateData, zReportTemplatesUpdateResponse, zScheduledReportsCreateData, zScheduledReportsCreateResponse, zScheduledReportsDeleteData, zScheduledReportsDeleteResponse, zScheduledReportsGetData, zScheduledReportsGetHistoryData, zScheduledReportsGetHistoryResponse, zScheduledReportsGetResponse, zScheduledReportsListData, zScheduledReportsListResponse, zScheduledReportsPauseData, zScheduledReportsPauseResponse, zScheduledReportsResumeData, zScheduledReportsResumeResponse, zScheduledReportsRunNowData, zScheduledReportsRunNowResponse, zScheduledReportsUpdateData, zScheduledReportsUpdateResponse, zTenantRolesCreateData, zTenantRolesCreateResponse, zTenantRolesDeleteData, zTenantRolesDeleteResponse, zTenantRolesGetData, zTenantRolesGetResponse, zTenantRolesListData, zTenantRolesListResponse, zTenantRolesUpdateData, zTenantRolesUpdateResponse, zUserPermissionsGetData, zUserPermissionsGetResponse, zUserTenantRolesAssignData, zUserTenantRolesAssignResponse, zUserTenantRolesListData, zUserTenantRolesListResponse, zUserTenantRolesRemoveData, zUserTenantRolesRemoveResponse, zWebhooksCreateData, zWebhooksCreateResponse, zWebhooksDeleteData, zWebhooksDeleteResponse, zWebhooksGetData, zWebhooksGetDeliveryData, zWebhooksGetDeliveryResponse, zWebhooksGetResponse, zWebhooksListData, zWebhooksListDeliveriesData, zWebhooksListDeliveriesResponse, zWebhooksListEventTypesData, zWebhooksListEventTypesResponse, zWebhooksListResponse, zWebhooksRetryDeliveryData, zWebhooksRetryDeliveryResponse, zWebhooksRotateSecretData, zWebhooksRotateSecretResponse, zWebhooksTestData, zWebhooksTestResponse, zWebhooksUpdateData, zWebhooksUpdateResponse } from './zod.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Health check
 *
 * Check API health status
 * Returns 200 OK if the API is healthy
 */
export const healthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthCheckData, ThrowOnError>) => (options?.client ?? client).get<HealthCheckResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zHealthCheckData.parseAsync(data),
    responseValidator: async (data) => await zHealthCheckResponse.parseAsync(data),
    url: '/health',
    ...options
});

/**
 * Get API version migration status
 *
 * Get migration status for the current API version
 *
 * Returns information about:
 * - Current version status (current, deprecated, sunset)
 * - Sunset date if deprecated
 * - Replacement version to migrate to
 * - Breaking changes and migration checklist
 */
export const migrationGetStatus = <ThrowOnError extends boolean = false>(options?: Options<MigrationGetStatusData, ThrowOnError>) => (options?.client ?? client).get<MigrationGetStatusResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zMigrationGetStatusData.parseAsync(data),
    responseValidator: async (data) => await zMigrationGetStatusResponse.parseAsync(data),
    url: '/v1/migration/status',
    ...options
});

/**
 * List notifications
 *
 * List user's notification history
 * Returns notifications for the authenticated user, excluding soft-deleted ones
 */
export const notificationsList = <ThrowOnError extends boolean = false>(options?: Options<NotificationsListData, ThrowOnError>) => (options?.client ?? client).get<NotificationsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsListData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsListResponse.parseAsync(data),
    url: '/v1/notifications',
    ...options
});

/**
 * Mark all notifications as read
 *
 * Mark all notifications as read for the current user
 * Returns the count of notifications that were marked as read
 */
export const notificationsMarkAllRead = <ThrowOnError extends boolean = false>(options?: Options<NotificationsMarkAllReadData, ThrowOnError>) => (options?.client ?? client).post<NotificationsMarkAllReadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsMarkAllReadData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsMarkAllReadResponse.parseAsync(data),
    url: '/v1/notifications/mark-all-read',
    ...options
});

/**
 * Preview email template
 *
 * Preview an email template
 * Renders the template with provided data and returns HTML/text content
 */
export const notificationsPreviewEmail = <ThrowOnError extends boolean = false>(options: Options<NotificationsPreviewEmailData, ThrowOnError>) => (options.client ?? client).post<NotificationsPreviewEmailResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsPreviewEmailData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsPreviewEmailResponse.parseAsync(data),
    url: '/v1/notifications/preview-email',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Send notification
 *
 * Send a notification
 * Queues the notification for delivery through the specified channel
 * Requires authentication. Consider adding authorization for production use.
 */
export const notificationsSend = <ThrowOnError extends boolean = false>(options: Options<NotificationsSendData, ThrowOnError>) => (options.client ?? client).post<NotificationsSendResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsSendData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsSendResponse.parseAsync(data),
    url: '/v1/notifications/send',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get unread notification count
 *
 * Get count of unread notifications
 * Returns the number of unread notifications for the current user
 */
export const notificationsGetUnreadCount = <ThrowOnError extends boolean = false>(options?: Options<NotificationsGetUnreadCountData, ThrowOnError>) => (options?.client ?? client).get<NotificationsGetUnreadCountResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsGetUnreadCountData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsGetUnreadCountResponse.parseAsync(data),
    url: '/v1/notifications/unread/count',
    ...options
});

/**
 * Delete notification
 *
 * Soft delete a notification
 * Marks the notification as deleted without actually removing it
 */
export const notificationsDelete = <ThrowOnError extends boolean = false>(options: Options<NotificationsDeleteData, ThrowOnError>) => (options.client ?? client).delete<NotificationsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsDeleteResponse.parseAsync(data),
    url: '/v1/notifications/{id}',
    ...options
});

/**
 * Get notification by ID
 *
 * Get a specific notification by ID
 * Only returns notifications owned by the authenticated user
 */
export const notificationsGet = <ThrowOnError extends boolean = false>(options: Options<NotificationsGetData, ThrowOnError>) => (options.client ?? client).get<NotificationsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsGetData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsGetResponse.parseAsync(data),
    url: '/v1/notifications/{id}',
    ...options
});

/**
 * Mark notification as read
 *
 * Mark a notification as read
 * Updates the readAt timestamp for the notification
 */
export const notificationsMarkRead = <ThrowOnError extends boolean = false>(options: Options<NotificationsMarkReadData, ThrowOnError>) => (options.client ?? client).patch<NotificationsMarkReadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsMarkReadData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsMarkReadResponse.parseAsync(data),
    url: '/v1/notifications/{id}/read',
    ...options
});

/**
 * Restore notification
 *
 * Restore a soft-deleted notification
 * Clears the deletedAt timestamp to restore the notification
 */
export const notificationsRestore = <ThrowOnError extends boolean = false>(options: Options<NotificationsRestoreData, ThrowOnError>) => (options.client ?? client).post<NotificationsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsRestoreResponse.parseAsync(data),
    url: '/v1/notifications/{id}/restore',
    ...options
});

/**
 * Mark notification as unread
 *
 * Mark a notification as unread
 * Clears the readAt timestamp for the notification
 */
export const notificationsMarkUnread = <ThrowOnError extends boolean = false>(options: Options<NotificationsMarkUnreadData, ThrowOnError>) => (options.client ?? client).patch<NotificationsMarkUnreadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsMarkUnreadData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsMarkUnreadResponse.parseAsync(data),
    url: '/v1/notifications/{id}/unread',
    ...options
});

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsList = <ThrowOnError extends boolean = false>(options: Options<AuditLogsListData, ThrowOnError>) => (options.client ?? client).get<AuditLogsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsListData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs',
    ...options
});

/**
 * Export audit logs
 *
 * Export audit logs
 *
 * Returns a download URL for audit logs in CSV or JSON format.
 * For large exports, returns 202 Accepted with a job ID.
 */
export const auditLogsExport = <ThrowOnError extends boolean = false>(options: Options<AuditLogsExportData, ThrowOnError>) => (options.client ?? client).post<AuditLogsExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsExportData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs/export',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get audit log entry
 *
 * Get a single audit log entry
 */
export const auditLogsGet = <ThrowOnError extends boolean = false>(options: Options<AuditLogsGetData, ThrowOnError>) => (options.client ?? client).get<AuditLogsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsGetData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs/{eventId}',
    ...options
});

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsList = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts',
    ...options
});

/**
 * Create example post
 *
 * Create a new post
 */
export const examplePostsCreate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsCreateData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsCreateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch update example posts
 *
 * Batch update posts
 */
export const examplePostsBatchUpdate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExamplePostsBatchUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create example posts
 *
 * Batch create posts
 */
export const examplePostsBatchCreate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchCreateData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch restore example posts
 *
 * Batch restore soft-deleted posts
 */
export const examplePostsBatchRestore = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchRestoreData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch/restore',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete example posts
 *
 * Batch soft delete posts
 */
export const examplePostsBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursor = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListCursorData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListCursorResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListCursorData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListCursorResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/cursor',
    ...options
});

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeleted = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListDeletedData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListDeletedResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListDeletedData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListDeletedResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/deleted',
    ...options
});

/**
 * Soft delete example post
 *
 * Soft delete a post (default delete behavior)
 * Post is marked as deleted but can be restored
 */
export const examplePostsDelete = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ExamplePostsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options
});

/**
 * Get example post
 *
 * Get a single post by ID
 */
export const examplePostsGet = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsGetData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsGetData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options
});

/**
 * Update example post
 *
 * Update a post (partial update)
 */
export const examplePostsUpdate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExamplePostsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete example post
 *
 * Permanently delete a post (hard delete)
 * Post is permanently removed and cannot be restored
 */
export const examplePostsDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<ExamplePostsDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}/permanent',
    ...options
});

/**
 * Restore example post
 *
 * Restore a soft-deleted post
 */
export const examplePostsRestore = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsRestoreData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}/restore',
    ...options
});

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsList = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsListData, ThrowOnError>) => (options.client ?? client).get<ExampleCommentsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsListData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments',
    ...options
});

/**
 * Create comment on post
 *
 * Create a new comment on a post
 */
export const exampleCommentsCreate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsCreateData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsCreateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create comments
 *
 * Batch create comments
 */
export const exampleCommentsBatchCreate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsBatchCreateData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete comments
 *
 * Batch soft delete comments
 */
export const exampleCommentsBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Soft delete comment
 *
 * Soft delete a comment
 */
export const exampleCommentsDelete = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ExampleCommentsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options
});

/**
 * Get comment
 *
 * Get a single comment by ID
 */
export const exampleCommentsGet = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsGetData, ThrowOnError>) => (options.client ?? client).get<ExampleCommentsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsGetData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options
});

/**
 * Update comment
 *
 * Update a comment (partial update)
 */
export const exampleCommentsUpdate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExampleCommentsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete comment
 *
 * Permanently delete a comment (hard delete)
 */
export const exampleCommentsDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<ExampleCommentsDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/permanent',
    ...options
});

/**
 * Restore comment
 *
 * Restore a soft-deleted comment
 */
export const exampleCommentsRestore = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsRestoreData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/restore',
    ...options
});

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesList = <ThrowOnError extends boolean = false>(options: Options<FilesListData, ThrowOnError>) => (options.client ?? client).get<FilesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesListData.parseAsync(data),
    responseValidator: async (data) => await zFilesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files',
    ...options
});

/**
 * Direct file upload
 *
 * Direct file upload (multipart/form-data)
 *
 * For simple uploads of small files (< 10 MB).
 * File is uploaded directly to the API server.
 *
 * Note: For larger files or high volume, use presigned URL upload.
 */
export const filesDirectUpload = <ThrowOnError extends boolean = false>(options: Options<FilesDirectUploadData, ThrowOnError>) => (options.client ?? client).post<FilesDirectUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDirectUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesDirectUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files',
    ...options
});

/**
 * Initiate presigned URL upload
 *
 * Initiate a presigned URL upload
 *
 * Returns a presigned URL for direct upload to storage (S3/R2/GCS).
 * Client uploads directly to storage, then confirms with the API.
 *
 * Flow:
 * 1. POST /files/uploads - Get presigned URL
 * 2. PUT {presignedUrl} - Upload directly to storage
 * 3. POST /files/uploads/{uploadId}/confirm - Confirm upload
 */
export const filesInitiateUpload = <ThrowOnError extends boolean = false>(options: Options<FilesInitiateUploadData, ThrowOnError>) => (options.client ?? client).post<FilesInitiateUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesInitiateUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesInitiateUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/uploads',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Confirm presigned URL upload
 *
 * Confirm a presigned URL upload
 *
 * Called after client successfully uploads to the presigned URL.
 * Triggers virus scanning and creates the file record.
 */
export const filesConfirmUpload = <ThrowOnError extends boolean = false>(options: Options<FilesConfirmUploadData, ThrowOnError>) => (options.client ?? client).post<FilesConfirmUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesConfirmUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesConfirmUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/uploads/{uploadId}/confirm',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete file
 *
 * Delete a file (soft delete)
 *
 * File is marked as deleted but retained for audit purposes.
 * Storage is cleaned up after retention period.
 */
export const filesDelete = <ThrowOnError extends boolean = false>(options: Options<FilesDeleteData, ThrowOnError>) => (options.client ?? client).delete<FilesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zFilesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options
});

/**
 * Get file
 *
 * Get a single file by ID
 *
 * Returns file metadata including a fresh signed URL for download.
 */
export const filesGet = <ThrowOnError extends boolean = false>(options: Options<FilesGetData, ThrowOnError>) => (options.client ?? client).get<FilesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesGetData.parseAsync(data),
    responseValidator: async (data) => await zFilesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options
});

/**
 * Update file
 *
 * Update file properties
 *
 * Currently supports changing the access level (private/public).
 */
export const filesUpdate = <ThrowOnError extends boolean = false>(options: Options<FilesUpdateData, ThrowOnError>) => (options.client ?? client).patch<FilesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zFilesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Download file
 *
 * Download a file
 *
 * Returns a redirect to a signed URL for the file.
 * The signed URL expires in 5 minutes.
 */
export const filesDownload = <ThrowOnError extends boolean = false>(options: Options<FilesDownloadData, ThrowOnError>) => (options.client ?? client).get<FilesDownloadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDownloadData.parseAsync(data),
    responseValidator: async (data) => await zFilesDownloadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}/download',
    ...options
});

/**
 * Permanently delete file
 *
 * Permanently delete a file (hard delete)
 *
 * Immediately removes file from storage.
 * Use with caution - cannot be undone.
 */
export const filesDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<FilesDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<FilesDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zFilesDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}/permanent',
    ...options
});

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsList = <ThrowOnError extends boolean = false>(options: Options<JobsListData, ThrowOnError>) => (options.client ?? client).get<JobsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsListData.parseAsync(data),
    responseValidator: async (data) => await zJobsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs',
    ...options
});

/**
 * Get job status
 *
 * Get job status
 *
 * Poll this endpoint to check progress of async operations.
 */
export const jobsGet = <ThrowOnError extends boolean = false>(options: Options<JobsGetData, ThrowOnError>) => (options.client ?? client).get<JobsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsGetData.parseAsync(data),
    responseValidator: async (data) => await zJobsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}',
    ...options
});

/**
 * Cancel job
 *
 * Cancel a job
 *
 * Only pending or processing jobs can be cancelled.
 */
export const jobsCancel = <ThrowOnError extends boolean = false>(options: Options<JobsCancelData, ThrowOnError>) => (options.client ?? client).post<JobsCancelResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsCancelData.parseAsync(data),
    responseValidator: async (data) => await zJobsCancelResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}/cancel',
    ...options
});

/**
 * Export data
 *
 * Export data synchronously
 *
 * For small datasets (<10,000 rows). Returns the file directly.
 * For larger datasets, use async=true to get a job ID.
 */
export const reportExportsExport = <ThrowOnError extends boolean = false>(options: Options<ReportExportsExportData, ThrowOnError>) => (options.client ?? client).post<ReportExportsExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportExportsExportData.parseAsync(data),
    responseValidator: async (data) => await zReportExportsExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/export',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Preview export
 *
 * Preview export (first N rows)
 *
 * Useful for testing templates and verifying data before full export.
 */
export const reportExportsPreviewExport = <ThrowOnError extends boolean = false>(options: Options<ReportExportsPreviewExportData, ThrowOnError>) => (options.client ?? client).post<ReportExportsPreviewExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportExportsPreviewExportData.parseAsync(data),
    responseValidator: async (data) => await zReportExportsPreviewExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/export/preview',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Stream export data
 *
 * Export data as streaming response
 *
 * For large datasets. Streams data in chunks as it's generated.
 * Only supports CSV and Excel formats.
 */
export const reportExportsStreamExport = <ThrowOnError extends boolean = false>(options: Options<ReportExportsStreamExportData, ThrowOnError>) => (options.client ?? client).post<ReportExportsStreamExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportExportsStreamExportData.parseAsync(data),
    responseValidator: async (data) => await zReportExportsStreamExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/export/stream',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List report jobs
 *
 * List report jobs in an organization
 */
export const reportJobsList = <ThrowOnError extends boolean = false>(options: Options<ReportJobsListData, ThrowOnError>) => (options.client ?? client).get<ReportJobsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportJobsListData.parseAsync(data),
    responseValidator: async (data) => await zReportJobsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/jobs',
    ...options
});

/**
 * Cancel report job
 *
 * Cancel a pending or processing job
 */
export const reportJobsCancel = <ThrowOnError extends boolean = false>(options: Options<ReportJobsCancelData, ThrowOnError>) => (options.client ?? client).delete<ReportJobsCancelResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportJobsCancelData.parseAsync(data),
    responseValidator: async (data) => await zReportJobsCancelResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/jobs/{jobId}',
    ...options
});

/**
 * Get report job
 *
 * Get a report job by ID
 */
export const reportJobsGet = <ThrowOnError extends boolean = false>(options: Options<ReportJobsGetData, ThrowOnError>) => (options.client ?? client).get<ReportJobsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportJobsGetData.parseAsync(data),
    responseValidator: async (data) => await zReportJobsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/jobs/{jobId}',
    ...options
});

/**
 * Download job result
 *
 * Download the result of a completed job
 */
export const reportJobsDownload = <ThrowOnError extends boolean = false>(options: Options<ReportJobsDownloadData, ThrowOnError>) => (options.client ?? client).get<ReportJobsDownloadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportJobsDownloadData.parseAsync(data),
    responseValidator: async (data) => await zReportJobsDownloadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/jobs/{jobId}/download',
    ...options
});

/**
 * Retry failed job
 *
 * Retry a failed job
 */
export const reportJobsRetry = <ThrowOnError extends boolean = false>(options: Options<ReportJobsRetryData, ThrowOnError>) => (options.client ?? client).post<ReportJobsRetryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportJobsRetryData.parseAsync(data),
    responseValidator: async (data) => await zReportJobsRetryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/jobs/{jobId}/retry',
    ...options
});

/**
 * List scheduled reports
 *
 * List scheduled reports in an organization
 */
export const scheduledReportsList = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsListData, ThrowOnError>) => (options.client ?? client).get<ScheduledReportsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsListData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules',
    ...options
});

/**
 * Create scheduled report
 *
 * Create a new scheduled report
 */
export const scheduledReportsCreate = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsCreateData, ThrowOnError>) => (options.client ?? client).post<ScheduledReportsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsCreateData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete scheduled report
 *
 * Delete a scheduled report
 */
export const scheduledReportsDelete = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ScheduledReportsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}',
    ...options
});

/**
 * Get scheduled report
 *
 * Get a scheduled report by ID
 */
export const scheduledReportsGet = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsGetData, ThrowOnError>) => (options.client ?? client).get<ScheduledReportsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsGetData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}',
    ...options
});

/**
 * Update scheduled report
 *
 * Update a scheduled report
 */
export const scheduledReportsUpdate = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ScheduledReportsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get schedule run history
 *
 * Get run history for a scheduled report
 */
export const scheduledReportsGetHistory = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsGetHistoryData, ThrowOnError>) => (options.client ?? client).get<ScheduledReportsGetHistoryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsGetHistoryData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsGetHistoryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}/history',
    ...options
});

/**
 * Pause scheduled report
 *
 * Pause a scheduled report
 */
export const scheduledReportsPause = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsPauseData, ThrowOnError>) => (options.client ?? client).post<ScheduledReportsPauseResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsPauseData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsPauseResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}/pause',
    ...options
});

/**
 * Resume scheduled report
 *
 * Resume a paused scheduled report
 */
export const scheduledReportsResume = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsResumeData, ThrowOnError>) => (options.client ?? client).post<ScheduledReportsResumeResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsResumeData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsResumeResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}/resume',
    ...options
});

/**
 * Run scheduled report now
 *
 * Trigger a scheduled report to run immediately
 */
export const scheduledReportsRunNow = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsRunNowData, ThrowOnError>) => (options.client ?? client).post<ScheduledReportsRunNowResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsRunNowData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsRunNowResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}/run',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List report templates
 *
 * List report templates in an organization
 */
export const reportTemplatesList = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesListData, ThrowOnError>) => (options.client ?? client).get<ReportTemplatesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesListData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates',
    ...options
});

/**
 * Create report template
 *
 * Create a new report template
 */
export const reportTemplatesCreate = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesCreateData, ThrowOnError>) => (options.client ?? client).post<ReportTemplatesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesCreateData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete report template
 *
 * Delete a report template
 */
export const reportTemplatesDelete = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesDeleteData, ThrowOnError>) => (options.client ?? client).delete<ReportTemplatesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}',
    ...options
});

/**
 * Get report template
 *
 * Get a report template by ID
 */
export const reportTemplatesGet = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesGetData, ThrowOnError>) => (options.client ?? client).get<ReportTemplatesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesGetData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}',
    ...options
});

/**
 * Update report template
 *
 * Update a report template
 */
export const reportTemplatesUpdate = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesUpdateData, ThrowOnError>) => (options.client ?? client).patch<ReportTemplatesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Clone report template
 *
 * Clone a report template
 */
export const reportTemplatesClone = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesCloneData, ThrowOnError>) => (options.client ?? client).post<ReportTemplatesCloneResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesCloneData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesCloneResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}/clone',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Test report template
 *
 * Test a report template with sample data
 */
export const reportTemplatesTest = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesTestData, ThrowOnError>) => (options.client ?? client).post<ReportTemplatesTestResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesTestData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesTestResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}/test',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesList = <ThrowOnError extends boolean = false>(options: Options<TenantRolesListData, ThrowOnError>) => (options.client ?? client).get<TenantRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesListData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles',
    ...options
});

/**
 * Create tenant role
 *
 * Create a tenant-scoped role
 *
 * Creates a custom role for this specific tenant.
 */
export const tenantRolesCreate = <ThrowOnError extends boolean = false>(options: Options<TenantRolesCreateData, ThrowOnError>) => (options.client ?? client).post<TenantRolesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesCreateData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const tenantRolesDelete = <ThrowOnError extends boolean = false>(options: Options<TenantRolesDeleteData, ThrowOnError>) => (options.client ?? client).delete<TenantRolesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options
});

/**
 * Get role
 *
 * Get a role by ID
 */
export const tenantRolesGet = <ThrowOnError extends boolean = false>(options: Options<TenantRolesGetData, ThrowOnError>) => (options.client ?? client).get<TenantRolesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesGetData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const tenantRolesUpdate = <ThrowOnError extends boolean = false>(options: Options<TenantRolesUpdateData, ThrowOnError>) => (options.client ?? client).patch<TenantRolesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get user effective permissions
 *
 * Get user's effective permissions in this tenant
 *
 * Returns all roles (global + tenant) and the combined effective permissions
 * after applying deny-override resolution.
 */
export const userPermissionsGet = <ThrowOnError extends boolean = false>(options: Options<UserPermissionsGetData, ThrowOnError>) => (options.client ?? client).get<UserPermissionsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserPermissionsGetData.parseAsync(data),
    responseValidator: async (data) => await zUserPermissionsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/permissions',
    ...options
});

/**
 * List user roles in tenant
 *
 * List roles assigned to a user in this tenant
 *
 * Returns both global and tenant-specific role assignments.
 */
export const userTenantRolesList = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesListData, ThrowOnError>) => (options.client ?? client).get<UserTenantRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesListData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles',
    ...options
});

/**
 * Assign role to user
 *
 * Assign a role to a user in this tenant
 */
export const userTenantRolesAssign = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesAssignData, ThrowOnError>) => (options.client ?? client).post<UserTenantRolesAssignResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesAssignData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesAssignResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Remove role from user
 *
 * Remove a role from a user
 */
export const userTenantRolesRemove = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesRemoveData, ThrowOnError>) => (options.client ?? client).delete<UserTenantRolesRemoveResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesRemoveData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesRemoveResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles/{roleId}',
    ...options
});

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksList = <ThrowOnError extends boolean = false>(options: Options<WebhooksListData, ThrowOnError>) => (options.client ?? client).get<WebhooksListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks',
    ...options
});

/**
 * Create webhook
 *
 * Create a new webhook
 *
 * The secret is only returned once in the response.
 * Store it securely for signature verification.
 */
export const webhooksCreate = <ThrowOnError extends boolean = false>(options: Options<WebhooksCreateData, ThrowOnError>) => (options.client ?? client).post<WebhooksCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksCreateData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List event types
 *
 * Get available event types
 *
 * Returns all event types that can be subscribed to.
 */
export const webhooksListEventTypes = <ThrowOnError extends boolean = false>(options: Options<WebhooksListEventTypesData, ThrowOnError>) => (options.client ?? client).get<WebhooksListEventTypesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListEventTypesData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListEventTypesResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/event-types',
    ...options
});

/**
 * Delete webhook
 *
 * Delete a webhook
 */
export const webhooksDelete = <ThrowOnError extends boolean = false>(options: Options<WebhooksDeleteData, ThrowOnError>) => (options.client ?? client).delete<WebhooksDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksDeleteData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options
});

/**
 * Get webhook
 *
 * Get a webhook by ID
 */
export const webhooksGet = <ThrowOnError extends boolean = false>(options: Options<WebhooksGetData, ThrowOnError>) => (options.client ?? client).get<WebhooksGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksGetData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options
});

/**
 * Update webhook
 *
 * Update a webhook
 */
export const webhooksUpdate = <ThrowOnError extends boolean = false>(options: Options<WebhooksUpdateData, ThrowOnError>) => (options.client ?? client).patch<WebhooksUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksUpdateData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveries = <ThrowOnError extends boolean = false>(options: Options<WebhooksListDeliveriesData, ThrowOnError>) => (options.client ?? client).get<WebhooksListDeliveriesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListDeliveriesData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListDeliveriesResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries',
    ...options
});

/**
 * Get webhook delivery
 *
 * Get a specific delivery
 */
export const webhooksGetDelivery = <ThrowOnError extends boolean = false>(options: Options<WebhooksGetDeliveryData, ThrowOnError>) => (options.client ?? client).get<WebhooksGetDeliveryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksGetDeliveryData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksGetDeliveryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}',
    ...options
});

/**
 * Retry delivery
 *
 * Retry a failed delivery
 *
 * Manually triggers a retry for a failed delivery.
 */
export const webhooksRetryDelivery = <ThrowOnError extends boolean = false>(options: Options<WebhooksRetryDeliveryData, ThrowOnError>) => (options.client ?? client).post<WebhooksRetryDeliveryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksRetryDeliveryData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksRetryDeliveryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}/retry',
    ...options
});

/**
 * Rotate webhook secret
 *
 * Rotate webhook secret
 *
 * Generates a new secret. The old secret immediately stops working.
 */
export const webhooksRotateSecret = <ThrowOnError extends boolean = false>(options: Options<WebhooksRotateSecretData, ThrowOnError>) => (options.client ?? client).post<WebhooksRotateSecretResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksRotateSecretData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksRotateSecretResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/rotate-secret',
    ...options
});

/**
 * Test webhook
 *
 * Test a webhook
 *
 * Sends a test event to verify the webhook is configured correctly.
 */
export const webhooksTest = <ThrowOnError extends boolean = false>(options: Options<WebhooksTestData, ThrowOnError>) => (options.client ?? client).post<WebhooksTestResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksTestData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksTestResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/test',
    ...options
});

/**
 * Get notification preferences
 *
 * Get notification preferences for the current user
 * Returns default values if no preferences are set
 */
export const notificationPreferencesRoutesGetPreferences = <ThrowOnError extends boolean = false>(options?: Options<NotificationPreferencesRoutesGetPreferencesData, ThrowOnError>) => (options?.client ?? client).get<NotificationPreferencesRoutesGetPreferencesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationPreferencesRoutesGetPreferencesData.parseAsync(data),
    responseValidator: async (data) => await zNotificationPreferencesRoutesGetPreferencesResponse.parseAsync(data),
    url: '/v1/preferences',
    ...options
});

/**
 * Update notification preferences
 *
 * Update notification preferences for the current user
 * Supports partial updates - only provided fields will be updated
 */
export const notificationPreferencesRoutesUpdatePreferences = <ThrowOnError extends boolean = false>(options: Options<NotificationPreferencesRoutesUpdatePreferencesData, ThrowOnError>) => (options.client ?? client).patch<NotificationPreferencesRoutesUpdatePreferencesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationPreferencesRoutesUpdatePreferencesData.parseAsync(data),
    responseValidator: async (data) => await zNotificationPreferencesRoutesUpdatePreferencesResponse.parseAsync(data),
    url: '/v1/preferences',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesList = <ThrowOnError extends boolean = false>(options?: Options<GlobalRolesListData, ThrowOnError>) => (options?.client ?? client).get<GlobalRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesListData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesListResponse.parseAsync(data),
    url: '/v1/roles',
    ...options
});

/**
 * Create global role
 *
 * Create a global role
 *
 * Creates a role that applies across all tenants.
 */
export const globalRolesCreate = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesCreateData, ThrowOnError>) => (options.client ?? client).post<GlobalRolesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesCreateData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesCreateResponse.parseAsync(data),
    url: '/v1/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const globalRolesDelete = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesDeleteData, ThrowOnError>) => (options.client ?? client).delete<GlobalRolesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesDeleteResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options
});

/**
 * Get role
 *
 * Get a role by ID
 */
export const globalRolesGet = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesGetData, ThrowOnError>) => (options.client ?? client).get<GlobalRolesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesGetData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesGetResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const globalRolesUpdate = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesUpdateData, ThrowOnError>) => (options.client ?? client).patch<GlobalRolesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesUpdateResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List available contexts
 *
 * List all available contexts for the current user
 *
 * Returns all applications and tenants the user has access to.
 */
export const availableContextsList = <ThrowOnError extends boolean = false>(options?: Options<AvailableContextsListData, ThrowOnError>) => (options?.client ?? client).get<AvailableContextsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAvailableContextsListData.parseAsync(data),
    responseValidator: async (data) => await zAvailableContextsListResponse.parseAsync(data),
    url: '/v1/users/me/available-contexts',
    ...options
});

/**
 * Get active context
 *
 * Get current user's active context
 *
 * Returns the currently active application and tenant for the user.
 * This is for UI state management, not authorization decisions.
 */
export const currentUserContextGet = <ThrowOnError extends boolean = false>(options?: Options<CurrentUserContextGetData, ThrowOnError>) => (options?.client ?? client).get<CurrentUserContextGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCurrentUserContextGetData.parseAsync(data),
    responseValidator: async (data) => await zCurrentUserContextGetResponse.parseAsync(data),
    url: '/v1/users/me/context',
    ...options
});

/**
 * Switch context
 *
 * Switch user's active context
 *
 * Changes the active application and/or tenant.
 * This is for UI state management, not authorization decisions.
 */
export const contextSwitchSwitch = <ThrowOnError extends boolean = false>(options: Options<ContextSwitchSwitchData, ThrowOnError>) => (options.client ?? client).post<ContextSwitchSwitchResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zContextSwitchSwitchData.parseAsync(data),
    responseValidator: async (data) => await zContextSwitchSwitchResponse.parseAsync(data),
    url: '/v1/users/me/switch-context',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all user roles
 *
 * List user's roles across all applications and tenants
 *
 * Returns all role assignments for the user across all contexts.
 */
export const allUserRolesList = <ThrowOnError extends boolean = false>(options: Options<AllUserRolesListData, ThrowOnError>) => (options.client ?? client).get<AllUserRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAllUserRolesListData.parseAsync(data),
    responseValidator: async (data) => await zAllUserRolesListResponse.parseAsync(data),
    url: '/v1/users/{userId}/roles',
    ...options
});
