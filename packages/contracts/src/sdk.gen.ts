// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { AllUserRolesListData, AllUserRolesListResponses, AnnouncementsAcknowledgeData, AnnouncementsAcknowledgeResponses, AnnouncementsCreateData, AnnouncementsCreateResponses, AnnouncementsDeleteData, AnnouncementsDeleteResponses, AnnouncementsDismissData, AnnouncementsDismissResponses, AnnouncementsGetData, AnnouncementsGetResponses, AnnouncementsGetStatsData, AnnouncementsGetStatsResponses, AnnouncementsGetUnreadCountData, AnnouncementsGetUnreadCountResponses, AnnouncementsListData, AnnouncementsListResponses, AnnouncementsMarkReadData, AnnouncementsMarkReadResponses, AnnouncementsMarkViewedData, AnnouncementsMarkViewedResponses, AnnouncementsUpdateData, AnnouncementsUpdateResponses, AuditLogsExportData, AuditLogsExportResponses, AuditLogsGetData, AuditLogsGetResponses, AuditLogsListData, AuditLogsListResponses, AvailableContextsListData, AvailableContextsListResponses, ContextSwitchSwitchData, ContextSwitchSwitchResponses, CouponsAdminCreateData, CouponsAdminCreateResponses, CouponsAdminDeleteData, CouponsAdminDeleteResponses, CouponsAdminGetData, CouponsAdminGetResponses, CouponsAdminListData, CouponsAdminListResponses, CouponsAdminUpdateData, CouponsAdminUpdateResponses, CurrentUserContextGetData, CurrentUserContextGetResponses, ExampleCommentsBatchCreateData, ExampleCommentsBatchCreateResponses, ExampleCommentsBatchSoftDeleteData, ExampleCommentsBatchSoftDeleteResponses, ExampleCommentsCreateData, ExampleCommentsCreateResponses, ExampleCommentsDeleteData, ExampleCommentsDeletePermanentData, ExampleCommentsDeletePermanentResponses, ExampleCommentsDeleteResponses, ExampleCommentsGetData, ExampleCommentsGetResponses, ExampleCommentsListData, ExampleCommentsListResponses, ExampleCommentsRestoreData, ExampleCommentsRestoreResponses, ExampleCommentsUpdateData, ExampleCommentsUpdateResponses, ExamplePostsBatchCreateData, ExamplePostsBatchCreateResponses, ExamplePostsBatchRestoreData, ExamplePostsBatchRestoreResponses, ExamplePostsBatchSoftDeleteData, ExamplePostsBatchSoftDeleteResponses, ExamplePostsBatchUpdateData, ExamplePostsBatchUpdateResponses, ExamplePostsCreateData, ExamplePostsCreateResponses, ExamplePostsDeleteData, ExamplePostsDeletePermanentData, ExamplePostsDeletePermanentResponses, ExamplePostsDeleteResponses, ExamplePostsGetData, ExamplePostsGetResponses, ExamplePostsListCursorData, ExamplePostsListCursorResponses, ExamplePostsListData, ExamplePostsListDeletedData, ExamplePostsListDeletedResponses, ExamplePostsListResponses, ExamplePostsRestoreData, ExamplePostsRestoreResponses, ExamplePostsUpdateData, ExamplePostsUpdateResponses, FilesConfirmUploadData, FilesConfirmUploadResponses, FilesDeleteData, FilesDeletePermanentData, FilesDeletePermanentResponses, FilesDeleteResponses, FilesDirectUploadData, FilesDirectUploadResponses, FilesDownloadData, FilesDownloadResponses, FilesGetData, FilesGetResponses, FilesInitiateUploadData, FilesInitiateUploadResponses, FilesListData, FilesListResponses, FilesUpdateData, FilesUpdateResponses, GlobalRolesCreateData, GlobalRolesCreateResponses, GlobalRolesDeleteData, GlobalRolesDeleteResponses, GlobalRolesGetData, GlobalRolesGetResponses, GlobalRolesListData, GlobalRolesListResponses, GlobalRolesUpdateData, GlobalRolesUpdateResponses, HealthCheckData, HealthCheckResponses, JobsCancelData, JobsCancelResponses, JobsDownloadData, JobsDownloadResponses, JobsGetData, JobsGetResponses, JobsListData, JobsListResponses, JobsRetryData, JobsRetryResponses, MigrationGetStatusData, MigrationGetStatusResponses, NotificationPreferencesRoutesGetPreferencesData, NotificationPreferencesRoutesGetPreferencesResponses, NotificationPreferencesRoutesUpdatePreferencesData, NotificationPreferencesRoutesUpdatePreferencesResponses, NotificationsDeleteData, NotificationsDeleteResponses, NotificationsGetData, NotificationsGetResponses, NotificationsGetUnreadCountData, NotificationsGetUnreadCountResponses, NotificationsListData, NotificationsListResponses, NotificationsMarkAllReadData, NotificationsMarkAllReadResponses, NotificationsMarkReadData, NotificationsMarkReadResponses, NotificationsMarkUnreadData, NotificationsMarkUnreadResponses, NotificationsPreviewEmailData, NotificationsPreviewEmailResponses, NotificationsRestoreData, NotificationsRestoreResponses, NotificationsSendData, NotificationsSendResponses, PaymentWebhooksHandleMidtransData, PaymentWebhooksHandleMidtransResponses, PaymentWebhooksHandleXenditData, PaymentWebhooksHandleXenditResponses, PublicPricingListPublicPlansData, PublicPricingListPublicPlansResponses, ReportExportsExportData, ReportExportsExportResponses, ReportExportsPreviewExportData, ReportExportsPreviewExportResponses, ReportExportsStreamExportData, ReportExportsStreamExportResponses, ReportTemplatesCloneData, ReportTemplatesCloneResponses, ReportTemplatesCreateData, ReportTemplatesCreateResponses, ReportTemplatesDeleteData, ReportTemplatesDeleteResponses, ReportTemplatesGetData, ReportTemplatesGetResponses, ReportTemplatesListData, ReportTemplatesListResponses, ReportTemplatesTestData, ReportTemplatesTestResponses, ReportTemplatesUpdateData, ReportTemplatesUpdateResponses, ScheduledReportsCreateData, ScheduledReportsCreateResponses, ScheduledReportsDeleteData, ScheduledReportsDeleteResponses, ScheduledReportsGetData, ScheduledReportsGetHistoryData, ScheduledReportsGetHistoryResponses, ScheduledReportsGetResponses, ScheduledReportsListData, ScheduledReportsListResponses, ScheduledReportsPauseData, ScheduledReportsPauseResponses, ScheduledReportsResumeData, ScheduledReportsResumeResponses, ScheduledReportsRunNowData, ScheduledReportsRunNowResponses, ScheduledReportsUpdateData, ScheduledReportsUpdateResponses, SubscriptionPlansAdminCreateData, SubscriptionPlansAdminCreateResponses, SubscriptionPlansAdminDeleteData, SubscriptionPlansAdminDeleteResponses, SubscriptionPlansAdminGetData, SubscriptionPlansAdminGetResponses, SubscriptionPlansAdminListData, SubscriptionPlansAdminListResponses, SubscriptionPlansAdminUpdateData, SubscriptionPlansAdminUpdateResponses, SubscriptionsApplyCouponData, SubscriptionsApplyCouponResponses, SubscriptionsCancelData, SubscriptionsCancelResponses, SubscriptionsCreateData, SubscriptionsCreateResponses, SubscriptionsGetCurrentData, SubscriptionsGetCurrentResponses, SubscriptionsResumeData, SubscriptionsResumeResponses, SubscriptionsUpdateData, SubscriptionsUpdateResponses, SubscriptionsValidateCouponData, SubscriptionsValidateCouponResponses, TenantRolesCreateData, TenantRolesCreateResponses, TenantRolesDeleteData, TenantRolesDeleteResponses, TenantRolesGetData, TenantRolesGetResponses, TenantRolesListData, TenantRolesListResponses, TenantRolesUpdateData, TenantRolesUpdateResponses, UserPermissionsGetData, UserPermissionsGetResponses, UserTenantRolesAssignData, UserTenantRolesAssignResponses, UserTenantRolesListData, UserTenantRolesListResponses, UserTenantRolesRemoveData, UserTenantRolesRemoveResponses, WebhooksCreateData, WebhooksCreateResponses, WebhooksDeleteData, WebhooksDeleteResponses, WebhooksGetData, WebhooksGetDeliveryData, WebhooksGetDeliveryResponses, WebhooksGetResponses, WebhooksListData, WebhooksListDeliveriesData, WebhooksListDeliveriesResponses, WebhooksListEventTypesData, WebhooksListEventTypesResponses, WebhooksListResponses, WebhooksRetryDeliveryData, WebhooksRetryDeliveryResponses, WebhooksRotateSecretData, WebhooksRotateSecretResponses, WebhooksTestData, WebhooksTestResponses, WebhooksUpdateData, WebhooksUpdateResponses } from './types.gen';
import { zAllUserRolesListData, zAllUserRolesListResponse, zAnnouncementsAcknowledgeData, zAnnouncementsAcknowledgeResponse, zAnnouncementsCreateData, zAnnouncementsCreateResponse, zAnnouncementsDeleteData, zAnnouncementsDeleteResponse, zAnnouncementsDismissData, zAnnouncementsDismissResponse, zAnnouncementsGetData, zAnnouncementsGetResponse, zAnnouncementsGetStatsData, zAnnouncementsGetStatsResponse, zAnnouncementsGetUnreadCountData, zAnnouncementsGetUnreadCountResponse, zAnnouncementsListData, zAnnouncementsListResponse, zAnnouncementsMarkReadData, zAnnouncementsMarkReadResponse, zAnnouncementsMarkViewedData, zAnnouncementsMarkViewedResponse, zAnnouncementsUpdateData, zAnnouncementsUpdateResponse, zAuditLogsExportData, zAuditLogsExportResponse, zAuditLogsGetData, zAuditLogsGetResponse, zAuditLogsListData, zAuditLogsListResponse, zAvailableContextsListData, zAvailableContextsListResponse, zContextSwitchSwitchData, zContextSwitchSwitchResponse, zCouponsAdminCreateData, zCouponsAdminCreateResponse, zCouponsAdminDeleteData, zCouponsAdminDeleteResponse, zCouponsAdminGetData, zCouponsAdminGetResponse, zCouponsAdminListData, zCouponsAdminListResponse, zCouponsAdminUpdateData, zCouponsAdminUpdateResponse, zCurrentUserContextGetData, zCurrentUserContextGetResponse, zExampleCommentsBatchCreateData, zExampleCommentsBatchCreateResponse, zExampleCommentsBatchSoftDeleteData, zExampleCommentsBatchSoftDeleteResponse, zExampleCommentsCreateData, zExampleCommentsCreateResponse, zExampleCommentsDeleteData, zExampleCommentsDeletePermanentData, zExampleCommentsDeletePermanentResponse, zExampleCommentsDeleteResponse, zExampleCommentsGetData, zExampleCommentsGetResponse, zExampleCommentsListData, zExampleCommentsListResponse, zExampleCommentsRestoreData, zExampleCommentsRestoreResponse, zExampleCommentsUpdateData, zExampleCommentsUpdateResponse, zExamplePostsBatchCreateData, zExamplePostsBatchCreateResponse, zExamplePostsBatchRestoreData, zExamplePostsBatchRestoreResponse, zExamplePostsBatchSoftDeleteData, zExamplePostsBatchSoftDeleteResponse, zExamplePostsBatchUpdateData, zExamplePostsBatchUpdateResponse, zExamplePostsCreateData, zExamplePostsCreateResponse, zExamplePostsDeleteData, zExamplePostsDeletePermanentData, zExamplePostsDeletePermanentResponse, zExamplePostsDeleteResponse, zExamplePostsGetData, zExamplePostsGetResponse, zExamplePostsListCursorData, zExamplePostsListCursorResponse, zExamplePostsListData, zExamplePostsListDeletedData, zExamplePostsListDeletedResponse, zExamplePostsListResponse, zExamplePostsRestoreData, zExamplePostsRestoreResponse, zExamplePostsUpdateData, zExamplePostsUpdateResponse, zFilesConfirmUploadData, zFilesConfirmUploadResponse, zFilesDeleteData, zFilesDeletePermanentData, zFilesDeletePermanentResponse, zFilesDeleteResponse, zFilesDirectUploadData, zFilesDirectUploadResponse, zFilesDownloadData, zFilesDownloadResponse, zFilesGetData, zFilesGetResponse, zFilesInitiateUploadData, zFilesInitiateUploadResponse, zFilesListData, zFilesListResponse, zFilesUpdateData, zFilesUpdateResponse, zGlobalRolesCreateData, zGlobalRolesCreateResponse, zGlobalRolesDeleteData, zGlobalRolesDeleteResponse, zGlobalRolesGetData, zGlobalRolesGetResponse, zGlobalRolesListData, zGlobalRolesListResponse, zGlobalRolesUpdateData, zGlobalRolesUpdateResponse, zHealthCheckData, zHealthCheckResponse, zJobsCancelData, zJobsCancelResponse, zJobsDownloadData, zJobsDownloadResponse, zJobsGetData, zJobsGetResponse, zJobsListData, zJobsListResponse, zJobsRetryData, zJobsRetryResponse, zMigrationGetStatusData, zMigrationGetStatusResponse, zNotificationPreferencesRoutesGetPreferencesData, zNotificationPreferencesRoutesGetPreferencesResponse, zNotificationPreferencesRoutesUpdatePreferencesData, zNotificationPreferencesRoutesUpdatePreferencesResponse, zNotificationsDeleteData, zNotificationsDeleteResponse, zNotificationsGetData, zNotificationsGetResponse, zNotificationsGetUnreadCountData, zNotificationsGetUnreadCountResponse, zNotificationsListData, zNotificationsListResponse, zNotificationsMarkAllReadData, zNotificationsMarkAllReadResponse, zNotificationsMarkReadData, zNotificationsMarkReadResponse, zNotificationsMarkUnreadData, zNotificationsMarkUnreadResponse, zNotificationsPreviewEmailData, zNotificationsPreviewEmailResponse, zNotificationsRestoreData, zNotificationsRestoreResponse, zNotificationsSendData, zNotificationsSendResponse, zPaymentWebhooksHandleMidtransData, zPaymentWebhooksHandleMidtransResponse, zPaymentWebhooksHandleXenditData, zPaymentWebhooksHandleXenditResponse, zPublicPricingListPublicPlansData, zPublicPricingListPublicPlansResponse, zReportExportsExportData, zReportExportsExportResponse, zReportExportsPreviewExportData, zReportExportsPreviewExportResponse, zReportExportsStreamExportData, zReportExportsStreamExportResponse, zReportTemplatesCloneData, zReportTemplatesCloneResponse, zReportTemplatesCreateData, zReportTemplatesCreateResponse, zReportTemplatesDeleteData, zReportTemplatesDeleteResponse, zReportTemplatesGetData, zReportTemplatesGetResponse, zReportTemplatesListData, zReportTemplatesListResponse, zReportTemplatesTestData, zReportTemplatesTestResponse, zReportTemplatesUpdateData, zReportTemplatesUpdateResponse, zScheduledReportsCreateData, zScheduledReportsCreateResponse, zScheduledReportsDeleteData, zScheduledReportsDeleteResponse, zScheduledReportsGetData, zScheduledReportsGetHistoryData, zScheduledReportsGetHistoryResponse, zScheduledReportsGetResponse, zScheduledReportsListData, zScheduledReportsListResponse, zScheduledReportsPauseData, zScheduledReportsPauseResponse, zScheduledReportsResumeData, zScheduledReportsResumeResponse, zScheduledReportsRunNowData, zScheduledReportsRunNowResponse, zScheduledReportsUpdateData, zScheduledReportsUpdateResponse, zSubscriptionPlansAdminCreateData, zSubscriptionPlansAdminCreateResponse, zSubscriptionPlansAdminDeleteData, zSubscriptionPlansAdminDeleteResponse, zSubscriptionPlansAdminGetData, zSubscriptionPlansAdminGetResponse, zSubscriptionPlansAdminListData, zSubscriptionPlansAdminListResponse, zSubscriptionPlansAdminUpdateData, zSubscriptionPlansAdminUpdateResponse, zSubscriptionsApplyCouponData, zSubscriptionsApplyCouponResponse, zSubscriptionsCancelData, zSubscriptionsCancelResponse, zSubscriptionsCreateData, zSubscriptionsCreateResponse, zSubscriptionsGetCurrentData, zSubscriptionsGetCurrentResponse, zSubscriptionsResumeData, zSubscriptionsResumeResponse, zSubscriptionsUpdateData, zSubscriptionsUpdateResponse, zSubscriptionsValidateCouponData, zSubscriptionsValidateCouponResponse, zTenantRolesCreateData, zTenantRolesCreateResponse, zTenantRolesDeleteData, zTenantRolesDeleteResponse, zTenantRolesGetData, zTenantRolesGetResponse, zTenantRolesListData, zTenantRolesListResponse, zTenantRolesUpdateData, zTenantRolesUpdateResponse, zUserPermissionsGetData, zUserPermissionsGetResponse, zUserTenantRolesAssignData, zUserTenantRolesAssignResponse, zUserTenantRolesListData, zUserTenantRolesListResponse, zUserTenantRolesRemoveData, zUserTenantRolesRemoveResponse, zWebhooksCreateData, zWebhooksCreateResponse, zWebhooksDeleteData, zWebhooksDeleteResponse, zWebhooksGetData, zWebhooksGetDeliveryData, zWebhooksGetDeliveryResponse, zWebhooksGetResponse, zWebhooksListData, zWebhooksListDeliveriesData, zWebhooksListDeliveriesResponse, zWebhooksListEventTypesData, zWebhooksListEventTypesResponse, zWebhooksListResponse, zWebhooksRetryDeliveryData, zWebhooksRetryDeliveryResponse, zWebhooksRotateSecretData, zWebhooksRotateSecretResponse, zWebhooksTestData, zWebhooksTestResponse, zWebhooksUpdateData, zWebhooksUpdateResponse } from './zod.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Health check
 *
 * Check API health status
 * Returns 200 OK if the API is healthy
 */
export const healthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthCheckData, ThrowOnError>) => (options?.client ?? client).get<HealthCheckResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zHealthCheckData.parseAsync(data),
    responseValidator: async (data) => await zHealthCheckResponse.parseAsync(data),
    url: '/health',
    ...options
});

/**
 * List coupons
 *
 * List coupons
 *
 * Returns all coupons with optional filtering.
 */
export const couponsAdminList = <ThrowOnError extends boolean = false>(options?: Options<CouponsAdminListData, ThrowOnError>) => (options?.client ?? client).get<CouponsAdminListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCouponsAdminListData.parseAsync(data),
    responseValidator: async (data) => await zCouponsAdminListResponse.parseAsync(data),
    url: '/v1/admin/coupons',
    ...options
});

/**
 * Create coupon
 *
 * Create coupon
 *
 * Creates a new discount coupon.
 */
export const couponsAdminCreate = <ThrowOnError extends boolean = false>(options: Options<CouponsAdminCreateData, ThrowOnError>) => (options.client ?? client).post<CouponsAdminCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCouponsAdminCreateData.parseAsync(data),
    responseValidator: async (data) => await zCouponsAdminCreateResponse.parseAsync(data),
    url: '/v1/admin/coupons',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete coupon
 *
 * Delete coupon
 *
 * Soft deletes a coupon (sets isActive to false).
 */
export const couponsAdminDelete = <ThrowOnError extends boolean = false>(options: Options<CouponsAdminDeleteData, ThrowOnError>) => (options.client ?? client).delete<CouponsAdminDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCouponsAdminDeleteData.parseAsync(data),
    responseValidator: async (data) => await zCouponsAdminDeleteResponse.parseAsync(data),
    url: '/v1/admin/coupons/{couponId}',
    ...options
});

/**
 * Get coupon
 *
 * Get coupon
 *
 * Returns a single coupon by ID.
 */
export const couponsAdminGet = <ThrowOnError extends boolean = false>(options: Options<CouponsAdminGetData, ThrowOnError>) => (options.client ?? client).get<CouponsAdminGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCouponsAdminGetData.parseAsync(data),
    responseValidator: async (data) => await zCouponsAdminGetResponse.parseAsync(data),
    url: '/v1/admin/coupons/{couponId}',
    ...options
});

/**
 * Update coupon
 *
 * Update coupon
 *
 * Updates an existing coupon.
 */
export const couponsAdminUpdate = <ThrowOnError extends boolean = false>(options: Options<CouponsAdminUpdateData, ThrowOnError>) => (options.client ?? client).patch<CouponsAdminUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCouponsAdminUpdateData.parseAsync(data),
    responseValidator: async (data) => await zCouponsAdminUpdateResponse.parseAsync(data),
    url: '/v1/admin/coupons/{couponId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List subscription plans
 *
 * List subscription plans
 *
 * Returns all plans with optional filtering.
 * Admin endpoint - returns all plans including archived.
 */
export const subscriptionPlansAdminList = <ThrowOnError extends boolean = false>(options?: Options<SubscriptionPlansAdminListData, ThrowOnError>) => (options?.client ?? client).get<SubscriptionPlansAdminListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionPlansAdminListData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionPlansAdminListResponse.parseAsync(data),
    url: '/v1/admin/plans',
    ...options
});

/**
 * Create subscription plan
 *
 * Create subscription plan
 *
 * Creates a new subscription plan.
 */
export const subscriptionPlansAdminCreate = <ThrowOnError extends boolean = false>(options: Options<SubscriptionPlansAdminCreateData, ThrowOnError>) => (options.client ?? client).post<SubscriptionPlansAdminCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionPlansAdminCreateData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionPlansAdminCreateResponse.parseAsync(data),
    url: '/v1/admin/plans',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete subscription plan
 *
 * Delete subscription plan
 *
 * Soft deletes a plan (sets visibility to archived).
 * Plans with active subscriptions cannot be hard deleted.
 */
export const subscriptionPlansAdminDelete = <ThrowOnError extends boolean = false>(options: Options<SubscriptionPlansAdminDeleteData, ThrowOnError>) => (options.client ?? client).delete<SubscriptionPlansAdminDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionPlansAdminDeleteData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionPlansAdminDeleteResponse.parseAsync(data),
    url: '/v1/admin/plans/{planId}',
    ...options
});

/**
 * Get subscription plan
 *
 * Get subscription plan
 *
 * Returns a single plan by ID.
 */
export const subscriptionPlansAdminGet = <ThrowOnError extends boolean = false>(options: Options<SubscriptionPlansAdminGetData, ThrowOnError>) => (options.client ?? client).get<SubscriptionPlansAdminGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionPlansAdminGetData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionPlansAdminGetResponse.parseAsync(data),
    url: '/v1/admin/plans/{planId}',
    ...options
});

/**
 * Update subscription plan
 *
 * Update subscription plan
 *
 * Updates an existing subscription plan.
 * Warning: Changing pricing affects future billing only.
 */
export const subscriptionPlansAdminUpdate = <ThrowOnError extends boolean = false>(options: Options<SubscriptionPlansAdminUpdateData, ThrowOnError>) => (options.client ?? client).patch<SubscriptionPlansAdminUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionPlansAdminUpdateData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionPlansAdminUpdateResponse.parseAsync(data),
    url: '/v1/admin/plans/{planId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get API version migration status
 *
 * Get migration status for the current API version
 *
 * Returns information about:
 * - Current version status (current, deprecated, sunset)
 * - Sunset date if deprecated
 * - Replacement version to migrate to
 * - Breaking changes and migration checklist
 */
export const migrationGetStatus = <ThrowOnError extends boolean = false>(options?: Options<MigrationGetStatusData, ThrowOnError>) => (options?.client ?? client).get<MigrationGetStatusResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zMigrationGetStatusData.parseAsync(data),
    responseValidator: async (data) => await zMigrationGetStatusResponse.parseAsync(data),
    url: '/v1/migration/status',
    ...options
});

/**
 * List notifications
 *
 * List user's notification history
 * Returns notifications for the authenticated user, excluding soft-deleted ones
 */
export const notificationsList = <ThrowOnError extends boolean = false>(options?: Options<NotificationsListData, ThrowOnError>) => (options?.client ?? client).get<NotificationsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsListData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsListResponse.parseAsync(data),
    url: '/v1/notifications',
    ...options
});

/**
 * Mark all notifications as read
 *
 * Mark all notifications as read for the current user
 * Returns the count of notifications that were marked as read
 */
export const notificationsMarkAllRead = <ThrowOnError extends boolean = false>(options?: Options<NotificationsMarkAllReadData, ThrowOnError>) => (options?.client ?? client).post<NotificationsMarkAllReadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsMarkAllReadData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsMarkAllReadResponse.parseAsync(data),
    url: '/v1/notifications/mark-all-read',
    ...options
});

/**
 * Preview email template
 *
 * Preview an email template
 * Renders the template with provided data and returns HTML/text content
 */
export const notificationsPreviewEmail = <ThrowOnError extends boolean = false>(options: Options<NotificationsPreviewEmailData, ThrowOnError>) => (options.client ?? client).post<NotificationsPreviewEmailResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsPreviewEmailData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsPreviewEmailResponse.parseAsync(data),
    url: '/v1/notifications/preview-email',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Send notification
 *
 * Send a notification
 * Queues the notification for delivery through the specified channel
 * Requires authentication. Consider adding authorization for production use.
 */
export const notificationsSend = <ThrowOnError extends boolean = false>(options: Options<NotificationsSendData, ThrowOnError>) => (options.client ?? client).post<NotificationsSendResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsSendData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsSendResponse.parseAsync(data),
    url: '/v1/notifications/send',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get unread notification count
 *
 * Get count of unread notifications
 * Returns the number of unread notifications for the current user
 */
export const notificationsGetUnreadCount = <ThrowOnError extends boolean = false>(options?: Options<NotificationsGetUnreadCountData, ThrowOnError>) => (options?.client ?? client).get<NotificationsGetUnreadCountResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsGetUnreadCountData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsGetUnreadCountResponse.parseAsync(data),
    url: '/v1/notifications/unread/count',
    ...options
});

/**
 * Delete notification
 *
 * Soft delete a notification
 * Marks the notification as deleted without actually removing it
 */
export const notificationsDelete = <ThrowOnError extends boolean = false>(options: Options<NotificationsDeleteData, ThrowOnError>) => (options.client ?? client).delete<NotificationsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsDeleteResponse.parseAsync(data),
    url: '/v1/notifications/{id}',
    ...options
});

/**
 * Get notification by ID
 *
 * Get a specific notification by ID
 * Only returns notifications owned by the authenticated user
 */
export const notificationsGet = <ThrowOnError extends boolean = false>(options: Options<NotificationsGetData, ThrowOnError>) => (options.client ?? client).get<NotificationsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsGetData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsGetResponse.parseAsync(data),
    url: '/v1/notifications/{id}',
    ...options
});

/**
 * Mark notification as read
 *
 * Mark a notification as read
 * Updates the readAt timestamp for the notification
 */
export const notificationsMarkRead = <ThrowOnError extends boolean = false>(options: Options<NotificationsMarkReadData, ThrowOnError>) => (options.client ?? client).patch<NotificationsMarkReadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsMarkReadData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsMarkReadResponse.parseAsync(data),
    url: '/v1/notifications/{id}/read',
    ...options
});

/**
 * Restore notification
 *
 * Restore a soft-deleted notification
 * Clears the deletedAt timestamp to restore the notification
 */
export const notificationsRestore = <ThrowOnError extends boolean = false>(options: Options<NotificationsRestoreData, ThrowOnError>) => (options.client ?? client).post<NotificationsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsRestoreResponse.parseAsync(data),
    url: '/v1/notifications/{id}/restore',
    ...options
});

/**
 * Mark notification as unread
 *
 * Mark a notification as unread
 * Clears the readAt timestamp for the notification
 */
export const notificationsMarkUnread = <ThrowOnError extends boolean = false>(options: Options<NotificationsMarkUnreadData, ThrowOnError>) => (options.client ?? client).patch<NotificationsMarkUnreadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationsMarkUnreadData.parseAsync(data),
    responseValidator: async (data) => await zNotificationsMarkUnreadResponse.parseAsync(data),
    url: '/v1/notifications/{id}/unread',
    ...options
});

/**
 * List active announcements
 *
 * List active announcements for the organization
 * Returns only published, non-expired announcements targeted to the user's role
 * Includes user interaction data (viewed, read, dismissed, acknowledged)
 */
export const announcementsList = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsListData, ThrowOnError>) => (options.client ?? client).get<AnnouncementsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsListData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements',
    ...options
});

/**
 * Create announcement
 *
 * Create a new announcement
 * Requires admin permission
 */
export const announcementsCreate = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsCreateData, ThrowOnError>) => (options.client ?? client).post<AnnouncementsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsCreateData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get unread announcement count
 *
 * Get unread announcement count for current user
 * Returns count of unread announcements and critical announcements needing acknowledgment
 */
export const announcementsGetUnreadCount = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsGetUnreadCountData, ThrowOnError>) => (options.client ?? client).get<AnnouncementsGetUnreadCountResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsGetUnreadCountData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsGetUnreadCountResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/unread-count',
    ...options
});

/**
 * Delete announcement
 *
 * Delete an announcement (soft delete)
 * Requires admin permission or ownership
 */
export const announcementsDelete = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsDeleteData, ThrowOnError>) => (options.client ?? client).delete<AnnouncementsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/{announcementId}',
    ...options
});

/**
 * Get announcement by ID
 *
 * Get a specific announcement by ID
 * Includes user interaction data
 */
export const announcementsGet = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsGetData, ThrowOnError>) => (options.client ?? client).get<AnnouncementsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsGetData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/{announcementId}',
    ...options
});

/**
 * Update announcement
 *
 * Update an announcement
 * Requires admin permission or ownership
 */
export const announcementsUpdate = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsUpdateData, ThrowOnError>) => (options.client ?? client).patch<AnnouncementsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/{announcementId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Acknowledge critical announcement
 *
 * Acknowledge a critical announcement
 * Required for critical priority announcements
 */
export const announcementsAcknowledge = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsAcknowledgeData, ThrowOnError>) => (options.client ?? client).post<AnnouncementsAcknowledgeResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsAcknowledgeData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsAcknowledgeResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/acknowledge',
    ...options
});

/**
 * Dismiss announcement
 *
 * Dismiss an announcement
 * Hides the announcement from the user's view
 */
export const announcementsDismiss = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsDismissData, ThrowOnError>) => (options.client ?? client).post<AnnouncementsDismissResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsDismissData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsDismissResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/dismiss',
    ...options
});

/**
 * Mark announcement as read
 *
 * Mark announcement as read
 * Called when user opens/expands the announcement
 */
export const announcementsMarkRead = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsMarkReadData, ThrowOnError>) => (options.client ?? client).post<AnnouncementsMarkReadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsMarkReadData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsMarkReadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/read',
    ...options
});

/**
 * Get announcement statistics
 *
 * Get announcement statistics
 * Returns analytics data for a specific announcement
 * Requires admin permission
 */
export const announcementsGetStats = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsGetStatsData, ThrowOnError>) => (options.client ?? client).get<AnnouncementsGetStatsResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsGetStatsData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsGetStatsResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/stats',
    ...options
});

/**
 * Mark announcement as viewed
 *
 * Mark announcement as viewed
 * Automatically called when announcement is displayed to user
 */
export const announcementsMarkViewed = <ThrowOnError extends boolean = false>(options: Options<AnnouncementsMarkViewedData, ThrowOnError>) => (options.client ?? client).post<AnnouncementsMarkViewedResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAnnouncementsMarkViewedData.parseAsync(data),
    responseValidator: async (data) => await zAnnouncementsMarkViewedResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/view',
    ...options
});

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsList = <ThrowOnError extends boolean = false>(options: Options<AuditLogsListData, ThrowOnError>) => (options.client ?? client).get<AuditLogsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsListData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs',
    ...options
});

/**
 * Export audit logs
 *
 * Export audit logs
 *
 * Returns a download URL for audit logs in CSV or JSON format.
 * For large exports, returns 202 Accepted with a job ID.
 */
export const auditLogsExport = <ThrowOnError extends boolean = false>(options: Options<AuditLogsExportData, ThrowOnError>) => (options.client ?? client).post<AuditLogsExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsExportData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs/export',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get audit log entry
 *
 * Get a single audit log entry
 */
export const auditLogsGet = <ThrowOnError extends boolean = false>(options: Options<AuditLogsGetData, ThrowOnError>) => (options.client ?? client).get<AuditLogsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsGetData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs/{eventId}',
    ...options
});

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsList = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts',
    ...options
});

/**
 * Create example post
 *
 * Create a new post
 */
export const examplePostsCreate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsCreateData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsCreateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch update example posts
 *
 * Batch update posts
 */
export const examplePostsBatchUpdate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExamplePostsBatchUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create example posts
 *
 * Batch create posts
 */
export const examplePostsBatchCreate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchCreateData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch restore example posts
 *
 * Batch restore soft-deleted posts
 */
export const examplePostsBatchRestore = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchRestoreData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch/restore',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete example posts
 *
 * Batch soft delete posts
 */
export const examplePostsBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursor = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListCursorData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListCursorResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListCursorData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListCursorResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/cursor',
    ...options
});

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeleted = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListDeletedData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListDeletedResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListDeletedData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListDeletedResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/deleted',
    ...options
});

/**
 * Soft delete example post
 *
 * Soft delete a post (default delete behavior)
 * Post is marked as deleted but can be restored
 */
export const examplePostsDelete = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ExamplePostsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options
});

/**
 * Get example post
 *
 * Get a single post by ID
 */
export const examplePostsGet = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsGetData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsGetData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options
});

/**
 * Update example post
 *
 * Update a post (partial update)
 */
export const examplePostsUpdate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExamplePostsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete example post
 *
 * Permanently delete a post (hard delete)
 * Post is permanently removed and cannot be restored
 */
export const examplePostsDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<ExamplePostsDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}/permanent',
    ...options
});

/**
 * Restore example post
 *
 * Restore a soft-deleted post
 */
export const examplePostsRestore = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsRestoreData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}/restore',
    ...options
});

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsList = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsListData, ThrowOnError>) => (options.client ?? client).get<ExampleCommentsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsListData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments',
    ...options
});

/**
 * Create comment on post
 *
 * Create a new comment on a post
 */
export const exampleCommentsCreate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsCreateData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsCreateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create comments
 *
 * Batch create comments
 */
export const exampleCommentsBatchCreate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsBatchCreateData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete comments
 *
 * Batch soft delete comments
 */
export const exampleCommentsBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Soft delete comment
 *
 * Soft delete a comment
 */
export const exampleCommentsDelete = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ExampleCommentsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options
});

/**
 * Get comment
 *
 * Get a single comment by ID
 */
export const exampleCommentsGet = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsGetData, ThrowOnError>) => (options.client ?? client).get<ExampleCommentsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsGetData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options
});

/**
 * Update comment
 *
 * Update a comment (partial update)
 */
export const exampleCommentsUpdate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExampleCommentsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete comment
 *
 * Permanently delete a comment (hard delete)
 */
export const exampleCommentsDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<ExampleCommentsDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/permanent',
    ...options
});

/**
 * Restore comment
 *
 * Restore a soft-deleted comment
 */
export const exampleCommentsRestore = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsRestoreData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/restore',
    ...options
});

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesList = <ThrowOnError extends boolean = false>(options: Options<FilesListData, ThrowOnError>) => (options.client ?? client).get<FilesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesListData.parseAsync(data),
    responseValidator: async (data) => await zFilesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files',
    ...options
});

/**
 * Direct file upload
 *
 * Direct file upload (multipart/form-data)
 *
 * For simple uploads of small files (< 10 MB).
 * File is uploaded directly to the API server.
 *
 * Note: For larger files or high volume, use presigned URL upload.
 */
export const filesDirectUpload = <ThrowOnError extends boolean = false>(options: Options<FilesDirectUploadData, ThrowOnError>) => (options.client ?? client).post<FilesDirectUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDirectUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesDirectUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files',
    ...options
});

/**
 * Initiate presigned URL upload
 *
 * Initiate a presigned URL upload
 *
 * Returns a presigned URL for direct upload to storage (S3/R2/GCS).
 * Client uploads directly to storage, then confirms with the API.
 *
 * Flow:
 * 1. POST /files/uploads - Get presigned URL
 * 2. PUT {presignedUrl} - Upload directly to storage
 * 3. POST /files/uploads/{uploadId}/confirm - Confirm upload
 */
export const filesInitiateUpload = <ThrowOnError extends boolean = false>(options: Options<FilesInitiateUploadData, ThrowOnError>) => (options.client ?? client).post<FilesInitiateUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesInitiateUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesInitiateUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/uploads',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Confirm presigned URL upload
 *
 * Confirm a presigned URL upload
 *
 * Called after client successfully uploads to the presigned URL.
 * Triggers virus scanning and creates the file record.
 */
export const filesConfirmUpload = <ThrowOnError extends boolean = false>(options: Options<FilesConfirmUploadData, ThrowOnError>) => (options.client ?? client).post<FilesConfirmUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesConfirmUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesConfirmUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/uploads/{uploadId}/confirm',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete file
 *
 * Delete a file (soft delete)
 *
 * File is marked as deleted but retained for audit purposes.
 * Storage is cleaned up after retention period.
 */
export const filesDelete = <ThrowOnError extends boolean = false>(options: Options<FilesDeleteData, ThrowOnError>) => (options.client ?? client).delete<FilesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zFilesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options
});

/**
 * Get file
 *
 * Get a single file by ID
 *
 * Returns file metadata including a fresh signed URL for download.
 */
export const filesGet = <ThrowOnError extends boolean = false>(options: Options<FilesGetData, ThrowOnError>) => (options.client ?? client).get<FilesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesGetData.parseAsync(data),
    responseValidator: async (data) => await zFilesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options
});

/**
 * Update file
 *
 * Update file properties
 *
 * Currently supports changing the access level (private/public).
 */
export const filesUpdate = <ThrowOnError extends boolean = false>(options: Options<FilesUpdateData, ThrowOnError>) => (options.client ?? client).patch<FilesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zFilesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Download file
 *
 * Download a file
 *
 * Returns a redirect to a signed URL for the file.
 * The signed URL expires in 5 minutes.
 */
export const filesDownload = <ThrowOnError extends boolean = false>(options: Options<FilesDownloadData, ThrowOnError>) => (options.client ?? client).get<FilesDownloadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDownloadData.parseAsync(data),
    responseValidator: async (data) => await zFilesDownloadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}/download',
    ...options
});

/**
 * Permanently delete file
 *
 * Permanently delete a file (hard delete)
 *
 * Immediately removes file from storage.
 * Use with caution - cannot be undone.
 */
export const filesDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<FilesDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<FilesDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zFilesDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}/permanent',
    ...options
});

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant with optional filtering.
 */
export const jobsList = <ThrowOnError extends boolean = false>(options: Options<JobsListData, ThrowOnError>) => (options.client ?? client).get<JobsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsListData.parseAsync(data),
    responseValidator: async (data) => await zJobsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs',
    ...options
});

/**
 * Get job status
 *
 * Get job status
 *
 * Poll this endpoint to check progress of async operations.
 */
export const jobsGet = <ThrowOnError extends boolean = false>(options: Options<JobsGetData, ThrowOnError>) => (options.client ?? client).get<JobsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsGetData.parseAsync(data),
    responseValidator: async (data) => await zJobsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}',
    ...options
});

/**
 * Cancel job
 *
 * Cancel a job
 *
 * Only pending or processing jobs can be cancelled.
 */
export const jobsCancel = <ThrowOnError extends boolean = false>(options: Options<JobsCancelData, ThrowOnError>) => (options.client ?? client).post<JobsCancelResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsCancelData.parseAsync(data),
    responseValidator: async (data) => await zJobsCancelResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}/cancel',
    ...options
});

/**
 * Download job result
 *
 * Download job result
 *
 * Downloads the file generated by a completed job (e.g., report exports).
 * Only available for jobs that produce downloadable files.
 */
export const jobsDownload = <ThrowOnError extends boolean = false>(options: Options<JobsDownloadData, ThrowOnError>) => (options.client ?? client).get<JobsDownloadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsDownloadData.parseAsync(data),
    responseValidator: async (data) => await zJobsDownloadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}/download',
    ...options
});

/**
 * Retry job
 *
 * Retry a failed job
 *
 * Creates a new job with the same parameters as the failed job.
 */
export const jobsRetry = <ThrowOnError extends boolean = false>(options: Options<JobsRetryData, ThrowOnError>) => (options.client ?? client).post<JobsRetryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsRetryData.parseAsync(data),
    responseValidator: async (data) => await zJobsRetryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}/retry',
    ...options
});

/**
 * Export data
 *
 * Export data synchronously
 *
 * For small datasets (<10,000 rows). Returns the file directly.
 * For larger datasets, use async=true to get a job ID.
 */
export const reportExportsExport = <ThrowOnError extends boolean = false>(options: Options<ReportExportsExportData, ThrowOnError>) => (options.client ?? client).post<ReportExportsExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportExportsExportData.parseAsync(data),
    responseValidator: async (data) => await zReportExportsExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/export',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Preview export
 *
 * Preview export (first N rows)
 *
 * Useful for testing templates and verifying data before full export.
 */
export const reportExportsPreviewExport = <ThrowOnError extends boolean = false>(options: Options<ReportExportsPreviewExportData, ThrowOnError>) => (options.client ?? client).post<ReportExportsPreviewExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportExportsPreviewExportData.parseAsync(data),
    responseValidator: async (data) => await zReportExportsPreviewExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/export/preview',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Stream export data
 *
 * Export data as streaming response
 *
 * For large datasets. Streams data in chunks as it's generated.
 * Only supports CSV and Excel formats.
 */
export const reportExportsStreamExport = <ThrowOnError extends boolean = false>(options: Options<ReportExportsStreamExportData, ThrowOnError>) => (options.client ?? client).post<ReportExportsStreamExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportExportsStreamExportData.parseAsync(data),
    responseValidator: async (data) => await zReportExportsStreamExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/export/stream',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List scheduled reports
 *
 * List scheduled reports in an organization
 */
export const scheduledReportsList = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsListData, ThrowOnError>) => (options.client ?? client).get<ScheduledReportsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsListData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules',
    ...options
});

/**
 * Create scheduled report
 *
 * Create a new scheduled report
 */
export const scheduledReportsCreate = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsCreateData, ThrowOnError>) => (options.client ?? client).post<ScheduledReportsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsCreateData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete scheduled report
 *
 * Delete a scheduled report
 */
export const scheduledReportsDelete = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ScheduledReportsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}',
    ...options
});

/**
 * Get scheduled report
 *
 * Get a scheduled report by ID
 */
export const scheduledReportsGet = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsGetData, ThrowOnError>) => (options.client ?? client).get<ScheduledReportsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsGetData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}',
    ...options
});

/**
 * Update scheduled report
 *
 * Update a scheduled report
 */
export const scheduledReportsUpdate = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ScheduledReportsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get schedule run history
 *
 * Get run history for a scheduled report
 */
export const scheduledReportsGetHistory = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsGetHistoryData, ThrowOnError>) => (options.client ?? client).get<ScheduledReportsGetHistoryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsGetHistoryData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsGetHistoryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}/history',
    ...options
});

/**
 * Pause scheduled report
 *
 * Pause a scheduled report
 */
export const scheduledReportsPause = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsPauseData, ThrowOnError>) => (options.client ?? client).post<ScheduledReportsPauseResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsPauseData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsPauseResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}/pause',
    ...options
});

/**
 * Resume scheduled report
 *
 * Resume a paused scheduled report
 */
export const scheduledReportsResume = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsResumeData, ThrowOnError>) => (options.client ?? client).post<ScheduledReportsResumeResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsResumeData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsResumeResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}/resume',
    ...options
});

/**
 * Run scheduled report now
 *
 * Trigger a scheduled report to run immediately
 */
export const scheduledReportsRunNow = <ThrowOnError extends boolean = false>(options: Options<ScheduledReportsRunNowData, ThrowOnError>) => (options.client ?? client).post<ScheduledReportsRunNowResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zScheduledReportsRunNowData.parseAsync(data),
    responseValidator: async (data) => await zScheduledReportsRunNowResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/schedules/{scheduleId}/run',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List report templates
 *
 * List report templates in an organization
 */
export const reportTemplatesList = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesListData, ThrowOnError>) => (options.client ?? client).get<ReportTemplatesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesListData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates',
    ...options
});

/**
 * Create report template
 *
 * Create a new report template
 */
export const reportTemplatesCreate = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesCreateData, ThrowOnError>) => (options.client ?? client).post<ReportTemplatesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesCreateData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete report template
 *
 * Delete a report template
 */
export const reportTemplatesDelete = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesDeleteData, ThrowOnError>) => (options.client ?? client).delete<ReportTemplatesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}',
    ...options
});

/**
 * Get report template
 *
 * Get a report template by ID
 */
export const reportTemplatesGet = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesGetData, ThrowOnError>) => (options.client ?? client).get<ReportTemplatesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesGetData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}',
    ...options
});

/**
 * Update report template
 *
 * Update a report template
 */
export const reportTemplatesUpdate = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesUpdateData, ThrowOnError>) => (options.client ?? client).patch<ReportTemplatesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Clone report template
 *
 * Clone a report template
 */
export const reportTemplatesClone = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesCloneData, ThrowOnError>) => (options.client ?? client).post<ReportTemplatesCloneResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesCloneData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesCloneResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}/clone',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Test report template
 *
 * Test a report template with sample data
 */
export const reportTemplatesTest = <ThrowOnError extends boolean = false>(options: Options<ReportTemplatesTestData, ThrowOnError>) => (options.client ?? client).post<ReportTemplatesTestResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zReportTemplatesTestData.parseAsync(data),
    responseValidator: async (data) => await zReportTemplatesTestResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}/test',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesList = <ThrowOnError extends boolean = false>(options: Options<TenantRolesListData, ThrowOnError>) => (options.client ?? client).get<TenantRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesListData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles',
    ...options
});

/**
 * Create tenant role
 *
 * Create a tenant-scoped role
 *
 * Creates a custom role for this specific tenant.
 */
export const tenantRolesCreate = <ThrowOnError extends boolean = false>(options: Options<TenantRolesCreateData, ThrowOnError>) => (options.client ?? client).post<TenantRolesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesCreateData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const tenantRolesDelete = <ThrowOnError extends boolean = false>(options: Options<TenantRolesDeleteData, ThrowOnError>) => (options.client ?? client).delete<TenantRolesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options
});

/**
 * Get role
 *
 * Get a role by ID
 */
export const tenantRolesGet = <ThrowOnError extends boolean = false>(options: Options<TenantRolesGetData, ThrowOnError>) => (options.client ?? client).get<TenantRolesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesGetData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const tenantRolesUpdate = <ThrowOnError extends boolean = false>(options: Options<TenantRolesUpdateData, ThrowOnError>) => (options.client ?? client).patch<TenantRolesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Create subscription
 *
 * Create subscription
 *
 * Creates a new subscription for the organization.
 * Starts trial if configured, otherwise requires payment.
 */
export const subscriptionsCreate = <ThrowOnError extends boolean = false>(options: Options<SubscriptionsCreateData, ThrowOnError>) => (options.client ?? client).post<SubscriptionsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionsCreateData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/subscriptions',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get current subscription
 *
 * Get current subscription
 *
 * Returns the active subscription for the organization and application.
 */
export const subscriptionsGetCurrent = <ThrowOnError extends boolean = false>(options: Options<SubscriptionsGetCurrentData, ThrowOnError>) => (options.client ?? client).get<SubscriptionsGetCurrentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionsGetCurrentData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionsGetCurrentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/subscriptions/current',
    ...options
});

/**
 * Validate coupon
 *
 * Validate coupon
 *
 * Check if a coupon code is valid for a plan.
 * Does not apply the coupon.
 */
export const subscriptionsValidateCoupon = <ThrowOnError extends boolean = false>(options: Options<SubscriptionsValidateCouponData, ThrowOnError>) => (options.client ?? client).post<SubscriptionsValidateCouponResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionsValidateCouponData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionsValidateCouponResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/subscriptions/validate-coupon',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update subscription
 *
 * Update subscription
 *
 * Update subscription (change plan, update settings).
 * Plan changes may be immediate or scheduled for period end.
 */
export const subscriptionsUpdate = <ThrowOnError extends boolean = false>(options: Options<SubscriptionsUpdateData, ThrowOnError>) => (options.client ?? client).patch<SubscriptionsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/subscriptions/{subscriptionId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Cancel subscription
 *
 * Cancel subscription
 *
 * Cancel the subscription.
 * By default, access continues until period end.
 */
export const subscriptionsCancel = <ThrowOnError extends boolean = false>(options: Options<SubscriptionsCancelData, ThrowOnError>) => (options.client ?? client).post<SubscriptionsCancelResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionsCancelData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionsCancelResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/subscriptions/{subscriptionId}/cancel',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Apply coupon
 *
 * Apply coupon
 *
 * Apply a discount coupon to the subscription.
 */
export const subscriptionsApplyCoupon = <ThrowOnError extends boolean = false>(options: Options<SubscriptionsApplyCouponData, ThrowOnError>) => (options.client ?? client).post<SubscriptionsApplyCouponResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionsApplyCouponData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionsApplyCouponResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/subscriptions/{subscriptionId}/coupon',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Resume subscription
 *
 * Resume subscription
 *
 * Reactivate a canceled subscription before it expires.
 */
export const subscriptionsResume = <ThrowOnError extends boolean = false>(options: Options<SubscriptionsResumeData, ThrowOnError>) => (options.client ?? client).post<SubscriptionsResumeResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zSubscriptionsResumeData.parseAsync(data),
    responseValidator: async (data) => await zSubscriptionsResumeResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/subscriptions/{subscriptionId}/resume',
    ...options
});

/**
 * Get user effective permissions
 *
 * Get user's effective permissions in this tenant
 *
 * Returns all roles (global + tenant) and the combined effective permissions
 * after applying deny-override resolution.
 */
export const userPermissionsGet = <ThrowOnError extends boolean = false>(options: Options<UserPermissionsGetData, ThrowOnError>) => (options.client ?? client).get<UserPermissionsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserPermissionsGetData.parseAsync(data),
    responseValidator: async (data) => await zUserPermissionsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/permissions',
    ...options
});

/**
 * List user roles in tenant
 *
 * List roles assigned to a user in this tenant
 *
 * Returns both global and tenant-specific role assignments.
 */
export const userTenantRolesList = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesListData, ThrowOnError>) => (options.client ?? client).get<UserTenantRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesListData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles',
    ...options
});

/**
 * Assign role to user
 *
 * Assign a role to a user in this tenant
 */
export const userTenantRolesAssign = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesAssignData, ThrowOnError>) => (options.client ?? client).post<UserTenantRolesAssignResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesAssignData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesAssignResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Remove role from user
 *
 * Remove a role from a user
 */
export const userTenantRolesRemove = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesRemoveData, ThrowOnError>) => (options.client ?? client).delete<UserTenantRolesRemoveResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesRemoveData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesRemoveResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles/{roleId}',
    ...options
});

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksList = <ThrowOnError extends boolean = false>(options: Options<WebhooksListData, ThrowOnError>) => (options.client ?? client).get<WebhooksListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks',
    ...options
});

/**
 * Create webhook
 *
 * Create a new webhook
 *
 * The secret is only returned once in the response.
 * Store it securely for signature verification.
 */
export const webhooksCreate = <ThrowOnError extends boolean = false>(options: Options<WebhooksCreateData, ThrowOnError>) => (options.client ?? client).post<WebhooksCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksCreateData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List event types
 *
 * Get available event types
 *
 * Returns all event types that can be subscribed to.
 */
export const webhooksListEventTypes = <ThrowOnError extends boolean = false>(options: Options<WebhooksListEventTypesData, ThrowOnError>) => (options.client ?? client).get<WebhooksListEventTypesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListEventTypesData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListEventTypesResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/event-types',
    ...options
});

/**
 * Delete webhook
 *
 * Delete a webhook
 */
export const webhooksDelete = <ThrowOnError extends boolean = false>(options: Options<WebhooksDeleteData, ThrowOnError>) => (options.client ?? client).delete<WebhooksDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksDeleteData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options
});

/**
 * Get webhook
 *
 * Get a webhook by ID
 */
export const webhooksGet = <ThrowOnError extends boolean = false>(options: Options<WebhooksGetData, ThrowOnError>) => (options.client ?? client).get<WebhooksGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksGetData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options
});

/**
 * Update webhook
 *
 * Update a webhook
 */
export const webhooksUpdate = <ThrowOnError extends boolean = false>(options: Options<WebhooksUpdateData, ThrowOnError>) => (options.client ?? client).patch<WebhooksUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksUpdateData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveries = <ThrowOnError extends boolean = false>(options: Options<WebhooksListDeliveriesData, ThrowOnError>) => (options.client ?? client).get<WebhooksListDeliveriesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListDeliveriesData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListDeliveriesResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries',
    ...options
});

/**
 * Get webhook delivery
 *
 * Get a specific delivery
 */
export const webhooksGetDelivery = <ThrowOnError extends boolean = false>(options: Options<WebhooksGetDeliveryData, ThrowOnError>) => (options.client ?? client).get<WebhooksGetDeliveryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksGetDeliveryData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksGetDeliveryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}',
    ...options
});

/**
 * Retry delivery
 *
 * Retry a failed delivery
 *
 * Manually triggers a retry for a failed delivery.
 */
export const webhooksRetryDelivery = <ThrowOnError extends boolean = false>(options: Options<WebhooksRetryDeliveryData, ThrowOnError>) => (options.client ?? client).post<WebhooksRetryDeliveryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksRetryDeliveryData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksRetryDeliveryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}/retry',
    ...options
});

/**
 * Rotate webhook secret
 *
 * Rotate webhook secret
 *
 * Generates a new secret. The old secret immediately stops working.
 */
export const webhooksRotateSecret = <ThrowOnError extends boolean = false>(options: Options<WebhooksRotateSecretData, ThrowOnError>) => (options.client ?? client).post<WebhooksRotateSecretResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksRotateSecretData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksRotateSecretResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/rotate-secret',
    ...options
});

/**
 * Test webhook
 *
 * Test a webhook
 *
 * Sends a test event to verify the webhook is configured correctly.
 */
export const webhooksTest = <ThrowOnError extends boolean = false>(options: Options<WebhooksTestData, ThrowOnError>) => (options.client ?? client).post<WebhooksTestResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksTestData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksTestResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/test',
    ...options
});

/**
 * Get notification preferences
 *
 * Get notification preferences for the current user
 * Returns default values if no preferences are set
 */
export const notificationPreferencesRoutesGetPreferences = <ThrowOnError extends boolean = false>(options?: Options<NotificationPreferencesRoutesGetPreferencesData, ThrowOnError>) => (options?.client ?? client).get<NotificationPreferencesRoutesGetPreferencesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationPreferencesRoutesGetPreferencesData.parseAsync(data),
    responseValidator: async (data) => await zNotificationPreferencesRoutesGetPreferencesResponse.parseAsync(data),
    url: '/v1/preferences',
    ...options
});

/**
 * Update notification preferences
 *
 * Update notification preferences for the current user
 * Supports partial updates - only provided fields will be updated
 */
export const notificationPreferencesRoutesUpdatePreferences = <ThrowOnError extends boolean = false>(options: Options<NotificationPreferencesRoutesUpdatePreferencesData, ThrowOnError>) => (options.client ?? client).patch<NotificationPreferencesRoutesUpdatePreferencesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zNotificationPreferencesRoutesUpdatePreferencesData.parseAsync(data),
    responseValidator: async (data) => await zNotificationPreferencesRoutesUpdatePreferencesResponse.parseAsync(data),
    url: '/v1/preferences',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List public subscription plans
 *
 * List public plans
 *
 * Returns all public, active subscription plans.
 * Used for the public pricing page.
 */
export const publicPricingListPublicPlans = <ThrowOnError extends boolean = false>(options?: Options<PublicPricingListPublicPlansData, ThrowOnError>) => (options?.client ?? client).get<PublicPricingListPublicPlansResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zPublicPricingListPublicPlansData.parseAsync(data),
    responseValidator: async (data) => await zPublicPricingListPublicPlansResponse.parseAsync(data),
    url: '/v1/pricing/plans',
    ...options
});

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesList = <ThrowOnError extends boolean = false>(options?: Options<GlobalRolesListData, ThrowOnError>) => (options?.client ?? client).get<GlobalRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesListData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesListResponse.parseAsync(data),
    url: '/v1/roles',
    ...options
});

/**
 * Create global role
 *
 * Create a global role
 *
 * Creates a role that applies across all tenants.
 */
export const globalRolesCreate = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesCreateData, ThrowOnError>) => (options.client ?? client).post<GlobalRolesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesCreateData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesCreateResponse.parseAsync(data),
    url: '/v1/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const globalRolesDelete = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesDeleteData, ThrowOnError>) => (options.client ?? client).delete<GlobalRolesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesDeleteResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options
});

/**
 * Get role
 *
 * Get a role by ID
 */
export const globalRolesGet = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesGetData, ThrowOnError>) => (options.client ?? client).get<GlobalRolesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesGetData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesGetResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const globalRolesUpdate = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesUpdateData, ThrowOnError>) => (options.client ?? client).patch<GlobalRolesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesUpdateResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List available contexts
 *
 * List all available contexts for the current user
 *
 * Returns all applications and tenants the user has access to.
 */
export const availableContextsList = <ThrowOnError extends boolean = false>(options?: Options<AvailableContextsListData, ThrowOnError>) => (options?.client ?? client).get<AvailableContextsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAvailableContextsListData.parseAsync(data),
    responseValidator: async (data) => await zAvailableContextsListResponse.parseAsync(data),
    url: '/v1/users/me/available-contexts',
    ...options
});

/**
 * Get active context
 *
 * Get current user's active context
 *
 * Returns the currently active application and tenant for the user.
 * This is for UI state management, not authorization decisions.
 */
export const currentUserContextGet = <ThrowOnError extends boolean = false>(options?: Options<CurrentUserContextGetData, ThrowOnError>) => (options?.client ?? client).get<CurrentUserContextGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCurrentUserContextGetData.parseAsync(data),
    responseValidator: async (data) => await zCurrentUserContextGetResponse.parseAsync(data),
    url: '/v1/users/me/context',
    ...options
});

/**
 * Switch context
 *
 * Switch user's active context
 *
 * Changes the active application and/or tenant.
 * This is for UI state management, not authorization decisions.
 */
export const contextSwitchSwitch = <ThrowOnError extends boolean = false>(options: Options<ContextSwitchSwitchData, ThrowOnError>) => (options.client ?? client).post<ContextSwitchSwitchResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zContextSwitchSwitchData.parseAsync(data),
    responseValidator: async (data) => await zContextSwitchSwitchResponse.parseAsync(data),
    url: '/v1/users/me/switch-context',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all user roles
 *
 * List user's roles across all applications and tenants
 *
 * Returns all role assignments for the user across all contexts.
 */
export const allUserRolesList = <ThrowOnError extends boolean = false>(options: Options<AllUserRolesListData, ThrowOnError>) => (options.client ?? client).get<AllUserRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAllUserRolesListData.parseAsync(data),
    responseValidator: async (data) => await zAllUserRolesListResponse.parseAsync(data),
    url: '/v1/users/{userId}/roles',
    ...options
});

/**
 * Handle Midtrans webhook
 *
 * Midtrans webhook handler
 *
 * Receives webhook events from Midtrans.
 */
export const paymentWebhooksHandleMidtrans = <ThrowOnError extends boolean = false>(options: Options<PaymentWebhooksHandleMidtransData, ThrowOnError>) => (options.client ?? client).post<PaymentWebhooksHandleMidtransResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zPaymentWebhooksHandleMidtransData.parseAsync(data),
    responseValidator: async (data) => await zPaymentWebhooksHandleMidtransResponse.parseAsync(data),
    url: '/v1/webhooks/payments/midtrans',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Handle Xendit webhook
 *
 * Xendit webhook handler
 *
 * Receives webhook events from Xendit.
 * Verifies signature via x-callback-token header.
 */
export const paymentWebhooksHandleXendit = <ThrowOnError extends boolean = false>(options: Options<PaymentWebhooksHandleXenditData, ThrowOnError>) => (options.client ?? client).post<PaymentWebhooksHandleXenditResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zPaymentWebhooksHandleXenditData.parseAsync(data),
    responseValidator: async (data) => await zPaymentWebhooksHandleXenditResponse.parseAsync(data),
    url: '/v1/webhooks/payments/xendit',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});
