// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { ApiKeysCreateData, ApiKeysCreateResponses, ApiKeysGetData, ApiKeysGetResponses, ApiKeysListData, ApiKeysListResponses, ApiKeysRevokeData, ApiKeysRevokeResponses, ApiKeysRotateData, ApiKeysRotateResponses, ApiKeysUpdateData, ApiKeysUpdateResponses, AuditLogsExportData, AuditLogsExportResponses, AuditLogsGetData, AuditLogsGetResponses, AuditLogsListData, AuditLogsListResponses, CrossTenantRolesListData, CrossTenantRolesListResponses, ExampleCommentsBatchCreateData, ExampleCommentsBatchCreateResponses, ExampleCommentsBatchSoftDeleteData, ExampleCommentsBatchSoftDeleteResponses, ExampleCommentsCreateData, ExampleCommentsCreateResponses, ExampleCommentsDeleteData, ExampleCommentsDeletePermanentData, ExampleCommentsDeletePermanentResponses, ExampleCommentsDeleteResponses, ExampleCommentsGetData, ExampleCommentsGetResponses, ExampleCommentsListData, ExampleCommentsListResponses, ExampleCommentsRestoreData, ExampleCommentsRestoreResponses, ExampleCommentsUpdateData, ExampleCommentsUpdateResponses, ExamplePostsBatchCreateData, ExamplePostsBatchCreateResponses, ExamplePostsBatchSoftDeleteData, ExamplePostsBatchSoftDeleteResponses, ExamplePostsBatchUpdateData, ExamplePostsBatchUpdateResponses, ExamplePostsCreateData, ExamplePostsCreateResponses, ExamplePostsDeleteData, ExamplePostsDeletePermanentData, ExamplePostsDeletePermanentResponses, ExamplePostsDeleteResponses, ExamplePostsGetData, ExamplePostsGetResponses, ExamplePostsListData, ExamplePostsListResponses, ExamplePostsRestoreData, ExamplePostsRestoreResponses, ExamplePostsUpdateData, ExamplePostsUpdateResponses, FilesConfirmUploadData, FilesConfirmUploadResponses, FilesDeleteData, FilesDeletePermanentData, FilesDeletePermanentResponses, FilesDeleteResponses, FilesDirectUploadData, FilesDirectUploadResponses, FilesDownloadData, FilesDownloadResponses, FilesGetData, FilesGetResponses, FilesInitiateUploadData, FilesInitiateUploadResponses, FilesListData, FilesListResponses, HealthCheckData, HealthCheckResponses, JobsCancelData, JobsCancelResponses, JobsGetData, JobsGetResponses, JobsListData, JobsListResponses, RolesCreateData, RolesCreateResponses, RolesDeleteData, RolesDeleteResponses, RolesGetData, RolesGetResponses, RolesListData, RolesListResponses, RolesUpdateData, RolesUpdateResponses, TenantSwitchSwitchData, TenantSwitchSwitchResponses, UserPermissionsEndpointGetData, UserPermissionsEndpointGetResponses, UserRolesAssignData, UserRolesAssignResponses, UserRolesListData, UserRolesListResponses, UserRolesRemoveData, UserRolesRemoveResponses, UsersBatchCreateData, UsersBatchCreateResponses, UsersBatchSoftDeleteData, UsersBatchSoftDeleteResponses, UsersBatchUpdateData, UsersBatchUpdateResponses, UsersCreateData, UsersCreateResponses, UsersDeleteData, UsersDeletePermanentData, UsersDeletePermanentResponses, UsersDeleteResponses, UsersGetData, UsersGetResponses, UsersListData, UsersListResponses, UsersResetPasswordData, UsersResetPasswordResponses, UsersRestoreData, UsersRestoreResponses, UsersUpdateData, UsersUpdateResponses, WebhooksCreateData, WebhooksCreateResponses, WebhooksDeleteData, WebhooksDeleteResponses, WebhooksGetData, WebhooksGetDeliveryData, WebhooksGetDeliveryResponses, WebhooksGetResponses, WebhooksListData, WebhooksListDeliveriesData, WebhooksListDeliveriesResponses, WebhooksListEventTypesData, WebhooksListEventTypesResponses, WebhooksListResponses, WebhooksRetryDeliveryData, WebhooksRetryDeliveryResponses, WebhooksRotateSecretData, WebhooksRotateSecretResponses, WebhooksTestData, WebhooksTestResponses, WebhooksUpdateData, WebhooksUpdateResponses } from './types.gen';
import { zApiKeysCreateData, zApiKeysCreateResponse, zApiKeysGetData, zApiKeysGetResponse, zApiKeysListData, zApiKeysListResponse, zApiKeysRevokeData, zApiKeysRevokeResponse, zApiKeysRotateData, zApiKeysRotateResponse, zApiKeysUpdateData, zApiKeysUpdateResponse, zAuditLogsExportData, zAuditLogsExportResponse, zAuditLogsGetData, zAuditLogsGetResponse, zAuditLogsListData, zAuditLogsListResponse, zCrossTenantRolesListData, zCrossTenantRolesListResponse, zExampleCommentsBatchCreateData, zExampleCommentsBatchCreateResponse, zExampleCommentsBatchSoftDeleteData, zExampleCommentsBatchSoftDeleteResponse, zExampleCommentsCreateData, zExampleCommentsCreateResponse, zExampleCommentsDeleteData, zExampleCommentsDeletePermanentData, zExampleCommentsDeletePermanentResponse, zExampleCommentsDeleteResponse, zExampleCommentsGetData, zExampleCommentsGetResponse, zExampleCommentsListData, zExampleCommentsListResponse, zExampleCommentsRestoreData, zExampleCommentsRestoreResponse, zExampleCommentsUpdateData, zExampleCommentsUpdateResponse, zExamplePostsBatchCreateData, zExamplePostsBatchCreateResponse, zExamplePostsBatchSoftDeleteData, zExamplePostsBatchSoftDeleteResponse, zExamplePostsBatchUpdateData, zExamplePostsBatchUpdateResponse, zExamplePostsCreateData, zExamplePostsCreateResponse, zExamplePostsDeleteData, zExamplePostsDeletePermanentData, zExamplePostsDeletePermanentResponse, zExamplePostsDeleteResponse, zExamplePostsGetData, zExamplePostsGetResponse, zExamplePostsListData, zExamplePostsListResponse, zExamplePostsRestoreData, zExamplePostsRestoreResponse, zExamplePostsUpdateData, zExamplePostsUpdateResponse, zFilesConfirmUploadData, zFilesConfirmUploadResponse, zFilesDeleteData, zFilesDeletePermanentData, zFilesDeletePermanentResponse, zFilesDeleteResponse, zFilesDirectUploadData, zFilesDirectUploadResponse, zFilesDownloadData, zFilesDownloadResponse, zFilesGetData, zFilesGetResponse, zFilesInitiateUploadData, zFilesInitiateUploadResponse, zFilesListData, zFilesListResponse, zHealthCheckData, zHealthCheckResponse, zJobsCancelData, zJobsCancelResponse, zJobsGetData, zJobsGetResponse, zJobsListData, zJobsListResponse, zRolesCreateData, zRolesCreateResponse, zRolesDeleteData, zRolesDeleteResponse, zRolesGetData, zRolesGetResponse, zRolesListData, zRolesListResponse, zRolesUpdateData, zRolesUpdateResponse, zTenantSwitchSwitchData, zTenantSwitchSwitchResponse, zUserPermissionsEndpointGetData, zUserPermissionsEndpointGetResponse, zUserRolesAssignData, zUserRolesAssignResponse, zUserRolesListData, zUserRolesListResponse, zUserRolesRemoveData, zUserRolesRemoveResponse, zUsersBatchCreateData, zUsersBatchCreateResponse, zUsersBatchSoftDeleteData, zUsersBatchSoftDeleteResponse, zUsersBatchUpdateData, zUsersBatchUpdateResponse, zUsersCreateData, zUsersCreateResponse, zUsersDeleteData, zUsersDeletePermanentData, zUsersDeletePermanentResponse, zUsersDeleteResponse, zUsersGetData, zUsersGetResponse, zUsersListData, zUsersListResponse, zUsersResetPasswordData, zUsersResetPasswordResponse, zUsersRestoreData, zUsersRestoreResponse, zUsersUpdateData, zUsersUpdateResponse, zWebhooksCreateData, zWebhooksCreateResponse, zWebhooksDeleteData, zWebhooksDeleteResponse, zWebhooksGetData, zWebhooksGetDeliveryData, zWebhooksGetDeliveryResponse, zWebhooksGetResponse, zWebhooksListData, zWebhooksListDeliveriesData, zWebhooksListDeliveriesResponse, zWebhooksListEventTypesData, zWebhooksListEventTypesResponse, zWebhooksListResponse, zWebhooksRetryDeliveryData, zWebhooksRetryDeliveryResponse, zWebhooksRotateSecretData, zWebhooksRotateSecretResponse, zWebhooksTestData, zWebhooksTestResponse, zWebhooksUpdateData, zWebhooksUpdateResponse } from './zod.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Health check
 *
 * Check API health status
 * Returns 200 OK if the API is healthy
 */
export const healthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthCheckData, ThrowOnError>) => (options?.client ?? client).get<HealthCheckResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zHealthCheckData.parseAsync(data),
    responseValidator: async (data) => await zHealthCheckResponse.parseAsync(data),
    url: '/health',
    ...options
});

/**
 * List API keys
 *
 * List all API keys in an organization
 *
 * Does not return the actual key secrets.
 */
export const apiKeysList = <ThrowOnError extends boolean = false>(options: Options<ApiKeysListData, ThrowOnError>) => (options.client ?? client).get<ApiKeysListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zApiKeysListData.parseAsync(data),
    responseValidator: async (data) => await zApiKeysListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/api-keys',
    ...options
});

/**
 * Create API key
 *
 * Create a new API key
 *
 * The key secret is only returned once in the response.
 * Store it securely - it cannot be retrieved again.
 */
export const apiKeysCreate = <ThrowOnError extends boolean = false>(options: Options<ApiKeysCreateData, ThrowOnError>) => (options.client ?? client).post<ApiKeysCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zApiKeysCreateData.parseAsync(data),
    responseValidator: async (data) => await zApiKeysCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/api-keys',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Revoke API key
 *
 * Revoke (delete) an API key
 *
 * The key will immediately stop working.
 * This action cannot be undone.
 */
export const apiKeysRevoke = <ThrowOnError extends boolean = false>(options: Options<ApiKeysRevokeData, ThrowOnError>) => (options.client ?? client).delete<ApiKeysRevokeResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zApiKeysRevokeData.parseAsync(data),
    responseValidator: async (data) => await zApiKeysRevokeResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/api-keys/{keyId}',
    ...options
});

/**
 * Get API key
 *
 * Get an API key by ID
 *
 * Does not return the actual key secret.
 */
export const apiKeysGet = <ThrowOnError extends boolean = false>(options: Options<ApiKeysGetData, ThrowOnError>) => (options.client ?? client).get<ApiKeysGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zApiKeysGetData.parseAsync(data),
    responseValidator: async (data) => await zApiKeysGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/api-keys/{keyId}',
    ...options
});

/**
 * Update API key
 *
 * Update an API key
 *
 * Can update name, description, permissions, and active status.
 * Cannot change the key secret - create a new key instead.
 */
export const apiKeysUpdate = <ThrowOnError extends boolean = false>(options: Options<ApiKeysUpdateData, ThrowOnError>) => (options.client ?? client).patch<ApiKeysUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zApiKeysUpdateData.parseAsync(data),
    responseValidator: async (data) => await zApiKeysUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/api-keys/{keyId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Rotate API key
 *
 * Rotate an API key
 *
 * Creates a new key secret while keeping the same key ID.
 * The old secret immediately stops working.
 */
export const apiKeysRotate = <ThrowOnError extends boolean = false>(options: Options<ApiKeysRotateData, ThrowOnError>) => (options.client ?? client).post<ApiKeysRotateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zApiKeysRotateData.parseAsync(data),
    responseValidator: async (data) => await zApiKeysRotateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/api-keys/{keyId}/rotate',
    ...options
});

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsList = <ThrowOnError extends boolean = false>(options: Options<AuditLogsListData, ThrowOnError>) => (options.client ?? client).get<AuditLogsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsListData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs',
    ...options
});

/**
 * Export audit logs
 *
 * Export audit logs
 *
 * Returns a download URL for audit logs in CSV or JSON format.
 * For large exports, returns 202 Accepted with a job ID.
 */
export const auditLogsExport = <ThrowOnError extends boolean = false>(options: Options<AuditLogsExportData, ThrowOnError>) => (options.client ?? client).post<AuditLogsExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsExportData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs/export',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get audit log entry
 *
 * Get a single audit log entry
 */
export const auditLogsGet = <ThrowOnError extends boolean = false>(options: Options<AuditLogsGetData, ThrowOnError>) => (options.client ?? client).get<AuditLogsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsGetData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs/{eventId}',
    ...options
});

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsList = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts',
    ...options
});

/**
 * Create example post
 *
 * Create a new post
 */
export const examplePostsCreate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsCreateData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsCreateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch update example posts
 *
 * Batch update posts
 */
export const examplePostsBatchUpdate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExamplePostsBatchUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create example posts
 *
 * Batch create posts
 */
export const examplePostsBatchCreate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchCreateData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete example posts
 *
 * Batch soft delete posts
 */
export const examplePostsBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Soft delete example post
 *
 * Soft delete a post (default delete behavior)
 * Post is marked as deleted but can be restored
 */
export const examplePostsDelete = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ExamplePostsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options
});

/**
 * Get example post
 *
 * Get a single post by ID
 */
export const examplePostsGet = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsGetData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsGetData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options
});

/**
 * Update example post
 *
 * Update a post (partial update)
 */
export const examplePostsUpdate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExamplePostsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete example post
 *
 * Permanently delete a post (hard delete)
 * Post is permanently removed and cannot be restored
 */
export const examplePostsDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<ExamplePostsDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}/permanent',
    ...options
});

/**
 * Restore example post
 *
 * Restore a soft-deleted post
 */
export const examplePostsRestore = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsRestoreData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}/restore',
    ...options
});

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsList = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsListData, ThrowOnError>) => (options.client ?? client).get<ExampleCommentsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsListData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments',
    ...options
});

/**
 * Create comment on post
 *
 * Create a new comment on a post
 */
export const exampleCommentsCreate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsCreateData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsCreateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create comments
 *
 * Batch create comments
 */
export const exampleCommentsBatchCreate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsBatchCreateData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete comments
 *
 * Batch soft delete comments
 */
export const exampleCommentsBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Soft delete comment
 *
 * Soft delete a comment
 */
export const exampleCommentsDelete = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ExampleCommentsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options
});

/**
 * Get comment
 *
 * Get a single comment by ID
 */
export const exampleCommentsGet = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsGetData, ThrowOnError>) => (options.client ?? client).get<ExampleCommentsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsGetData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options
});

/**
 * Update comment
 *
 * Update a comment (partial update)
 */
export const exampleCommentsUpdate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExampleCommentsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete comment
 *
 * Permanently delete a comment (hard delete)
 */
export const exampleCommentsDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<ExampleCommentsDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/permanent',
    ...options
});

/**
 * Restore comment
 *
 * Restore a soft-deleted comment
 */
export const exampleCommentsRestore = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsRestoreData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/restore',
    ...options
});

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesList = <ThrowOnError extends boolean = false>(options: Options<FilesListData, ThrowOnError>) => (options.client ?? client).get<FilesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesListData.parseAsync(data),
    responseValidator: async (data) => await zFilesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files',
    ...options
});

/**
 * Direct file upload
 *
 * Direct file upload (multipart/form-data)
 *
 * For simple uploads of small files (< 10 MB).
 * File is uploaded directly to the API server.
 *
 * Note: For larger files or high volume, use presigned URL upload.
 */
export const filesDirectUpload = <ThrowOnError extends boolean = false>(options: Options<FilesDirectUploadData, ThrowOnError>) => (options.client ?? client).post<FilesDirectUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDirectUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesDirectUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files',
    ...options
});

/**
 * Initiate presigned URL upload
 *
 * Initiate a presigned URL upload
 *
 * Returns a presigned URL for direct upload to storage (S3/R2/GCS).
 * Client uploads directly to storage, then confirms with the API.
 *
 * Flow:
 * 1. POST /files/uploads - Get presigned URL
 * 2. PUT {presignedUrl} - Upload directly to storage
 * 3. POST /files/uploads/{uploadId}/confirm - Confirm upload
 */
export const filesInitiateUpload = <ThrowOnError extends boolean = false>(options: Options<FilesInitiateUploadData, ThrowOnError>) => (options.client ?? client).post<FilesInitiateUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesInitiateUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesInitiateUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/uploads',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Confirm presigned URL upload
 *
 * Confirm a presigned URL upload
 *
 * Called after client successfully uploads to the presigned URL.
 * Triggers virus scanning and creates the file record.
 */
export const filesConfirmUpload = <ThrowOnError extends boolean = false>(options: Options<FilesConfirmUploadData, ThrowOnError>) => (options.client ?? client).post<FilesConfirmUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesConfirmUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesConfirmUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/uploads/{uploadId}/confirm',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete file
 *
 * Delete a file (soft delete)
 *
 * File is marked as deleted but retained for audit purposes.
 * Storage is cleaned up after retention period.
 */
export const filesDelete = <ThrowOnError extends boolean = false>(options: Options<FilesDeleteData, ThrowOnError>) => (options.client ?? client).delete<FilesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zFilesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options
});

/**
 * Get file
 *
 * Get a single file by ID
 *
 * Returns file metadata including a fresh signed URL for download.
 */
export const filesGet = <ThrowOnError extends boolean = false>(options: Options<FilesGetData, ThrowOnError>) => (options.client ?? client).get<FilesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesGetData.parseAsync(data),
    responseValidator: async (data) => await zFilesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options
});

/**
 * Download file
 *
 * Download a file
 *
 * Returns a redirect to a signed URL for the file.
 * The signed URL expires in 5 minutes.
 */
export const filesDownload = <ThrowOnError extends boolean = false>(options: Options<FilesDownloadData, ThrowOnError>) => (options.client ?? client).get<FilesDownloadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDownloadData.parseAsync(data),
    responseValidator: async (data) => await zFilesDownloadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}/download',
    ...options
});

/**
 * Permanently delete file
 *
 * Permanently delete a file (hard delete)
 *
 * Immediately removes file from storage.
 * Use with caution - cannot be undone.
 */
export const filesDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<FilesDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<FilesDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zFilesDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}/permanent',
    ...options
});

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsList = <ThrowOnError extends boolean = false>(options: Options<JobsListData, ThrowOnError>) => (options.client ?? client).get<JobsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsListData.parseAsync(data),
    responseValidator: async (data) => await zJobsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs',
    ...options
});

/**
 * Get job status
 *
 * Get job status
 *
 * Poll this endpoint to check progress of async operations.
 */
export const jobsGet = <ThrowOnError extends boolean = false>(options: Options<JobsGetData, ThrowOnError>) => (options.client ?? client).get<JobsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsGetData.parseAsync(data),
    responseValidator: async (data) => await zJobsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}',
    ...options
});

/**
 * Cancel job
 *
 * Cancel a job
 *
 * Only pending or processing jobs can be cancelled.
 */
export const jobsCancel = <ThrowOnError extends boolean = false>(options: Options<JobsCancelData, ThrowOnError>) => (options.client ?? client).post<JobsCancelResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsCancelData.parseAsync(data),
    responseValidator: async (data) => await zJobsCancelResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}/cancel',
    ...options
});

/**
 * List roles
 *
 * List all roles in an organization
 *
 * Returns both system roles and custom roles.
 */
export const rolesList = <ThrowOnError extends boolean = false>(options: Options<RolesListData, ThrowOnError>) => (options.client ?? client).get<RolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zRolesListData.parseAsync(data),
    responseValidator: async (data) => await zRolesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles',
    ...options
});

/**
 * Create role
 *
 * Create a custom role
 *
 * System roles cannot be created via API.
 */
export const rolesCreate = <ThrowOnError extends boolean = false>(options: Options<RolesCreateData, ThrowOnError>) => (options.client ?? client).post<RolesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zRolesCreateData.parseAsync(data),
    responseValidator: async (data) => await zRolesCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete role
 *
 * Delete a custom role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const rolesDelete = <ThrowOnError extends boolean = false>(options: Options<RolesDeleteData, ThrowOnError>) => (options.client ?? client).delete<RolesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zRolesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zRolesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options
});

/**
 * Get role
 *
 * Get a role by ID
 */
export const rolesGet = <ThrowOnError extends boolean = false>(options: Options<RolesGetData, ThrowOnError>) => (options.client ?? client).get<RolesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zRolesGetData.parseAsync(data),
    responseValidator: async (data) => await zRolesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options
});

/**
 * Update role
 *
 * Update a custom role
 *
 * System roles cannot be modified.
 */
export const rolesUpdate = <ThrowOnError extends boolean = false>(options: Options<RolesUpdateData, ThrowOnError>) => (options.client ?? client).patch<RolesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zRolesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zRolesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List users
 *
 * List users in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const usersList = <ThrowOnError extends boolean = false>(options: Options<UsersListData, ThrowOnError>) => (options.client ?? client).get<UsersListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersListData.parseAsync(data),
    responseValidator: async (data) => await zUsersListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users',
    ...options
});

/**
 * Create user
 *
 * Create a new user
 */
export const usersCreate = <ThrowOnError extends boolean = false>(options: Options<UsersCreateData, ThrowOnError>) => (options.client ?? client).post<UsersCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersCreateData.parseAsync(data),
    responseValidator: async (data) => await zUsersCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch update users
 *
 * Batch update users
 */
export const usersBatchUpdate = <ThrowOnError extends boolean = false>(options: Options<UsersBatchUpdateData, ThrowOnError>) => (options.client ?? client).patch<UsersBatchUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersBatchUpdateData.parseAsync(data),
    responseValidator: async (data) => await zUsersBatchUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create users
 *
 * Batch create users
 */
export const usersBatchCreate = <ThrowOnError extends boolean = false>(options: Options<UsersBatchCreateData, ThrowOnError>) => (options.client ?? client).post<UsersBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zUsersBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete users
 *
 * Batch soft delete users
 */
export const usersBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<UsersBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<UsersBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zUsersBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Soft delete user
 *
 * Soft delete a user (default delete behavior)
 * User is marked as deleted but can be restored
 */
export const usersDelete = <ThrowOnError extends boolean = false>(options: Options<UsersDeleteData, ThrowOnError>) => (options.client ?? client).delete<UsersDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersDeleteData.parseAsync(data),
    responseValidator: async (data) => await zUsersDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{id}',
    ...options
});

/**
 * Get user
 *
 * Get a single user by ID
 */
export const usersGet = <ThrowOnError extends boolean = false>(options: Options<UsersGetData, ThrowOnError>) => (options.client ?? client).get<UsersGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersGetData.parseAsync(data),
    responseValidator: async (data) => await zUsersGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{id}',
    ...options
});

/**
 * Update user
 *
 * Update a user (partial update)
 */
export const usersUpdate = <ThrowOnError extends boolean = false>(options: Options<UsersUpdateData, ThrowOnError>) => (options.client ?? client).patch<UsersUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersUpdateData.parseAsync(data),
    responseValidator: async (data) => await zUsersUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Reset user password
 *
 * Custom action: Reset user password
 */
export const usersResetPassword = <ThrowOnError extends boolean = false>(options: Options<UsersResetPasswordData, ThrowOnError>) => (options.client ?? client).post<UsersResetPasswordResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersResetPasswordData.parseAsync(data),
    responseValidator: async (data) => await zUsersResetPasswordResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{id}/actions/reset-password',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete user
 *
 * Permanently delete a user (hard delete)
 * User is permanently removed and cannot be restored
 */
export const usersDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<UsersDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<UsersDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zUsersDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{id}/permanent',
    ...options
});

/**
 * Restore user
 *
 * Restore a soft-deleted user
 */
export const usersRestore = <ThrowOnError extends boolean = false>(options: Options<UsersRestoreData, ThrowOnError>) => (options.client ?? client).post<UsersRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUsersRestoreData.parseAsync(data),
    responseValidator: async (data) => await zUsersRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{id}/restore',
    ...options
});

/**
 * Get user permissions
 *
 * Get user's effective permissions in this tenant
 *
 * Returns all roles and the combined effective permissions.
 */
export const userPermissionsEndpointGet = <ThrowOnError extends boolean = false>(options: Options<UserPermissionsEndpointGetData, ThrowOnError>) => (options.client ?? client).get<UserPermissionsEndpointGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserPermissionsEndpointGetData.parseAsync(data),
    responseValidator: async (data) => await zUserPermissionsEndpointGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/permissions',
    ...options
});

/**
 * List user roles
 *
 * List roles assigned to a user in this tenant
 */
export const userRolesList = <ThrowOnError extends boolean = false>(options: Options<UserRolesListData, ThrowOnError>) => (options.client ?? client).get<UserRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserRolesListData.parseAsync(data),
    responseValidator: async (data) => await zUserRolesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles',
    ...options
});

/**
 * Assign role to user
 *
 * Assign a role to a user
 */
export const userRolesAssign = <ThrowOnError extends boolean = false>(options: Options<UserRolesAssignData, ThrowOnError>) => (options.client ?? client).post<UserRolesAssignResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserRolesAssignData.parseAsync(data),
    responseValidator: async (data) => await zUserRolesAssignResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Remove role from user
 *
 * Remove a role from a user
 */
export const userRolesRemove = <ThrowOnError extends boolean = false>(options: Options<UserRolesRemoveData, ThrowOnError>) => (options.client ?? client).delete<UserRolesRemoveResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserRolesRemoveData.parseAsync(data),
    responseValidator: async (data) => await zUserRolesRemoveResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles/{roleId}',
    ...options
});

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksList = <ThrowOnError extends boolean = false>(options: Options<WebhooksListData, ThrowOnError>) => (options.client ?? client).get<WebhooksListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks',
    ...options
});

/**
 * Create webhook
 *
 * Create a new webhook
 *
 * The secret is only returned once in the response.
 * Store it securely for signature verification.
 */
export const webhooksCreate = <ThrowOnError extends boolean = false>(options: Options<WebhooksCreateData, ThrowOnError>) => (options.client ?? client).post<WebhooksCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksCreateData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List event types
 *
 * Get available event types
 *
 * Returns all event types that can be subscribed to.
 */
export const webhooksListEventTypes = <ThrowOnError extends boolean = false>(options: Options<WebhooksListEventTypesData, ThrowOnError>) => (options.client ?? client).get<WebhooksListEventTypesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListEventTypesData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListEventTypesResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/event-types',
    ...options
});

/**
 * Delete webhook
 *
 * Delete a webhook
 */
export const webhooksDelete = <ThrowOnError extends boolean = false>(options: Options<WebhooksDeleteData, ThrowOnError>) => (options.client ?? client).delete<WebhooksDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksDeleteData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options
});

/**
 * Get webhook
 *
 * Get a webhook by ID
 */
export const webhooksGet = <ThrowOnError extends boolean = false>(options: Options<WebhooksGetData, ThrowOnError>) => (options.client ?? client).get<WebhooksGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksGetData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options
});

/**
 * Update webhook
 *
 * Update a webhook
 */
export const webhooksUpdate = <ThrowOnError extends boolean = false>(options: Options<WebhooksUpdateData, ThrowOnError>) => (options.client ?? client).patch<WebhooksUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksUpdateData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveries = <ThrowOnError extends boolean = false>(options: Options<WebhooksListDeliveriesData, ThrowOnError>) => (options.client ?? client).get<WebhooksListDeliveriesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListDeliveriesData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListDeliveriesResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries',
    ...options
});

/**
 * Get webhook delivery
 *
 * Get a specific delivery
 */
export const webhooksGetDelivery = <ThrowOnError extends boolean = false>(options: Options<WebhooksGetDeliveryData, ThrowOnError>) => (options.client ?? client).get<WebhooksGetDeliveryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksGetDeliveryData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksGetDeliveryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}',
    ...options
});

/**
 * Retry delivery
 *
 * Retry a failed delivery
 *
 * Manually triggers a retry for a failed delivery.
 */
export const webhooksRetryDelivery = <ThrowOnError extends boolean = false>(options: Options<WebhooksRetryDeliveryData, ThrowOnError>) => (options.client ?? client).post<WebhooksRetryDeliveryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksRetryDeliveryData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksRetryDeliveryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}/retry',
    ...options
});

/**
 * Rotate webhook secret
 *
 * Rotate webhook secret
 *
 * Generates a new secret. The old secret immediately stops working.
 */
export const webhooksRotateSecret = <ThrowOnError extends boolean = false>(options: Options<WebhooksRotateSecretData, ThrowOnError>) => (options.client ?? client).post<WebhooksRotateSecretResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksRotateSecretData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksRotateSecretResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/rotate-secret',
    ...options
});

/**
 * Test webhook
 *
 * Test a webhook
 *
 * Sends a test event to verify the webhook is configured correctly.
 */
export const webhooksTest = <ThrowOnError extends boolean = false>(options: Options<WebhooksTestData, ThrowOnError>) => (options.client ?? client).post<WebhooksTestResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksTestData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksTestResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/test',
    ...options
});

/**
 * Switch tenant
 *
 * Switch user's active tenant
 *
 * Returns a new access token scoped to the target tenant.
 */
export const tenantSwitchSwitch = <ThrowOnError extends boolean = false>(options: Options<TenantSwitchSwitchData, ThrowOnError>) => (options.client ?? client).post<TenantSwitchSwitchResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantSwitchSwitchData.parseAsync(data),
    responseValidator: async (data) => await zTenantSwitchSwitchResponse.parseAsync(data),
    url: '/v1/users/{userId}/switch-tenant',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List user tenant roles
 *
 * List user's roles across all tenants
 *
 * Returns all tenants the user belongs to with their roles.
 */
export const crossTenantRolesList = <ThrowOnError extends boolean = false>(options: Options<CrossTenantRolesListData, ThrowOnError>) => (options.client ?? client).get<CrossTenantRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCrossTenantRolesListData.parseAsync(data),
    responseValidator: async (data) => await zCrossTenantRolesListResponse.parseAsync(data),
    url: '/v1/users/{userId}/tenant-roles',
    ...options
});
