// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { AllUserRolesListData, AllUserRolesListResponses, AuditLogsExportData, AuditLogsExportResponses, AuditLogsGetData, AuditLogsGetResponses, AuditLogsListData, AuditLogsListResponses, AvailableContextsListData, AvailableContextsListResponses, ContextSwitchSwitchData, ContextSwitchSwitchResponses, CurrentUserContextGetData, CurrentUserContextGetResponses, ExampleCommentsBatchCreateData, ExampleCommentsBatchCreateResponses, ExampleCommentsBatchSoftDeleteData, ExampleCommentsBatchSoftDeleteResponses, ExampleCommentsCreateData, ExampleCommentsCreateResponses, ExampleCommentsDeleteData, ExampleCommentsDeletePermanentData, ExampleCommentsDeletePermanentResponses, ExampleCommentsDeleteResponses, ExampleCommentsGetData, ExampleCommentsGetResponses, ExampleCommentsListData, ExampleCommentsListResponses, ExampleCommentsRestoreData, ExampleCommentsRestoreResponses, ExampleCommentsUpdateData, ExampleCommentsUpdateResponses, ExamplePostsBatchCreateData, ExamplePostsBatchCreateResponses, ExamplePostsBatchRestoreData, ExamplePostsBatchRestoreResponses, ExamplePostsBatchSoftDeleteData, ExamplePostsBatchSoftDeleteResponses, ExamplePostsBatchUpdateData, ExamplePostsBatchUpdateResponses, ExamplePostsCreateData, ExamplePostsCreateResponses, ExamplePostsDeleteData, ExamplePostsDeletePermanentData, ExamplePostsDeletePermanentResponses, ExamplePostsDeleteResponses, ExamplePostsGetData, ExamplePostsGetResponses, ExamplePostsListCursorData, ExamplePostsListCursorResponses, ExamplePostsListData, ExamplePostsListDeletedData, ExamplePostsListDeletedResponses, ExamplePostsListResponses, ExamplePostsRestoreData, ExamplePostsRestoreResponses, ExamplePostsUpdateData, ExamplePostsUpdateResponses, FilesConfirmUploadData, FilesConfirmUploadResponses, FilesDeleteData, FilesDeletePermanentData, FilesDeletePermanentResponses, FilesDeleteResponses, FilesDirectUploadData, FilesDirectUploadResponses, FilesDownloadData, FilesDownloadResponses, FilesGetData, FilesGetResponses, FilesInitiateUploadData, FilesInitiateUploadResponses, FilesListData, FilesListResponses, FilesUpdateData, FilesUpdateResponses, GlobalRolesCreateData, GlobalRolesCreateResponses, GlobalRolesDeleteData, GlobalRolesDeleteResponses, GlobalRolesGetData, GlobalRolesGetResponses, GlobalRolesListData, GlobalRolesListResponses, GlobalRolesUpdateData, GlobalRolesUpdateResponses, HealthCheckData, HealthCheckResponses, JobsCancelData, JobsCancelResponses, JobsGetData, JobsGetResponses, JobsListData, JobsListResponses, MigrationGetStatusData, MigrationGetStatusResponses, TenantRolesCreateData, TenantRolesCreateResponses, TenantRolesDeleteData, TenantRolesDeleteResponses, TenantRolesGetData, TenantRolesGetResponses, TenantRolesListData, TenantRolesListResponses, TenantRolesUpdateData, TenantRolesUpdateResponses, UserPermissionsGetData, UserPermissionsGetResponses, UserTenantRolesAssignData, UserTenantRolesAssignResponses, UserTenantRolesListData, UserTenantRolesListResponses, UserTenantRolesRemoveData, UserTenantRolesRemoveResponses, WebhooksCreateData, WebhooksCreateResponses, WebhooksDeleteData, WebhooksDeleteResponses, WebhooksGetData, WebhooksGetDeliveryData, WebhooksGetDeliveryResponses, WebhooksGetResponses, WebhooksListData, WebhooksListDeliveriesData, WebhooksListDeliveriesResponses, WebhooksListEventTypesData, WebhooksListEventTypesResponses, WebhooksListResponses, WebhooksRetryDeliveryData, WebhooksRetryDeliveryResponses, WebhooksRotateSecretData, WebhooksRotateSecretResponses, WebhooksTestData, WebhooksTestResponses, WebhooksUpdateData, WebhooksUpdateResponses } from './types.gen';
import { zAllUserRolesListData, zAllUserRolesListResponse, zAuditLogsExportData, zAuditLogsExportResponse, zAuditLogsGetData, zAuditLogsGetResponse, zAuditLogsListData, zAuditLogsListResponse, zAvailableContextsListData, zAvailableContextsListResponse, zContextSwitchSwitchData, zContextSwitchSwitchResponse, zCurrentUserContextGetData, zCurrentUserContextGetResponse, zExampleCommentsBatchCreateData, zExampleCommentsBatchCreateResponse, zExampleCommentsBatchSoftDeleteData, zExampleCommentsBatchSoftDeleteResponse, zExampleCommentsCreateData, zExampleCommentsCreateResponse, zExampleCommentsDeleteData, zExampleCommentsDeletePermanentData, zExampleCommentsDeletePermanentResponse, zExampleCommentsDeleteResponse, zExampleCommentsGetData, zExampleCommentsGetResponse, zExampleCommentsListData, zExampleCommentsListResponse, zExampleCommentsRestoreData, zExampleCommentsRestoreResponse, zExampleCommentsUpdateData, zExampleCommentsUpdateResponse, zExamplePostsBatchCreateData, zExamplePostsBatchCreateResponse, zExamplePostsBatchRestoreData, zExamplePostsBatchRestoreResponse, zExamplePostsBatchSoftDeleteData, zExamplePostsBatchSoftDeleteResponse, zExamplePostsBatchUpdateData, zExamplePostsBatchUpdateResponse, zExamplePostsCreateData, zExamplePostsCreateResponse, zExamplePostsDeleteData, zExamplePostsDeletePermanentData, zExamplePostsDeletePermanentResponse, zExamplePostsDeleteResponse, zExamplePostsGetData, zExamplePostsGetResponse, zExamplePostsListCursorData, zExamplePostsListCursorResponse, zExamplePostsListData, zExamplePostsListDeletedData, zExamplePostsListDeletedResponse, zExamplePostsListResponse, zExamplePostsRestoreData, zExamplePostsRestoreResponse, zExamplePostsUpdateData, zExamplePostsUpdateResponse, zFilesConfirmUploadData, zFilesConfirmUploadResponse, zFilesDeleteData, zFilesDeletePermanentData, zFilesDeletePermanentResponse, zFilesDeleteResponse, zFilesDirectUploadData, zFilesDirectUploadResponse, zFilesDownloadData, zFilesDownloadResponse, zFilesGetData, zFilesGetResponse, zFilesInitiateUploadData, zFilesInitiateUploadResponse, zFilesListData, zFilesListResponse, zFilesUpdateData, zFilesUpdateResponse, zGlobalRolesCreateData, zGlobalRolesCreateResponse, zGlobalRolesDeleteData, zGlobalRolesDeleteResponse, zGlobalRolesGetData, zGlobalRolesGetResponse, zGlobalRolesListData, zGlobalRolesListResponse, zGlobalRolesUpdateData, zGlobalRolesUpdateResponse, zHealthCheckData, zHealthCheckResponse, zJobsCancelData, zJobsCancelResponse, zJobsGetData, zJobsGetResponse, zJobsListData, zJobsListResponse, zMigrationGetStatusData, zMigrationGetStatusResponse, zTenantRolesCreateData, zTenantRolesCreateResponse, zTenantRolesDeleteData, zTenantRolesDeleteResponse, zTenantRolesGetData, zTenantRolesGetResponse, zTenantRolesListData, zTenantRolesListResponse, zTenantRolesUpdateData, zTenantRolesUpdateResponse, zUserPermissionsGetData, zUserPermissionsGetResponse, zUserTenantRolesAssignData, zUserTenantRolesAssignResponse, zUserTenantRolesListData, zUserTenantRolesListResponse, zUserTenantRolesRemoveData, zUserTenantRolesRemoveResponse, zWebhooksCreateData, zWebhooksCreateResponse, zWebhooksDeleteData, zWebhooksDeleteResponse, zWebhooksGetData, zWebhooksGetDeliveryData, zWebhooksGetDeliveryResponse, zWebhooksGetResponse, zWebhooksListData, zWebhooksListDeliveriesData, zWebhooksListDeliveriesResponse, zWebhooksListEventTypesData, zWebhooksListEventTypesResponse, zWebhooksListResponse, zWebhooksRetryDeliveryData, zWebhooksRetryDeliveryResponse, zWebhooksRotateSecretData, zWebhooksRotateSecretResponse, zWebhooksTestData, zWebhooksTestResponse, zWebhooksUpdateData, zWebhooksUpdateResponse } from './zod.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Health check
 *
 * Check API health status
 * Returns 200 OK if the API is healthy
 */
export const healthCheck = <ThrowOnError extends boolean = false>(options?: Options<HealthCheckData, ThrowOnError>) => (options?.client ?? client).get<HealthCheckResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zHealthCheckData.parseAsync(data),
    responseValidator: async (data) => await zHealthCheckResponse.parseAsync(data),
    url: '/health',
    ...options
});

/**
 * Get API version migration status
 *
 * Get migration status for the current API version
 *
 * Returns information about:
 * - Current version status (current, deprecated, sunset)
 * - Sunset date if deprecated
 * - Replacement version to migrate to
 * - Breaking changes and migration checklist
 */
export const migrationGetStatus = <ThrowOnError extends boolean = false>(options?: Options<MigrationGetStatusData, ThrowOnError>) => (options?.client ?? client).get<MigrationGetStatusResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zMigrationGetStatusData.parseAsync(data),
    responseValidator: async (data) => await zMigrationGetStatusResponse.parseAsync(data),
    url: '/v1/migration/status',
    ...options
});

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsList = <ThrowOnError extends boolean = false>(options: Options<AuditLogsListData, ThrowOnError>) => (options.client ?? client).get<AuditLogsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsListData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs',
    ...options
});

/**
 * Export audit logs
 *
 * Export audit logs
 *
 * Returns a download URL for audit logs in CSV or JSON format.
 * For large exports, returns 202 Accepted with a job ID.
 */
export const auditLogsExport = <ThrowOnError extends boolean = false>(options: Options<AuditLogsExportData, ThrowOnError>) => (options.client ?? client).post<AuditLogsExportResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsExportData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsExportResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs/export',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get audit log entry
 *
 * Get a single audit log entry
 */
export const auditLogsGet = <ThrowOnError extends boolean = false>(options: Options<AuditLogsGetData, ThrowOnError>) => (options.client ?? client).get<AuditLogsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAuditLogsGetData.parseAsync(data),
    responseValidator: async (data) => await zAuditLogsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/audit-logs/{eventId}',
    ...options
});

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsList = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts',
    ...options
});

/**
 * Create example post
 *
 * Create a new post
 */
export const examplePostsCreate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsCreateData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsCreateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch update example posts
 *
 * Batch update posts
 */
export const examplePostsBatchUpdate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExamplePostsBatchUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create example posts
 *
 * Batch create posts
 */
export const examplePostsBatchCreate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchCreateData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch restore example posts
 *
 * Batch restore soft-deleted posts
 */
export const examplePostsBatchRestore = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchRestoreData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch/restore',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete example posts
 *
 * Batch soft delete posts
 */
export const examplePostsBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursor = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListCursorData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListCursorResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListCursorData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListCursorResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/cursor',
    ...options
});

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeleted = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsListDeletedData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsListDeletedResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsListDeletedData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsListDeletedResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/deleted',
    ...options
});

/**
 * Soft delete example post
 *
 * Soft delete a post (default delete behavior)
 * Post is marked as deleted but can be restored
 */
export const examplePostsDelete = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ExamplePostsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options
});

/**
 * Get example post
 *
 * Get a single post by ID
 */
export const examplePostsGet = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsGetData, ThrowOnError>) => (options.client ?? client).get<ExamplePostsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsGetData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options
});

/**
 * Update example post
 *
 * Update a post (partial update)
 */
export const examplePostsUpdate = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExamplePostsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete example post
 *
 * Permanently delete a post (hard delete)
 * Post is permanently removed and cannot be restored
 */
export const examplePostsDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<ExamplePostsDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}/permanent',
    ...options
});

/**
 * Restore example post
 *
 * Restore a soft-deleted post
 */
export const examplePostsRestore = <ThrowOnError extends boolean = false>(options: Options<ExamplePostsRestoreData, ThrowOnError>) => (options.client ?? client).post<ExamplePostsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExamplePostsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExamplePostsRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{id}/restore',
    ...options
});

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsList = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsListData, ThrowOnError>) => (options.client ?? client).get<ExampleCommentsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsListData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments',
    ...options
});

/**
 * Create comment on post
 *
 * Create a new comment on a post
 */
export const exampleCommentsCreate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsCreateData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsCreateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch create comments
 *
 * Batch create comments
 */
export const exampleCommentsBatchCreate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsBatchCreateData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsBatchCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsBatchCreateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsBatchCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Batch soft delete comments
 *
 * Batch soft delete comments
 */
export const exampleCommentsBatchSoftDelete = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsBatchSoftDeleteData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsBatchSoftDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsBatchSoftDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsBatchSoftDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch/soft-delete',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Soft delete comment
 *
 * Soft delete a comment
 */
export const exampleCommentsDelete = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsDeleteData, ThrowOnError>) => (options.client ?? client).delete<ExampleCommentsDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsDeleteData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options
});

/**
 * Get comment
 *
 * Get a single comment by ID
 */
export const exampleCommentsGet = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsGetData, ThrowOnError>) => (options.client ?? client).get<ExampleCommentsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsGetData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options
});

/**
 * Update comment
 *
 * Update a comment (partial update)
 */
export const exampleCommentsUpdate = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsUpdateData, ThrowOnError>) => (options.client ?? client).patch<ExampleCommentsUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsUpdateData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Permanently delete comment
 *
 * Permanently delete a comment (hard delete)
 */
export const exampleCommentsDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<ExampleCommentsDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/permanent',
    ...options
});

/**
 * Restore comment
 *
 * Restore a soft-deleted comment
 */
export const exampleCommentsRestore = <ThrowOnError extends boolean = false>(options: Options<ExampleCommentsRestoreData, ThrowOnError>) => (options.client ?? client).post<ExampleCommentsRestoreResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zExampleCommentsRestoreData.parseAsync(data),
    responseValidator: async (data) => await zExampleCommentsRestoreResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/restore',
    ...options
});

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesList = <ThrowOnError extends boolean = false>(options: Options<FilesListData, ThrowOnError>) => (options.client ?? client).get<FilesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesListData.parseAsync(data),
    responseValidator: async (data) => await zFilesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files',
    ...options
});

/**
 * Direct file upload
 *
 * Direct file upload (multipart/form-data)
 *
 * For simple uploads of small files (< 10 MB).
 * File is uploaded directly to the API server.
 *
 * Note: For larger files or high volume, use presigned URL upload.
 */
export const filesDirectUpload = <ThrowOnError extends boolean = false>(options: Options<FilesDirectUploadData, ThrowOnError>) => (options.client ?? client).post<FilesDirectUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDirectUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesDirectUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files',
    ...options
});

/**
 * Initiate presigned URL upload
 *
 * Initiate a presigned URL upload
 *
 * Returns a presigned URL for direct upload to storage (S3/R2/GCS).
 * Client uploads directly to storage, then confirms with the API.
 *
 * Flow:
 * 1. POST /files/uploads - Get presigned URL
 * 2. PUT {presignedUrl} - Upload directly to storage
 * 3. POST /files/uploads/{uploadId}/confirm - Confirm upload
 */
export const filesInitiateUpload = <ThrowOnError extends boolean = false>(options: Options<FilesInitiateUploadData, ThrowOnError>) => (options.client ?? client).post<FilesInitiateUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesInitiateUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesInitiateUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/uploads',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Confirm presigned URL upload
 *
 * Confirm a presigned URL upload
 *
 * Called after client successfully uploads to the presigned URL.
 * Triggers virus scanning and creates the file record.
 */
export const filesConfirmUpload = <ThrowOnError extends boolean = false>(options: Options<FilesConfirmUploadData, ThrowOnError>) => (options.client ?? client).post<FilesConfirmUploadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesConfirmUploadData.parseAsync(data),
    responseValidator: async (data) => await zFilesConfirmUploadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/uploads/{uploadId}/confirm',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete file
 *
 * Delete a file (soft delete)
 *
 * File is marked as deleted but retained for audit purposes.
 * Storage is cleaned up after retention period.
 */
export const filesDelete = <ThrowOnError extends boolean = false>(options: Options<FilesDeleteData, ThrowOnError>) => (options.client ?? client).delete<FilesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zFilesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options
});

/**
 * Get file
 *
 * Get a single file by ID
 *
 * Returns file metadata including a fresh signed URL for download.
 */
export const filesGet = <ThrowOnError extends boolean = false>(options: Options<FilesGetData, ThrowOnError>) => (options.client ?? client).get<FilesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesGetData.parseAsync(data),
    responseValidator: async (data) => await zFilesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options
});

/**
 * Update file
 *
 * Update file properties
 *
 * Currently supports changing the access level (private/public).
 */
export const filesUpdate = <ThrowOnError extends boolean = false>(options: Options<FilesUpdateData, ThrowOnError>) => (options.client ?? client).patch<FilesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zFilesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Download file
 *
 * Download a file
 *
 * Returns a redirect to a signed URL for the file.
 * The signed URL expires in 5 minutes.
 */
export const filesDownload = <ThrowOnError extends boolean = false>(options: Options<FilesDownloadData, ThrowOnError>) => (options.client ?? client).get<FilesDownloadResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDownloadData.parseAsync(data),
    responseValidator: async (data) => await zFilesDownloadResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}/download',
    ...options
});

/**
 * Permanently delete file
 *
 * Permanently delete a file (hard delete)
 *
 * Immediately removes file from storage.
 * Use with caution - cannot be undone.
 */
export const filesDeletePermanent = <ThrowOnError extends boolean = false>(options: Options<FilesDeletePermanentData, ThrowOnError>) => (options.client ?? client).delete<FilesDeletePermanentResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zFilesDeletePermanentData.parseAsync(data),
    responseValidator: async (data) => await zFilesDeletePermanentResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/files/{fileId}/permanent',
    ...options
});

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsList = <ThrowOnError extends boolean = false>(options: Options<JobsListData, ThrowOnError>) => (options.client ?? client).get<JobsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsListData.parseAsync(data),
    responseValidator: async (data) => await zJobsListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs',
    ...options
});

/**
 * Get job status
 *
 * Get job status
 *
 * Poll this endpoint to check progress of async operations.
 */
export const jobsGet = <ThrowOnError extends boolean = false>(options: Options<JobsGetData, ThrowOnError>) => (options.client ?? client).get<JobsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsGetData.parseAsync(data),
    responseValidator: async (data) => await zJobsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}',
    ...options
});

/**
 * Cancel job
 *
 * Cancel a job
 *
 * Only pending or processing jobs can be cancelled.
 */
export const jobsCancel = <ThrowOnError extends boolean = false>(options: Options<JobsCancelData, ThrowOnError>) => (options.client ?? client).post<JobsCancelResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zJobsCancelData.parseAsync(data),
    responseValidator: async (data) => await zJobsCancelResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/jobs/{jobId}/cancel',
    ...options
});

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesList = <ThrowOnError extends boolean = false>(options: Options<TenantRolesListData, ThrowOnError>) => (options.client ?? client).get<TenantRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesListData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles',
    ...options
});

/**
 * Create tenant role
 *
 * Create a tenant-scoped role
 *
 * Creates a custom role for this specific tenant.
 */
export const tenantRolesCreate = <ThrowOnError extends boolean = false>(options: Options<TenantRolesCreateData, ThrowOnError>) => (options.client ?? client).post<TenantRolesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesCreateData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const tenantRolesDelete = <ThrowOnError extends boolean = false>(options: Options<TenantRolesDeleteData, ThrowOnError>) => (options.client ?? client).delete<TenantRolesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options
});

/**
 * Get role
 *
 * Get a role by ID
 */
export const tenantRolesGet = <ThrowOnError extends boolean = false>(options: Options<TenantRolesGetData, ThrowOnError>) => (options.client ?? client).get<TenantRolesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesGetData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const tenantRolesUpdate = <ThrowOnError extends boolean = false>(options: Options<TenantRolesUpdateData, ThrowOnError>) => (options.client ?? client).patch<TenantRolesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zTenantRolesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zTenantRolesUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/roles/{roleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get user effective permissions
 *
 * Get user's effective permissions in this tenant
 *
 * Returns all roles (global + tenant) and the combined effective permissions
 * after applying deny-override resolution.
 */
export const userPermissionsGet = <ThrowOnError extends boolean = false>(options: Options<UserPermissionsGetData, ThrowOnError>) => (options.client ?? client).get<UserPermissionsGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserPermissionsGetData.parseAsync(data),
    responseValidator: async (data) => await zUserPermissionsGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/permissions',
    ...options
});

/**
 * List user roles in tenant
 *
 * List roles assigned to a user in this tenant
 *
 * Returns both global and tenant-specific role assignments.
 */
export const userTenantRolesList = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesListData, ThrowOnError>) => (options.client ?? client).get<UserTenantRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesListData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles',
    ...options
});

/**
 * Assign role to user
 *
 * Assign a role to a user in this tenant
 */
export const userTenantRolesAssign = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesAssignData, ThrowOnError>) => (options.client ?? client).post<UserTenantRolesAssignResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesAssignData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesAssignResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Remove role from user
 *
 * Remove a role from a user
 */
export const userTenantRolesRemove = <ThrowOnError extends boolean = false>(options: Options<UserTenantRolesRemoveData, ThrowOnError>) => (options.client ?? client).delete<UserTenantRolesRemoveResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zUserTenantRolesRemoveData.parseAsync(data),
    responseValidator: async (data) => await zUserTenantRolesRemoveResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/users/{userId}/roles/{roleId}',
    ...options
});

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksList = <ThrowOnError extends boolean = false>(options: Options<WebhooksListData, ThrowOnError>) => (options.client ?? client).get<WebhooksListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks',
    ...options
});

/**
 * Create webhook
 *
 * Create a new webhook
 *
 * The secret is only returned once in the response.
 * Store it securely for signature verification.
 */
export const webhooksCreate = <ThrowOnError extends boolean = false>(options: Options<WebhooksCreateData, ThrowOnError>) => (options.client ?? client).post<WebhooksCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksCreateData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksCreateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List event types
 *
 * Get available event types
 *
 * Returns all event types that can be subscribed to.
 */
export const webhooksListEventTypes = <ThrowOnError extends boolean = false>(options: Options<WebhooksListEventTypesData, ThrowOnError>) => (options.client ?? client).get<WebhooksListEventTypesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListEventTypesData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListEventTypesResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/event-types',
    ...options
});

/**
 * Delete webhook
 *
 * Delete a webhook
 */
export const webhooksDelete = <ThrowOnError extends boolean = false>(options: Options<WebhooksDeleteData, ThrowOnError>) => (options.client ?? client).delete<WebhooksDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksDeleteData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksDeleteResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options
});

/**
 * Get webhook
 *
 * Get a webhook by ID
 */
export const webhooksGet = <ThrowOnError extends boolean = false>(options: Options<WebhooksGetData, ThrowOnError>) => (options.client ?? client).get<WebhooksGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksGetData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksGetResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options
});

/**
 * Update webhook
 *
 * Update a webhook
 */
export const webhooksUpdate = <ThrowOnError extends boolean = false>(options: Options<WebhooksUpdateData, ThrowOnError>) => (options.client ?? client).patch<WebhooksUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksUpdateData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksUpdateResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveries = <ThrowOnError extends boolean = false>(options: Options<WebhooksListDeliveriesData, ThrowOnError>) => (options.client ?? client).get<WebhooksListDeliveriesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksListDeliveriesData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksListDeliveriesResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries',
    ...options
});

/**
 * Get webhook delivery
 *
 * Get a specific delivery
 */
export const webhooksGetDelivery = <ThrowOnError extends boolean = false>(options: Options<WebhooksGetDeliveryData, ThrowOnError>) => (options.client ?? client).get<WebhooksGetDeliveryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksGetDeliveryData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksGetDeliveryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}',
    ...options
});

/**
 * Retry delivery
 *
 * Retry a failed delivery
 *
 * Manually triggers a retry for a failed delivery.
 */
export const webhooksRetryDelivery = <ThrowOnError extends boolean = false>(options: Options<WebhooksRetryDeliveryData, ThrowOnError>) => (options.client ?? client).post<WebhooksRetryDeliveryResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksRetryDeliveryData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksRetryDeliveryResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}/retry',
    ...options
});

/**
 * Rotate webhook secret
 *
 * Rotate webhook secret
 *
 * Generates a new secret. The old secret immediately stops working.
 */
export const webhooksRotateSecret = <ThrowOnError extends boolean = false>(options: Options<WebhooksRotateSecretData, ThrowOnError>) => (options.client ?? client).post<WebhooksRotateSecretResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksRotateSecretData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksRotateSecretResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/rotate-secret',
    ...options
});

/**
 * Test webhook
 *
 * Test a webhook
 *
 * Sends a test event to verify the webhook is configured correctly.
 */
export const webhooksTest = <ThrowOnError extends boolean = false>(options: Options<WebhooksTestData, ThrowOnError>) => (options.client ?? client).post<WebhooksTestResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zWebhooksTestData.parseAsync(data),
    responseValidator: async (data) => await zWebhooksTestResponse.parseAsync(data),
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/test',
    ...options
});

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesList = <ThrowOnError extends boolean = false>(options?: Options<GlobalRolesListData, ThrowOnError>) => (options?.client ?? client).get<GlobalRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesListData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesListResponse.parseAsync(data),
    url: '/v1/roles',
    ...options
});

/**
 * Create global role
 *
 * Create a global role
 *
 * Creates a role that applies across all tenants.
 */
export const globalRolesCreate = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesCreateData, ThrowOnError>) => (options.client ?? client).post<GlobalRolesCreateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesCreateData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesCreateResponse.parseAsync(data),
    url: '/v1/roles',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const globalRolesDelete = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesDeleteData, ThrowOnError>) => (options.client ?? client).delete<GlobalRolesDeleteResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesDeleteData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesDeleteResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options
});

/**
 * Get role
 *
 * Get a role by ID
 */
export const globalRolesGet = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesGetData, ThrowOnError>) => (options.client ?? client).get<GlobalRolesGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesGetData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesGetResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const globalRolesUpdate = <ThrowOnError extends boolean = false>(options: Options<GlobalRolesUpdateData, ThrowOnError>) => (options.client ?? client).patch<GlobalRolesUpdateResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGlobalRolesUpdateData.parseAsync(data),
    responseValidator: async (data) => await zGlobalRolesUpdateResponse.parseAsync(data),
    url: '/v1/roles/{roleId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List available contexts
 *
 * List all available contexts for the current user
 *
 * Returns all applications and tenants the user has access to.
 */
export const availableContextsList = <ThrowOnError extends boolean = false>(options?: Options<AvailableContextsListData, ThrowOnError>) => (options?.client ?? client).get<AvailableContextsListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAvailableContextsListData.parseAsync(data),
    responseValidator: async (data) => await zAvailableContextsListResponse.parseAsync(data),
    url: '/v1/users/me/available-contexts',
    ...options
});

/**
 * Get active context
 *
 * Get current user's active context
 *
 * Returns the currently active application and tenant for the user.
 * This is for UI state management, not authorization decisions.
 */
export const currentUserContextGet = <ThrowOnError extends boolean = false>(options?: Options<CurrentUserContextGetData, ThrowOnError>) => (options?.client ?? client).get<CurrentUserContextGetResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zCurrentUserContextGetData.parseAsync(data),
    responseValidator: async (data) => await zCurrentUserContextGetResponse.parseAsync(data),
    url: '/v1/users/me/context',
    ...options
});

/**
 * Switch context
 *
 * Switch user's active context
 *
 * Changes the active application and/or tenant.
 * This is for UI state management, not authorization decisions.
 */
export const contextSwitchSwitch = <ThrowOnError extends boolean = false>(options: Options<ContextSwitchSwitchData, ThrowOnError>) => (options.client ?? client).post<ContextSwitchSwitchResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zContextSwitchSwitchData.parseAsync(data),
    responseValidator: async (data) => await zContextSwitchSwitchResponse.parseAsync(data),
    url: '/v1/users/me/switch-context',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all user roles
 *
 * List user's roles across all applications and tenants
 *
 * Returns all role assignments for the user across all contexts.
 */
export const allUserRolesList = <ThrowOnError extends boolean = false>(options: Options<AllUserRolesListData, ThrowOnError>) => (options.client ?? client).get<AllUserRolesListResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zAllUserRolesListData.parseAsync(data),
    responseValidator: async (data) => await zAllUserRolesListResponse.parseAsync(data),
    url: '/v1/users/{userId}/roles',
    ...options
});
