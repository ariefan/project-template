// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen.js';
import { apiKeysCreate, apiKeysGet, apiKeysList, apiKeysRevoke, apiKeysRotate, apiKeysUpdate, auditLogsExport, auditLogsGet, auditLogsList, crossTenantRolesList, filesConfirmUpload, filesDelete, filesDeletePermanent, filesDirectUpload, filesDownload, filesGet, filesInitiateUpload, filesList, healthCheck, jobsCancel, jobsGet, jobsList, type Options, rolesCreate, rolesDelete, rolesGet, rolesList, rolesUpdate, tenantSwitchSwitch, userPermissionsEndpointGet, userRolesAssign, userRolesList, userRolesRemove, usersBatchCreate, usersBatchSoftDelete, usersBatchUpdate, usersCreate, usersDelete, usersDeletePermanent, usersGet, usersList, usersResetPassword, usersRestore, usersUpdate, webhooksCreate, webhooksDelete, webhooksGet, webhooksGetDelivery, webhooksList, webhooksListDeliveries, webhooksListEventTypes, webhooksRetryDelivery, webhooksRotateSecret, webhooksTest, webhooksUpdate } from '../sdk.gen.js';
import type { ApiKeysCreateData, ApiKeysCreateResponse, ApiKeysGetData, ApiKeysGetResponse, ApiKeysListData, ApiKeysListResponse, ApiKeysRevokeData, ApiKeysRevokeResponse, ApiKeysRotateData, ApiKeysRotateResponse, ApiKeysUpdateData, ApiKeysUpdateResponse, AuditLogsExportData, AuditLogsExportResponse, AuditLogsGetData, AuditLogsGetResponse, AuditLogsListData, AuditLogsListResponse, CrossTenantRolesListData, CrossTenantRolesListResponse, FilesConfirmUploadData, FilesConfirmUploadResponse, FilesDeleteData, FilesDeletePermanentData, FilesDeletePermanentResponse, FilesDeleteResponse, FilesDirectUploadData, FilesDirectUploadResponse, FilesDownloadData, FilesDownloadResponse, FilesGetData, FilesGetResponse, FilesInitiateUploadData, FilesInitiateUploadResponse, FilesListData, FilesListResponse, HealthCheckData, HealthCheckResponse, JobsCancelData, JobsCancelResponse, JobsGetData, JobsGetResponse, JobsListData, JobsListResponse, RolesCreateData, RolesCreateResponse, RolesDeleteData, RolesDeleteResponse, RolesGetData, RolesGetResponse, RolesListData, RolesListResponse, RolesUpdateData, RolesUpdateResponse, TenantSwitchSwitchData, TenantSwitchSwitchResponse, UserPermissionsEndpointGetData, UserPermissionsEndpointGetResponse, UserRolesAssignData, UserRolesAssignResponse, UserRolesListData, UserRolesListResponse, UserRolesRemoveData, UserRolesRemoveResponse, UsersBatchCreateData, UsersBatchCreateResponse, UsersBatchSoftDeleteData, UsersBatchSoftDeleteResponse, UsersBatchUpdateData, UsersBatchUpdateResponse, UsersCreateData, UsersCreateResponse, UsersDeleteData, UsersDeletePermanentData, UsersDeletePermanentResponse, UsersDeleteResponse, UsersGetData, UsersGetResponse, UsersListData, UsersListResponse, UsersResetPasswordData, UsersResetPasswordResponse, UsersRestoreData, UsersRestoreResponse, UsersUpdateData, UsersUpdateResponse, WebhooksCreateData, WebhooksCreateResponse, WebhooksDeleteData, WebhooksDeleteResponse, WebhooksGetData, WebhooksGetDeliveryData, WebhooksGetDeliveryResponse, WebhooksGetResponse, WebhooksListData, WebhooksListDeliveriesData, WebhooksListDeliveriesResponse, WebhooksListEventTypesData, WebhooksListEventTypesResponse, WebhooksListResponse, WebhooksRetryDeliveryData, WebhooksRetryDeliveryResponse, WebhooksRotateSecretData, WebhooksRotateSecretResponse, WebhooksTestData, WebhooksTestResponse, WebhooksUpdateData, WebhooksUpdateResponse } from '../types.gen.js';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) => createQueryKey('healthCheck', options);

/**
 * Health check
 *
 * Check API health status
 * Returns 200 OK if the API is healthy
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) => queryOptions<HealthCheckResponse, DefaultError, HealthCheckResponse, ReturnType<typeof healthCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await healthCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthCheckQueryKey(options)
});

export const apiKeysListQueryKey = (options: Options<ApiKeysListData>) => createQueryKey('apiKeysList', options);

/**
 * List API keys
 *
 * List all API keys in an organization
 *
 * Does not return the actual key secrets.
 */
export const apiKeysListOptions = (options: Options<ApiKeysListData>) => queryOptions<ApiKeysListResponse, DefaultError, ApiKeysListResponse, ReturnType<typeof apiKeysListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await apiKeysList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: apiKeysListQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const apiKeysListInfiniteQueryKey = (options: Options<ApiKeysListData>): QueryKey<Options<ApiKeysListData>> => createQueryKey('apiKeysList', options, true);

/**
 * List API keys
 *
 * List all API keys in an organization
 *
 * Does not return the actual key secrets.
 */
export const apiKeysListInfiniteOptions = (options: Options<ApiKeysListData>) => infiniteQueryOptions<ApiKeysListResponse, DefaultError, InfiniteData<ApiKeysListResponse>, QueryKey<Options<ApiKeysListData>>, number | Pick<QueryKey<Options<ApiKeysListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ApiKeysListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await apiKeysList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: apiKeysListInfiniteQueryKey(options)
});

/**
 * Create API key
 *
 * Create a new API key
 *
 * The key secret is only returned once in the response.
 * Store it securely - it cannot be retrieved again.
 */
export const apiKeysCreateMutation = (options?: Partial<Options<ApiKeysCreateData>>): UseMutationOptions<ApiKeysCreateResponse, DefaultError, Options<ApiKeysCreateData>> => {
    const mutationOptions: UseMutationOptions<ApiKeysCreateResponse, DefaultError, Options<ApiKeysCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await apiKeysCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Revoke API key
 *
 * Revoke (delete) an API key
 *
 * The key will immediately stop working.
 * This action cannot be undone.
 */
export const apiKeysRevokeMutation = (options?: Partial<Options<ApiKeysRevokeData>>): UseMutationOptions<ApiKeysRevokeResponse, DefaultError, Options<ApiKeysRevokeData>> => {
    const mutationOptions: UseMutationOptions<ApiKeysRevokeResponse, DefaultError, Options<ApiKeysRevokeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await apiKeysRevoke({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const apiKeysGetQueryKey = (options: Options<ApiKeysGetData>) => createQueryKey('apiKeysGet', options);

/**
 * Get API key
 *
 * Get an API key by ID
 *
 * Does not return the actual key secret.
 */
export const apiKeysGetOptions = (options: Options<ApiKeysGetData>) => queryOptions<ApiKeysGetResponse, DefaultError, ApiKeysGetResponse, ReturnType<typeof apiKeysGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await apiKeysGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: apiKeysGetQueryKey(options)
});

/**
 * Update API key
 *
 * Update an API key
 *
 * Can update name, description, permissions, and active status.
 * Cannot change the key secret - create a new key instead.
 */
export const apiKeysUpdateMutation = (options?: Partial<Options<ApiKeysUpdateData>>): UseMutationOptions<ApiKeysUpdateResponse, DefaultError, Options<ApiKeysUpdateData>> => {
    const mutationOptions: UseMutationOptions<ApiKeysUpdateResponse, DefaultError, Options<ApiKeysUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await apiKeysUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rotate API key
 *
 * Rotate an API key
 *
 * Creates a new key secret while keeping the same key ID.
 * The old secret immediately stops working.
 */
export const apiKeysRotateMutation = (options?: Partial<Options<ApiKeysRotateData>>): UseMutationOptions<ApiKeysRotateResponse, DefaultError, Options<ApiKeysRotateData>> => {
    const mutationOptions: UseMutationOptions<ApiKeysRotateResponse, DefaultError, Options<ApiKeysRotateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await apiKeysRotate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const auditLogsListQueryKey = (options: Options<AuditLogsListData>) => createQueryKey('auditLogsList', options);

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsListOptions = (options: Options<AuditLogsListData>) => queryOptions<AuditLogsListResponse, DefaultError, AuditLogsListResponse, ReturnType<typeof auditLogsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await auditLogsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsListQueryKey(options)
});

export const auditLogsListInfiniteQueryKey = (options: Options<AuditLogsListData>): QueryKey<Options<AuditLogsListData>> => createQueryKey('auditLogsList', options, true);

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsListInfiniteOptions = (options: Options<AuditLogsListData>) => infiniteQueryOptions<AuditLogsListResponse, DefaultError, InfiniteData<AuditLogsListResponse>, QueryKey<Options<AuditLogsListData>>, number | Pick<QueryKey<Options<AuditLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<AuditLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await auditLogsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsListInfiniteQueryKey(options)
});

/**
 * Export audit logs
 *
 * Export audit logs
 *
 * Returns a download URL for audit logs in CSV or JSON format.
 * For large exports, returns 202 Accepted with a job ID.
 */
export const auditLogsExportMutation = (options?: Partial<Options<AuditLogsExportData>>): UseMutationOptions<AuditLogsExportResponse, DefaultError, Options<AuditLogsExportData>> => {
    const mutationOptions: UseMutationOptions<AuditLogsExportResponse, DefaultError, Options<AuditLogsExportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await auditLogsExport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const auditLogsGetQueryKey = (options: Options<AuditLogsGetData>) => createQueryKey('auditLogsGet', options);

/**
 * Get audit log entry
 *
 * Get a single audit log entry
 */
export const auditLogsGetOptions = (options: Options<AuditLogsGetData>) => queryOptions<AuditLogsGetResponse, DefaultError, AuditLogsGetResponse, ReturnType<typeof auditLogsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await auditLogsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsGetQueryKey(options)
});

export const filesListQueryKey = (options: Options<FilesListData>) => createQueryKey('filesList', options);

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesListOptions = (options: Options<FilesListData>) => queryOptions<FilesListResponse, DefaultError, FilesListResponse, ReturnType<typeof filesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesListQueryKey(options)
});

export const filesListInfiniteQueryKey = (options: Options<FilesListData>): QueryKey<Options<FilesListData>> => createQueryKey('filesList', options, true);

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesListInfiniteOptions = (options: Options<FilesListData>) => infiniteQueryOptions<FilesListResponse, DefaultError, InfiniteData<FilesListResponse>, QueryKey<Options<FilesListData>>, number | Pick<QueryKey<Options<FilesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<FilesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await filesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesListInfiniteQueryKey(options)
});

/**
 * Direct file upload
 *
 * Direct file upload (multipart/form-data)
 *
 * For simple uploads of small files (< 10 MB).
 * File is uploaded directly to the API server.
 *
 * Note: For larger files or high volume, use presigned URL upload.
 */
export const filesDirectUploadMutation = (options?: Partial<Options<FilesDirectUploadData>>): UseMutationOptions<FilesDirectUploadResponse, DefaultError, Options<FilesDirectUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesDirectUploadResponse, DefaultError, Options<FilesDirectUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDirectUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Initiate presigned URL upload
 *
 * Initiate a presigned URL upload
 *
 * Returns a presigned URL for direct upload to storage (S3/R2/GCS).
 * Client uploads directly to storage, then confirms with the API.
 *
 * Flow:
 * 1. POST /files/uploads - Get presigned URL
 * 2. PUT {presignedUrl} - Upload directly to storage
 * 3. POST /files/uploads/{uploadId}/confirm - Confirm upload
 */
export const filesInitiateUploadMutation = (options?: Partial<Options<FilesInitiateUploadData>>): UseMutationOptions<FilesInitiateUploadResponse, DefaultError, Options<FilesInitiateUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesInitiateUploadResponse, DefaultError, Options<FilesInitiateUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesInitiateUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Confirm presigned URL upload
 *
 * Confirm a presigned URL upload
 *
 * Called after client successfully uploads to the presigned URL.
 * Triggers virus scanning and creates the file record.
 */
export const filesConfirmUploadMutation = (options?: Partial<Options<FilesConfirmUploadData>>): UseMutationOptions<FilesConfirmUploadResponse, DefaultError, Options<FilesConfirmUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesConfirmUploadResponse, DefaultError, Options<FilesConfirmUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesConfirmUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete file
 *
 * Delete a file (soft delete)
 *
 * File is marked as deleted but retained for audit purposes.
 * Storage is cleaned up after retention period.
 */
export const filesDeleteMutation = (options?: Partial<Options<FilesDeleteData>>): UseMutationOptions<FilesDeleteResponse, DefaultError, Options<FilesDeleteData>> => {
    const mutationOptions: UseMutationOptions<FilesDeleteResponse, DefaultError, Options<FilesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesGetQueryKey = (options: Options<FilesGetData>) => createQueryKey('filesGet', options);

/**
 * Get file
 *
 * Get a single file by ID
 *
 * Returns file metadata including a fresh signed URL for download.
 */
export const filesGetOptions = (options: Options<FilesGetData>) => queryOptions<FilesGetResponse, DefaultError, FilesGetResponse, ReturnType<typeof filesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesGetQueryKey(options)
});

export const filesDownloadQueryKey = (options: Options<FilesDownloadData>) => createQueryKey('filesDownload', options);

/**
 * Download file
 *
 * Download a file
 *
 * Returns a redirect to a signed URL for the file.
 * The signed URL expires in 5 minutes.
 */
export const filesDownloadOptions = (options: Options<FilesDownloadData>) => queryOptions<FilesDownloadResponse, DefaultError, FilesDownloadResponse, ReturnType<typeof filesDownloadQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesDownload({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesDownloadQueryKey(options)
});

/**
 * Permanently delete file
 *
 * Permanently delete a file (hard delete)
 *
 * Immediately removes file from storage.
 * Use with caution - cannot be undone.
 */
export const filesDeletePermanentMutation = (options?: Partial<Options<FilesDeletePermanentData>>): UseMutationOptions<FilesDeletePermanentResponse, DefaultError, Options<FilesDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<FilesDeletePermanentResponse, DefaultError, Options<FilesDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const jobsListQueryKey = (options: Options<JobsListData>) => createQueryKey('jobsList', options);

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsListOptions = (options: Options<JobsListData>) => queryOptions<JobsListResponse, DefaultError, JobsListResponse, ReturnType<typeof jobsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await jobsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsListQueryKey(options)
});

export const jobsListInfiniteQueryKey = (options: Options<JobsListData>): QueryKey<Options<JobsListData>> => createQueryKey('jobsList', options, true);

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsListInfiniteOptions = (options: Options<JobsListData>) => infiniteQueryOptions<JobsListResponse, DefaultError, InfiniteData<JobsListResponse>, QueryKey<Options<JobsListData>>, number | Pick<QueryKey<Options<JobsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<JobsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await jobsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsListInfiniteQueryKey(options)
});

export const jobsGetQueryKey = (options: Options<JobsGetData>) => createQueryKey('jobsGet', options);

/**
 * Get job status
 *
 * Get job status
 *
 * Poll this endpoint to check progress of async operations.
 */
export const jobsGetOptions = (options: Options<JobsGetData>) => queryOptions<JobsGetResponse, DefaultError, JobsGetResponse, ReturnType<typeof jobsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await jobsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsGetQueryKey(options)
});

/**
 * Cancel job
 *
 * Cancel a job
 *
 * Only pending or processing jobs can be cancelled.
 */
export const jobsCancelMutation = (options?: Partial<Options<JobsCancelData>>): UseMutationOptions<JobsCancelResponse, DefaultError, Options<JobsCancelData>> => {
    const mutationOptions: UseMutationOptions<JobsCancelResponse, DefaultError, Options<JobsCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await jobsCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const rolesListQueryKey = (options: Options<RolesListData>) => createQueryKey('rolesList', options);

/**
 * List roles
 *
 * List all roles in an organization
 *
 * Returns both system roles and custom roles.
 */
export const rolesListOptions = (options: Options<RolesListData>) => queryOptions<RolesListResponse, DefaultError, RolesListResponse, ReturnType<typeof rolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await rolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: rolesListQueryKey(options)
});

export const rolesListInfiniteQueryKey = (options: Options<RolesListData>): QueryKey<Options<RolesListData>> => createQueryKey('rolesList', options, true);

/**
 * List roles
 *
 * List all roles in an organization
 *
 * Returns both system roles and custom roles.
 */
export const rolesListInfiniteOptions = (options: Options<RolesListData>) => infiniteQueryOptions<RolesListResponse, DefaultError, InfiniteData<RolesListResponse>, QueryKey<Options<RolesListData>>, number | Pick<QueryKey<Options<RolesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<RolesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await rolesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: rolesListInfiniteQueryKey(options)
});

/**
 * Create role
 *
 * Create a custom role
 *
 * System roles cannot be created via API.
 */
export const rolesCreateMutation = (options?: Partial<Options<RolesCreateData>>): UseMutationOptions<RolesCreateResponse, DefaultError, Options<RolesCreateData>> => {
    const mutationOptions: UseMutationOptions<RolesCreateResponse, DefaultError, Options<RolesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await rolesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 *
 * Delete a custom role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const rolesDeleteMutation = (options?: Partial<Options<RolesDeleteData>>): UseMutationOptions<RolesDeleteResponse, DefaultError, Options<RolesDeleteData>> => {
    const mutationOptions: UseMutationOptions<RolesDeleteResponse, DefaultError, Options<RolesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await rolesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const rolesGetQueryKey = (options: Options<RolesGetData>) => createQueryKey('rolesGet', options);

/**
 * Get role
 *
 * Get a role by ID
 */
export const rolesGetOptions = (options: Options<RolesGetData>) => queryOptions<RolesGetResponse, DefaultError, RolesGetResponse, ReturnType<typeof rolesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await rolesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: rolesGetQueryKey(options)
});

/**
 * Update role
 *
 * Update a custom role
 *
 * System roles cannot be modified.
 */
export const rolesUpdateMutation = (options?: Partial<Options<RolesUpdateData>>): UseMutationOptions<RolesUpdateResponse, DefaultError, Options<RolesUpdateData>> => {
    const mutationOptions: UseMutationOptions<RolesUpdateResponse, DefaultError, Options<RolesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await rolesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersListQueryKey = (options: Options<UsersListData>) => createQueryKey('usersList', options);

/**
 * List users
 *
 * List users in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const usersListOptions = (options: Options<UsersListData>) => queryOptions<UsersListResponse, DefaultError, UsersListResponse, ReturnType<typeof usersListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await usersList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersListQueryKey(options)
});

export const usersListInfiniteQueryKey = (options: Options<UsersListData>): QueryKey<Options<UsersListData>> => createQueryKey('usersList', options, true);

/**
 * List users
 *
 * List users in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const usersListInfiniteOptions = (options: Options<UsersListData>) => infiniteQueryOptions<UsersListResponse, DefaultError, InfiniteData<UsersListResponse>, QueryKey<Options<UsersListData>>, number | Pick<QueryKey<Options<UsersListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<UsersListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await usersList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersListInfiniteQueryKey(options)
});

/**
 * Create user
 *
 * Create a new user
 */
export const usersCreateMutation = (options?: Partial<Options<UsersCreateData>>): UseMutationOptions<UsersCreateResponse, DefaultError, Options<UsersCreateData>> => {
    const mutationOptions: UseMutationOptions<UsersCreateResponse, DefaultError, Options<UsersCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch update users
 *
 * Batch update users
 */
export const usersBatchUpdateMutation = (options?: Partial<Options<UsersBatchUpdateData>>): UseMutationOptions<UsersBatchUpdateResponse, DefaultError, Options<UsersBatchUpdateData>> => {
    const mutationOptions: UseMutationOptions<UsersBatchUpdateResponse, DefaultError, Options<UsersBatchUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersBatchUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch create users
 *
 * Batch create users
 */
export const usersBatchCreateMutation = (options?: Partial<Options<UsersBatchCreateData>>): UseMutationOptions<UsersBatchCreateResponse, DefaultError, Options<UsersBatchCreateData>> => {
    const mutationOptions: UseMutationOptions<UsersBatchCreateResponse, DefaultError, Options<UsersBatchCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersBatchCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch soft delete users
 *
 * Batch soft delete users
 */
export const usersBatchSoftDeleteMutation = (options?: Partial<Options<UsersBatchSoftDeleteData>>): UseMutationOptions<UsersBatchSoftDeleteResponse, DefaultError, Options<UsersBatchSoftDeleteData>> => {
    const mutationOptions: UseMutationOptions<UsersBatchSoftDeleteResponse, DefaultError, Options<UsersBatchSoftDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersBatchSoftDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Soft delete user
 *
 * Soft delete a user (default delete behavior)
 * User is marked as deleted but can be restored
 */
export const usersDeleteMutation = (options?: Partial<Options<UsersDeleteData>>): UseMutationOptions<UsersDeleteResponse, DefaultError, Options<UsersDeleteData>> => {
    const mutationOptions: UseMutationOptions<UsersDeleteResponse, DefaultError, Options<UsersDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersGetQueryKey = (options: Options<UsersGetData>) => createQueryKey('usersGet', options);

/**
 * Get user
 *
 * Get a single user by ID
 */
export const usersGetOptions = (options: Options<UsersGetData>) => queryOptions<UsersGetResponse, DefaultError, UsersGetResponse, ReturnType<typeof usersGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await usersGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersGetQueryKey(options)
});

/**
 * Update user
 *
 * Update a user (partial update)
 */
export const usersUpdateMutation = (options?: Partial<Options<UsersUpdateData>>): UseMutationOptions<UsersUpdateResponse, DefaultError, Options<UsersUpdateData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdateResponse, DefaultError, Options<UsersUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset user password
 *
 * Custom action: Reset user password
 */
export const usersResetPasswordMutation = (options?: Partial<Options<UsersResetPasswordData>>): UseMutationOptions<UsersResetPasswordResponse, DefaultError, Options<UsersResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<UsersResetPasswordResponse, DefaultError, Options<UsersResetPasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersResetPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete user
 *
 * Permanently delete a user (hard delete)
 * User is permanently removed and cannot be restored
 */
export const usersDeletePermanentMutation = (options?: Partial<Options<UsersDeletePermanentData>>): UseMutationOptions<UsersDeletePermanentResponse, DefaultError, Options<UsersDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<UsersDeletePermanentResponse, DefaultError, Options<UsersDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore user
 *
 * Restore a soft-deleted user
 */
export const usersRestoreMutation = (options?: Partial<Options<UsersRestoreData>>): UseMutationOptions<UsersRestoreResponse, DefaultError, Options<UsersRestoreData>> => {
    const mutationOptions: UseMutationOptions<UsersRestoreResponse, DefaultError, Options<UsersRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const userPermissionsEndpointGetQueryKey = (options: Options<UserPermissionsEndpointGetData>) => createQueryKey('userPermissionsEndpointGet', options);

/**
 * Get user permissions
 *
 * Get user's effective permissions in this tenant
 *
 * Returns all roles and the combined effective permissions.
 */
export const userPermissionsEndpointGetOptions = (options: Options<UserPermissionsEndpointGetData>) => queryOptions<UserPermissionsEndpointGetResponse, DefaultError, UserPermissionsEndpointGetResponse, ReturnType<typeof userPermissionsEndpointGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await userPermissionsEndpointGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: userPermissionsEndpointGetQueryKey(options)
});

export const userRolesListQueryKey = (options: Options<UserRolesListData>) => createQueryKey('userRolesList', options);

/**
 * List user roles
 *
 * List roles assigned to a user in this tenant
 */
export const userRolesListOptions = (options: Options<UserRolesListData>) => queryOptions<UserRolesListResponse, DefaultError, UserRolesListResponse, ReturnType<typeof userRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await userRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: userRolesListQueryKey(options)
});

/**
 * Assign role to user
 *
 * Assign a role to a user
 */
export const userRolesAssignMutation = (options?: Partial<Options<UserRolesAssignData>>): UseMutationOptions<UserRolesAssignResponse, DefaultError, Options<UserRolesAssignData>> => {
    const mutationOptions: UseMutationOptions<UserRolesAssignResponse, DefaultError, Options<UserRolesAssignData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await userRolesAssign({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove role from user
 *
 * Remove a role from a user
 */
export const userRolesRemoveMutation = (options?: Partial<Options<UserRolesRemoveData>>): UseMutationOptions<UserRolesRemoveResponse, DefaultError, Options<UserRolesRemoveData>> => {
    const mutationOptions: UseMutationOptions<UserRolesRemoveResponse, DefaultError, Options<UserRolesRemoveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await userRolesRemove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListQueryKey = (options: Options<WebhooksListData>) => createQueryKey('webhooksList', options);

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksListOptions = (options: Options<WebhooksListData>) => queryOptions<WebhooksListResponse, DefaultError, WebhooksListResponse, ReturnType<typeof webhooksListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListQueryKey(options)
});

export const webhooksListInfiniteQueryKey = (options: Options<WebhooksListData>): QueryKey<Options<WebhooksListData>> => createQueryKey('webhooksList', options, true);

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksListInfiniteOptions = (options: Options<WebhooksListData>) => infiniteQueryOptions<WebhooksListResponse, DefaultError, InfiniteData<WebhooksListResponse>, QueryKey<Options<WebhooksListData>>, number | Pick<QueryKey<Options<WebhooksListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<WebhooksListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await webhooksList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListInfiniteQueryKey(options)
});

/**
 * Create webhook
 *
 * Create a new webhook
 *
 * The secret is only returned once in the response.
 * Store it securely for signature verification.
 */
export const webhooksCreateMutation = (options?: Partial<Options<WebhooksCreateData>>): UseMutationOptions<WebhooksCreateResponse, DefaultError, Options<WebhooksCreateData>> => {
    const mutationOptions: UseMutationOptions<WebhooksCreateResponse, DefaultError, Options<WebhooksCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListEventTypesQueryKey = (options: Options<WebhooksListEventTypesData>) => createQueryKey('webhooksListEventTypes', options);

/**
 * List event types
 *
 * Get available event types
 *
 * Returns all event types that can be subscribed to.
 */
export const webhooksListEventTypesOptions = (options: Options<WebhooksListEventTypesData>) => queryOptions<WebhooksListEventTypesResponse, DefaultError, WebhooksListEventTypesResponse, ReturnType<typeof webhooksListEventTypesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksListEventTypes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListEventTypesQueryKey(options)
});

/**
 * Delete webhook
 *
 * Delete a webhook
 */
export const webhooksDeleteMutation = (options?: Partial<Options<WebhooksDeleteData>>): UseMutationOptions<WebhooksDeleteResponse, DefaultError, Options<WebhooksDeleteData>> => {
    const mutationOptions: UseMutationOptions<WebhooksDeleteResponse, DefaultError, Options<WebhooksDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksGetQueryKey = (options: Options<WebhooksGetData>) => createQueryKey('webhooksGet', options);

/**
 * Get webhook
 *
 * Get a webhook by ID
 */
export const webhooksGetOptions = (options: Options<WebhooksGetData>) => queryOptions<WebhooksGetResponse, DefaultError, WebhooksGetResponse, ReturnType<typeof webhooksGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksGetQueryKey(options)
});

/**
 * Update webhook
 *
 * Update a webhook
 */
export const webhooksUpdateMutation = (options?: Partial<Options<WebhooksUpdateData>>): UseMutationOptions<WebhooksUpdateResponse, DefaultError, Options<WebhooksUpdateData>> => {
    const mutationOptions: UseMutationOptions<WebhooksUpdateResponse, DefaultError, Options<WebhooksUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListDeliveriesQueryKey = (options: Options<WebhooksListDeliveriesData>) => createQueryKey('webhooksListDeliveries', options);

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveriesOptions = (options: Options<WebhooksListDeliveriesData>) => queryOptions<WebhooksListDeliveriesResponse, DefaultError, WebhooksListDeliveriesResponse, ReturnType<typeof webhooksListDeliveriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksListDeliveries({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListDeliveriesQueryKey(options)
});

export const webhooksListDeliveriesInfiniteQueryKey = (options: Options<WebhooksListDeliveriesData>): QueryKey<Options<WebhooksListDeliveriesData>> => createQueryKey('webhooksListDeliveries', options, true);

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveriesInfiniteOptions = (options: Options<WebhooksListDeliveriesData>) => infiniteQueryOptions<WebhooksListDeliveriesResponse, DefaultError, InfiniteData<WebhooksListDeliveriesResponse>, QueryKey<Options<WebhooksListDeliveriesData>>, number | Pick<QueryKey<Options<WebhooksListDeliveriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<WebhooksListDeliveriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await webhooksListDeliveries({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListDeliveriesInfiniteQueryKey(options)
});

export const webhooksGetDeliveryQueryKey = (options: Options<WebhooksGetDeliveryData>) => createQueryKey('webhooksGetDelivery', options);

/**
 * Get webhook delivery
 *
 * Get a specific delivery
 */
export const webhooksGetDeliveryOptions = (options: Options<WebhooksGetDeliveryData>) => queryOptions<WebhooksGetDeliveryResponse, DefaultError, WebhooksGetDeliveryResponse, ReturnType<typeof webhooksGetDeliveryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksGetDelivery({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksGetDeliveryQueryKey(options)
});

/**
 * Retry delivery
 *
 * Retry a failed delivery
 *
 * Manually triggers a retry for a failed delivery.
 */
export const webhooksRetryDeliveryMutation = (options?: Partial<Options<WebhooksRetryDeliveryData>>): UseMutationOptions<WebhooksRetryDeliveryResponse, DefaultError, Options<WebhooksRetryDeliveryData>> => {
    const mutationOptions: UseMutationOptions<WebhooksRetryDeliveryResponse, DefaultError, Options<WebhooksRetryDeliveryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksRetryDelivery({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rotate webhook secret
 *
 * Rotate webhook secret
 *
 * Generates a new secret. The old secret immediately stops working.
 */
export const webhooksRotateSecretMutation = (options?: Partial<Options<WebhooksRotateSecretData>>): UseMutationOptions<WebhooksRotateSecretResponse, DefaultError, Options<WebhooksRotateSecretData>> => {
    const mutationOptions: UseMutationOptions<WebhooksRotateSecretResponse, DefaultError, Options<WebhooksRotateSecretData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksRotateSecret({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test webhook
 *
 * Test a webhook
 *
 * Sends a test event to verify the webhook is configured correctly.
 */
export const webhooksTestMutation = (options?: Partial<Options<WebhooksTestData>>): UseMutationOptions<WebhooksTestResponse, DefaultError, Options<WebhooksTestData>> => {
    const mutationOptions: UseMutationOptions<WebhooksTestResponse, DefaultError, Options<WebhooksTestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksTest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Switch tenant
 *
 * Switch user's active tenant
 *
 * Returns a new access token scoped to the target tenant.
 */
export const tenantSwitchSwitchMutation = (options?: Partial<Options<TenantSwitchSwitchData>>): UseMutationOptions<TenantSwitchSwitchResponse, DefaultError, Options<TenantSwitchSwitchData>> => {
    const mutationOptions: UseMutationOptions<TenantSwitchSwitchResponse, DefaultError, Options<TenantSwitchSwitchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await tenantSwitchSwitch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const crossTenantRolesListQueryKey = (options: Options<CrossTenantRolesListData>) => createQueryKey('crossTenantRolesList', options);

/**
 * List user tenant roles
 *
 * List user's roles across all tenants
 *
 * Returns all tenants the user belongs to with their roles.
 */
export const crossTenantRolesListOptions = (options: Options<CrossTenantRolesListData>) => queryOptions<CrossTenantRolesListResponse, DefaultError, CrossTenantRolesListResponse, ReturnType<typeof crossTenantRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await crossTenantRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: crossTenantRolesListQueryKey(options)
});
