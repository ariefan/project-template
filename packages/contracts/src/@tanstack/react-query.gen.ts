// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { allUserRolesList, announcementsAcknowledge, announcementsCreate, announcementsDelete, announcementsDismiss, announcementsGet, announcementsGetStats, announcementsGetUnreadCount, announcementsList, announcementsMarkRead, announcementsMarkViewed, announcementsUpdate, auditLogsExport, auditLogsGet, auditLogsList, availableContextsList, contextSwitchSwitch, couponsAdminCreate, couponsAdminDelete, couponsAdminGet, couponsAdminList, couponsAdminUpdate, currentUserContextGet, exampleCommentsBatchCreate, exampleCommentsBatchSoftDelete, exampleCommentsCreate, exampleCommentsDelete, exampleCommentsDeletePermanent, exampleCommentsGet, exampleCommentsList, exampleCommentsRestore, exampleCommentsUpdate, examplePostsBatchCreate, examplePostsBatchRestore, examplePostsBatchSoftDelete, examplePostsBatchUpdate, examplePostsCreate, examplePostsDelete, examplePostsDeletePermanent, examplePostsGet, examplePostsList, examplePostsListCursor, examplePostsListDeleted, examplePostsRestore, examplePostsUpdate, filesConfirmUpload, filesDelete, filesDeletePermanent, filesDirectUpload, filesDownload, filesGet, filesInitiateUpload, filesList, filesUpdate, globalRolesCreate, globalRolesDelete, globalRolesGet, globalRolesList, globalRolesUpdate, healthCheck, jobsCancel, jobsDownload, jobsGet, jobsList, jobsRetry, migrationGetStatus, notificationPreferencesRoutesGetPreferences, notificationPreferencesRoutesUpdatePreferences, notificationsDelete, notificationsGet, notificationsGetUnreadCount, notificationsList, notificationsMarkAllRead, notificationsMarkRead, notificationsMarkUnread, notificationsPreviewEmail, notificationsRestore, notificationsSend, type Options, paymentWebhooksHandleMidtrans, paymentWebhooksHandleXendit, publicPricingListPublicPlans, reportExportsExport, reportExportsPreviewExport, reportExportsStreamExport, reportTemplatesClone, reportTemplatesCreate, reportTemplatesDelete, reportTemplatesGet, reportTemplatesList, reportTemplatesTest, reportTemplatesUpdate, scheduledReportsCreate, scheduledReportsDelete, scheduledReportsGet, scheduledReportsGetHistory, scheduledReportsList, scheduledReportsPause, scheduledReportsResume, scheduledReportsRunNow, scheduledReportsUpdate, subscriptionPlansAdminCreate, subscriptionPlansAdminDelete, subscriptionPlansAdminGet, subscriptionPlansAdminList, subscriptionPlansAdminUpdate, subscriptionsApplyCoupon, subscriptionsCancel, subscriptionsCreate, subscriptionsGetCurrent, subscriptionsResume, subscriptionsUpdate, subscriptionsValidateCoupon, tenantRolesCreate, tenantRolesDelete, tenantRolesGet, tenantRolesList, tenantRolesUpdate, userPermissionsGet, userTenantRolesAssign, userTenantRolesList, userTenantRolesRemove, webhooksCreate, webhooksDelete, webhooksGet, webhooksGetDelivery, webhooksList, webhooksListDeliveries, webhooksListEventTypes, webhooksRetryDelivery, webhooksRotateSecret, webhooksTest, webhooksUpdate } from '../sdk.gen';
import type { AllUserRolesListData, AllUserRolesListResponse, AnnouncementsAcknowledgeData, AnnouncementsAcknowledgeResponse, AnnouncementsCreateData, AnnouncementsCreateResponse, AnnouncementsDeleteData, AnnouncementsDeleteResponse, AnnouncementsDismissData, AnnouncementsDismissResponse, AnnouncementsGetData, AnnouncementsGetResponse, AnnouncementsGetStatsData, AnnouncementsGetStatsResponse, AnnouncementsGetUnreadCountData, AnnouncementsGetUnreadCountResponse, AnnouncementsListData, AnnouncementsListResponse, AnnouncementsMarkReadData, AnnouncementsMarkReadResponse, AnnouncementsMarkViewedData, AnnouncementsMarkViewedResponse, AnnouncementsUpdateData, AnnouncementsUpdateResponse, AuditLogsExportData, AuditLogsExportResponse, AuditLogsGetData, AuditLogsGetResponse, AuditLogsListData, AuditLogsListResponse, AvailableContextsListData, AvailableContextsListResponse, ContextSwitchSwitchData, ContextSwitchSwitchResponse, CouponsAdminCreateData, CouponsAdminCreateResponse, CouponsAdminDeleteData, CouponsAdminDeleteResponse, CouponsAdminGetData, CouponsAdminGetResponse, CouponsAdminListData, CouponsAdminListResponse, CouponsAdminUpdateData, CouponsAdminUpdateResponse, CurrentUserContextGetData, CurrentUserContextGetResponse, ExampleCommentsBatchCreateData, ExampleCommentsBatchCreateResponse, ExampleCommentsBatchSoftDeleteData, ExampleCommentsBatchSoftDeleteResponse, ExampleCommentsCreateData, ExampleCommentsCreateResponse, ExampleCommentsDeleteData, ExampleCommentsDeletePermanentData, ExampleCommentsDeletePermanentResponse, ExampleCommentsDeleteResponse, ExampleCommentsGetData, ExampleCommentsGetResponse, ExampleCommentsListData, ExampleCommentsListResponse, ExampleCommentsRestoreData, ExampleCommentsRestoreResponse, ExampleCommentsUpdateData, ExampleCommentsUpdateResponse, ExamplePostsBatchCreateData, ExamplePostsBatchCreateResponse, ExamplePostsBatchRestoreData, ExamplePostsBatchRestoreResponse, ExamplePostsBatchSoftDeleteData, ExamplePostsBatchSoftDeleteResponse, ExamplePostsBatchUpdateData, ExamplePostsBatchUpdateResponse, ExamplePostsCreateData, ExamplePostsCreateResponse, ExamplePostsDeleteData, ExamplePostsDeletePermanentData, ExamplePostsDeletePermanentResponse, ExamplePostsDeleteResponse, ExamplePostsGetData, ExamplePostsGetResponse, ExamplePostsListCursorData, ExamplePostsListCursorResponse, ExamplePostsListData, ExamplePostsListDeletedData, ExamplePostsListDeletedResponse, ExamplePostsListResponse, ExamplePostsRestoreData, ExamplePostsRestoreResponse, ExamplePostsUpdateData, ExamplePostsUpdateResponse, FilesConfirmUploadData, FilesConfirmUploadResponse, FilesDeleteData, FilesDeletePermanentData, FilesDeletePermanentResponse, FilesDeleteResponse, FilesDirectUploadData, FilesDirectUploadResponse, FilesDownloadData, FilesDownloadResponse, FilesGetData, FilesGetResponse, FilesInitiateUploadData, FilesInitiateUploadResponse, FilesListData, FilesListResponse, FilesUpdateData, FilesUpdateResponse, GlobalRolesCreateData, GlobalRolesCreateResponse, GlobalRolesDeleteData, GlobalRolesDeleteResponse, GlobalRolesGetData, GlobalRolesGetResponse, GlobalRolesListData, GlobalRolesListResponse, GlobalRolesUpdateData, GlobalRolesUpdateResponse, HealthCheckData, HealthCheckResponse, JobsCancelData, JobsCancelResponse, JobsDownloadData, JobsDownloadResponse, JobsGetData, JobsGetResponse, JobsListData, JobsListResponse, JobsRetryData, JobsRetryResponse, MigrationGetStatusData, MigrationGetStatusResponse, NotificationPreferencesRoutesGetPreferencesData, NotificationPreferencesRoutesGetPreferencesResponse, NotificationPreferencesRoutesUpdatePreferencesData, NotificationPreferencesRoutesUpdatePreferencesResponse, NotificationsDeleteData, NotificationsDeleteResponse, NotificationsGetData, NotificationsGetResponse, NotificationsGetUnreadCountData, NotificationsGetUnreadCountResponse, NotificationsListData, NotificationsListResponse, NotificationsMarkAllReadData, NotificationsMarkAllReadResponse, NotificationsMarkReadData, NotificationsMarkReadResponse, NotificationsMarkUnreadData, NotificationsMarkUnreadResponse, NotificationsPreviewEmailData, NotificationsPreviewEmailResponse, NotificationsRestoreData, NotificationsRestoreResponse, NotificationsSendData, NotificationsSendResponse, PaymentWebhooksHandleMidtransData, PaymentWebhooksHandleMidtransResponse, PaymentWebhooksHandleXenditData, PaymentWebhooksHandleXenditResponse, PublicPricingListPublicPlansData, PublicPricingListPublicPlansResponse, ReportExportsExportData, ReportExportsExportResponse, ReportExportsPreviewExportData, ReportExportsPreviewExportResponse, ReportExportsStreamExportData, ReportExportsStreamExportResponse, ReportTemplatesCloneData, ReportTemplatesCloneResponse, ReportTemplatesCreateData, ReportTemplatesCreateResponse, ReportTemplatesDeleteData, ReportTemplatesDeleteResponse, ReportTemplatesGetData, ReportTemplatesGetResponse, ReportTemplatesListData, ReportTemplatesListResponse, ReportTemplatesTestData, ReportTemplatesTestResponse, ReportTemplatesUpdateData, ReportTemplatesUpdateResponse, ScheduledReportsCreateData, ScheduledReportsCreateResponse, ScheduledReportsDeleteData, ScheduledReportsDeleteResponse, ScheduledReportsGetData, ScheduledReportsGetHistoryData, ScheduledReportsGetHistoryResponse, ScheduledReportsGetResponse, ScheduledReportsListData, ScheduledReportsListResponse, ScheduledReportsPauseData, ScheduledReportsPauseResponse, ScheduledReportsResumeData, ScheduledReportsResumeResponse, ScheduledReportsRunNowData, ScheduledReportsRunNowResponse, ScheduledReportsUpdateData, ScheduledReportsUpdateResponse, SubscriptionPlansAdminCreateData, SubscriptionPlansAdminCreateResponse, SubscriptionPlansAdminDeleteData, SubscriptionPlansAdminDeleteResponse, SubscriptionPlansAdminGetData, SubscriptionPlansAdminGetResponse, SubscriptionPlansAdminListData, SubscriptionPlansAdminListResponse, SubscriptionPlansAdminUpdateData, SubscriptionPlansAdminUpdateResponse, SubscriptionsApplyCouponData, SubscriptionsApplyCouponResponse, SubscriptionsCancelData, SubscriptionsCancelResponse, SubscriptionsCreateData, SubscriptionsCreateResponse, SubscriptionsGetCurrentData, SubscriptionsGetCurrentResponse, SubscriptionsResumeData, SubscriptionsResumeResponse, SubscriptionsUpdateData, SubscriptionsUpdateResponse, SubscriptionsValidateCouponData, SubscriptionsValidateCouponResponse, TenantRolesCreateData, TenantRolesCreateResponse, TenantRolesDeleteData, TenantRolesDeleteResponse, TenantRolesGetData, TenantRolesGetResponse, TenantRolesListData, TenantRolesListResponse, TenantRolesUpdateData, TenantRolesUpdateResponse, UserPermissionsGetData, UserPermissionsGetResponse, UserTenantRolesAssignData, UserTenantRolesAssignResponse, UserTenantRolesListData, UserTenantRolesListResponse, UserTenantRolesRemoveData, UserTenantRolesRemoveResponse, WebhooksCreateData, WebhooksCreateResponse, WebhooksDeleteData, WebhooksDeleteResponse, WebhooksGetData, WebhooksGetDeliveryData, WebhooksGetDeliveryResponse, WebhooksGetResponse, WebhooksListData, WebhooksListDeliveriesData, WebhooksListDeliveriesResponse, WebhooksListEventTypesData, WebhooksListEventTypesResponse, WebhooksListResponse, WebhooksRetryDeliveryData, WebhooksRetryDeliveryResponse, WebhooksRotateSecretData, WebhooksRotateSecretResponse, WebhooksTestData, WebhooksTestResponse, WebhooksUpdateData, WebhooksUpdateResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) => createQueryKey('healthCheck', options);

/**
 * Health check
 *
 * Check API health status
 * Returns 200 OK if the API is healthy
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) => queryOptions<HealthCheckResponse, DefaultError, HealthCheckResponse, ReturnType<typeof healthCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await healthCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthCheckQueryKey(options)
});

export const couponsAdminListQueryKey = (options?: Options<CouponsAdminListData>) => createQueryKey('couponsAdminList', options);

/**
 * List coupons
 *
 * List coupons
 *
 * Returns all coupons with optional filtering.
 */
export const couponsAdminListOptions = (options?: Options<CouponsAdminListData>) => queryOptions<CouponsAdminListResponse, DefaultError, CouponsAdminListResponse, ReturnType<typeof couponsAdminListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await couponsAdminList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: couponsAdminListQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const couponsAdminListInfiniteQueryKey = (options?: Options<CouponsAdminListData>): QueryKey<Options<CouponsAdminListData>> => createQueryKey('couponsAdminList', options, true);

/**
 * List coupons
 *
 * List coupons
 *
 * Returns all coupons with optional filtering.
 */
export const couponsAdminListInfiniteOptions = (options?: Options<CouponsAdminListData>) => infiniteQueryOptions<CouponsAdminListResponse, DefaultError, InfiniteData<CouponsAdminListResponse>, QueryKey<Options<CouponsAdminListData>>, number | Pick<QueryKey<Options<CouponsAdminListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<CouponsAdminListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await couponsAdminList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: couponsAdminListInfiniteQueryKey(options)
});

/**
 * Create coupon
 *
 * Create coupon
 *
 * Creates a new discount coupon.
 */
export const couponsAdminCreateMutation = (options?: Partial<Options<CouponsAdminCreateData>>): UseMutationOptions<CouponsAdminCreateResponse, DefaultError, Options<CouponsAdminCreateData>> => {
    const mutationOptions: UseMutationOptions<CouponsAdminCreateResponse, DefaultError, Options<CouponsAdminCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await couponsAdminCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete coupon
 *
 * Delete coupon
 *
 * Soft deletes a coupon (sets isActive to false).
 */
export const couponsAdminDeleteMutation = (options?: Partial<Options<CouponsAdminDeleteData>>): UseMutationOptions<CouponsAdminDeleteResponse, DefaultError, Options<CouponsAdminDeleteData>> => {
    const mutationOptions: UseMutationOptions<CouponsAdminDeleteResponse, DefaultError, Options<CouponsAdminDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await couponsAdminDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const couponsAdminGetQueryKey = (options: Options<CouponsAdminGetData>) => createQueryKey('couponsAdminGet', options);

/**
 * Get coupon
 *
 * Get coupon
 *
 * Returns a single coupon by ID.
 */
export const couponsAdminGetOptions = (options: Options<CouponsAdminGetData>) => queryOptions<CouponsAdminGetResponse, DefaultError, CouponsAdminGetResponse, ReturnType<typeof couponsAdminGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await couponsAdminGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: couponsAdminGetQueryKey(options)
});

/**
 * Update coupon
 *
 * Update coupon
 *
 * Updates an existing coupon.
 */
export const couponsAdminUpdateMutation = (options?: Partial<Options<CouponsAdminUpdateData>>): UseMutationOptions<CouponsAdminUpdateResponse, DefaultError, Options<CouponsAdminUpdateData>> => {
    const mutationOptions: UseMutationOptions<CouponsAdminUpdateResponse, DefaultError, Options<CouponsAdminUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await couponsAdminUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const subscriptionPlansAdminListQueryKey = (options?: Options<SubscriptionPlansAdminListData>) => createQueryKey('subscriptionPlansAdminList', options);

/**
 * List subscription plans
 *
 * List subscription plans
 *
 * Returns all plans with optional filtering.
 * Admin endpoint - returns all plans including archived.
 */
export const subscriptionPlansAdminListOptions = (options?: Options<SubscriptionPlansAdminListData>) => queryOptions<SubscriptionPlansAdminListResponse, DefaultError, SubscriptionPlansAdminListResponse, ReturnType<typeof subscriptionPlansAdminListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await subscriptionPlansAdminList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: subscriptionPlansAdminListQueryKey(options)
});

export const subscriptionPlansAdminListInfiniteQueryKey = (options?: Options<SubscriptionPlansAdminListData>): QueryKey<Options<SubscriptionPlansAdminListData>> => createQueryKey('subscriptionPlansAdminList', options, true);

/**
 * List subscription plans
 *
 * List subscription plans
 *
 * Returns all plans with optional filtering.
 * Admin endpoint - returns all plans including archived.
 */
export const subscriptionPlansAdminListInfiniteOptions = (options?: Options<SubscriptionPlansAdminListData>) => infiniteQueryOptions<SubscriptionPlansAdminListResponse, DefaultError, InfiniteData<SubscriptionPlansAdminListResponse>, QueryKey<Options<SubscriptionPlansAdminListData>>, number | Pick<QueryKey<Options<SubscriptionPlansAdminListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<SubscriptionPlansAdminListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await subscriptionPlansAdminList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: subscriptionPlansAdminListInfiniteQueryKey(options)
});

/**
 * Create subscription plan
 *
 * Create subscription plan
 *
 * Creates a new subscription plan.
 */
export const subscriptionPlansAdminCreateMutation = (options?: Partial<Options<SubscriptionPlansAdminCreateData>>): UseMutationOptions<SubscriptionPlansAdminCreateResponse, DefaultError, Options<SubscriptionPlansAdminCreateData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionPlansAdminCreateResponse, DefaultError, Options<SubscriptionPlansAdminCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionPlansAdminCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete subscription plan
 *
 * Delete subscription plan
 *
 * Soft deletes a plan (sets visibility to archived).
 * Plans with active subscriptions cannot be hard deleted.
 */
export const subscriptionPlansAdminDeleteMutation = (options?: Partial<Options<SubscriptionPlansAdminDeleteData>>): UseMutationOptions<SubscriptionPlansAdminDeleteResponse, DefaultError, Options<SubscriptionPlansAdminDeleteData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionPlansAdminDeleteResponse, DefaultError, Options<SubscriptionPlansAdminDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionPlansAdminDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const subscriptionPlansAdminGetQueryKey = (options: Options<SubscriptionPlansAdminGetData>) => createQueryKey('subscriptionPlansAdminGet', options);

/**
 * Get subscription plan
 *
 * Get subscription plan
 *
 * Returns a single plan by ID.
 */
export const subscriptionPlansAdminGetOptions = (options: Options<SubscriptionPlansAdminGetData>) => queryOptions<SubscriptionPlansAdminGetResponse, DefaultError, SubscriptionPlansAdminGetResponse, ReturnType<typeof subscriptionPlansAdminGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await subscriptionPlansAdminGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: subscriptionPlansAdminGetQueryKey(options)
});

/**
 * Update subscription plan
 *
 * Update subscription plan
 *
 * Updates an existing subscription plan.
 * Warning: Changing pricing affects future billing only.
 */
export const subscriptionPlansAdminUpdateMutation = (options?: Partial<Options<SubscriptionPlansAdminUpdateData>>): UseMutationOptions<SubscriptionPlansAdminUpdateResponse, DefaultError, Options<SubscriptionPlansAdminUpdateData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionPlansAdminUpdateResponse, DefaultError, Options<SubscriptionPlansAdminUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionPlansAdminUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const migrationGetStatusQueryKey = (options?: Options<MigrationGetStatusData>) => createQueryKey('migrationGetStatus', options);

/**
 * Get API version migration status
 *
 * Get migration status for the current API version
 *
 * Returns information about:
 * - Current version status (current, deprecated, sunset)
 * - Sunset date if deprecated
 * - Replacement version to migrate to
 * - Breaking changes and migration checklist
 */
export const migrationGetStatusOptions = (options?: Options<MigrationGetStatusData>) => queryOptions<MigrationGetStatusResponse, DefaultError, MigrationGetStatusResponse, ReturnType<typeof migrationGetStatusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await migrationGetStatus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: migrationGetStatusQueryKey(options)
});

export const notificationsListQueryKey = (options?: Options<NotificationsListData>) => createQueryKey('notificationsList', options);

/**
 * List notifications
 *
 * List user's notification history
 * Returns notifications for the authenticated user, excluding soft-deleted ones
 */
export const notificationsListOptions = (options?: Options<NotificationsListData>) => queryOptions<NotificationsListResponse, DefaultError, NotificationsListResponse, ReturnType<typeof notificationsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await notificationsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationsListQueryKey(options)
});

export const notificationsListInfiniteQueryKey = (options?: Options<NotificationsListData>): QueryKey<Options<NotificationsListData>> => createQueryKey('notificationsList', options, true);

/**
 * List notifications
 *
 * List user's notification history
 * Returns notifications for the authenticated user, excluding soft-deleted ones
 */
export const notificationsListInfiniteOptions = (options?: Options<NotificationsListData>) => infiniteQueryOptions<NotificationsListResponse, DefaultError, InfiniteData<NotificationsListResponse>, QueryKey<Options<NotificationsListData>>, number | Pick<QueryKey<Options<NotificationsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<NotificationsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await notificationsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationsListInfiniteQueryKey(options)
});

/**
 * Mark all notifications as read
 *
 * Mark all notifications as read for the current user
 * Returns the count of notifications that were marked as read
 */
export const notificationsMarkAllReadMutation = (options?: Partial<Options<NotificationsMarkAllReadData>>): UseMutationOptions<NotificationsMarkAllReadResponse, DefaultError, Options<NotificationsMarkAllReadData>> => {
    const mutationOptions: UseMutationOptions<NotificationsMarkAllReadResponse, DefaultError, Options<NotificationsMarkAllReadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await notificationsMarkAllRead({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Preview email template
 *
 * Preview an email template
 * Renders the template with provided data and returns HTML/text content
 */
export const notificationsPreviewEmailMutation = (options?: Partial<Options<NotificationsPreviewEmailData>>): UseMutationOptions<NotificationsPreviewEmailResponse, DefaultError, Options<NotificationsPreviewEmailData>> => {
    const mutationOptions: UseMutationOptions<NotificationsPreviewEmailResponse, DefaultError, Options<NotificationsPreviewEmailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await notificationsPreviewEmail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Send notification
 *
 * Send a notification
 * Queues the notification for delivery through the specified channel
 * Requires authentication. Consider adding authorization for production use.
 */
export const notificationsSendMutation = (options?: Partial<Options<NotificationsSendData>>): UseMutationOptions<NotificationsSendResponse, DefaultError, Options<NotificationsSendData>> => {
    const mutationOptions: UseMutationOptions<NotificationsSendResponse, DefaultError, Options<NotificationsSendData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await notificationsSend({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const notificationsGetUnreadCountQueryKey = (options?: Options<NotificationsGetUnreadCountData>) => createQueryKey('notificationsGetUnreadCount', options);

/**
 * Get unread notification count
 *
 * Get count of unread notifications
 * Returns the number of unread notifications for the current user
 */
export const notificationsGetUnreadCountOptions = (options?: Options<NotificationsGetUnreadCountData>) => queryOptions<NotificationsGetUnreadCountResponse, DefaultError, NotificationsGetUnreadCountResponse, ReturnType<typeof notificationsGetUnreadCountQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await notificationsGetUnreadCount({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationsGetUnreadCountQueryKey(options)
});

/**
 * Delete notification
 *
 * Soft delete a notification
 * Marks the notification as deleted without actually removing it
 */
export const notificationsDeleteMutation = (options?: Partial<Options<NotificationsDeleteData>>): UseMutationOptions<NotificationsDeleteResponse, DefaultError, Options<NotificationsDeleteData>> => {
    const mutationOptions: UseMutationOptions<NotificationsDeleteResponse, DefaultError, Options<NotificationsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await notificationsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const notificationsGetQueryKey = (options: Options<NotificationsGetData>) => createQueryKey('notificationsGet', options);

/**
 * Get notification by ID
 *
 * Get a specific notification by ID
 * Only returns notifications owned by the authenticated user
 */
export const notificationsGetOptions = (options: Options<NotificationsGetData>) => queryOptions<NotificationsGetResponse, DefaultError, NotificationsGetResponse, ReturnType<typeof notificationsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await notificationsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationsGetQueryKey(options)
});

/**
 * Mark notification as read
 *
 * Mark a notification as read
 * Updates the readAt timestamp for the notification
 */
export const notificationsMarkReadMutation = (options?: Partial<Options<NotificationsMarkReadData>>): UseMutationOptions<NotificationsMarkReadResponse, DefaultError, Options<NotificationsMarkReadData>> => {
    const mutationOptions: UseMutationOptions<NotificationsMarkReadResponse, DefaultError, Options<NotificationsMarkReadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await notificationsMarkRead({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore notification
 *
 * Restore a soft-deleted notification
 * Clears the deletedAt timestamp to restore the notification
 */
export const notificationsRestoreMutation = (options?: Partial<Options<NotificationsRestoreData>>): UseMutationOptions<NotificationsRestoreResponse, DefaultError, Options<NotificationsRestoreData>> => {
    const mutationOptions: UseMutationOptions<NotificationsRestoreResponse, DefaultError, Options<NotificationsRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await notificationsRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Mark notification as unread
 *
 * Mark a notification as unread
 * Clears the readAt timestamp for the notification
 */
export const notificationsMarkUnreadMutation = (options?: Partial<Options<NotificationsMarkUnreadData>>): UseMutationOptions<NotificationsMarkUnreadResponse, DefaultError, Options<NotificationsMarkUnreadData>> => {
    const mutationOptions: UseMutationOptions<NotificationsMarkUnreadResponse, DefaultError, Options<NotificationsMarkUnreadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await notificationsMarkUnread({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const announcementsListQueryKey = (options: Options<AnnouncementsListData>) => createQueryKey('announcementsList', options);

/**
 * List active announcements
 *
 * List active announcements for the organization
 * Returns only published, non-expired announcements targeted to the user's role
 * Includes user interaction data (viewed, read, dismissed, acknowledged)
 */
export const announcementsListOptions = (options: Options<AnnouncementsListData>) => queryOptions<AnnouncementsListResponse, DefaultError, AnnouncementsListResponse, ReturnType<typeof announcementsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await announcementsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: announcementsListQueryKey(options)
});

export const announcementsListInfiniteQueryKey = (options: Options<AnnouncementsListData>): QueryKey<Options<AnnouncementsListData>> => createQueryKey('announcementsList', options, true);

/**
 * List active announcements
 *
 * List active announcements for the organization
 * Returns only published, non-expired announcements targeted to the user's role
 * Includes user interaction data (viewed, read, dismissed, acknowledged)
 */
export const announcementsListInfiniteOptions = (options: Options<AnnouncementsListData>) => infiniteQueryOptions<AnnouncementsListResponse, DefaultError, InfiniteData<AnnouncementsListResponse>, QueryKey<Options<AnnouncementsListData>>, number | Pick<QueryKey<Options<AnnouncementsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<AnnouncementsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await announcementsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: announcementsListInfiniteQueryKey(options)
});

/**
 * Create announcement
 *
 * Create a new announcement
 * Requires admin permission
 */
export const announcementsCreateMutation = (options?: Partial<Options<AnnouncementsCreateData>>): UseMutationOptions<AnnouncementsCreateResponse, DefaultError, Options<AnnouncementsCreateData>> => {
    const mutationOptions: UseMutationOptions<AnnouncementsCreateResponse, DefaultError, Options<AnnouncementsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await announcementsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const announcementsGetUnreadCountQueryKey = (options: Options<AnnouncementsGetUnreadCountData>) => createQueryKey('announcementsGetUnreadCount', options);

/**
 * Get unread announcement count
 *
 * Get unread announcement count for current user
 * Returns count of unread announcements and critical announcements needing acknowledgment
 */
export const announcementsGetUnreadCountOptions = (options: Options<AnnouncementsGetUnreadCountData>) => queryOptions<AnnouncementsGetUnreadCountResponse, DefaultError, AnnouncementsGetUnreadCountResponse, ReturnType<typeof announcementsGetUnreadCountQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await announcementsGetUnreadCount({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: announcementsGetUnreadCountQueryKey(options)
});

/**
 * Delete announcement
 *
 * Delete an announcement (soft delete)
 * Requires admin permission or ownership
 */
export const announcementsDeleteMutation = (options?: Partial<Options<AnnouncementsDeleteData>>): UseMutationOptions<AnnouncementsDeleteResponse, DefaultError, Options<AnnouncementsDeleteData>> => {
    const mutationOptions: UseMutationOptions<AnnouncementsDeleteResponse, DefaultError, Options<AnnouncementsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await announcementsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const announcementsGetQueryKey = (options: Options<AnnouncementsGetData>) => createQueryKey('announcementsGet', options);

/**
 * Get announcement by ID
 *
 * Get a specific announcement by ID
 * Includes user interaction data
 */
export const announcementsGetOptions = (options: Options<AnnouncementsGetData>) => queryOptions<AnnouncementsGetResponse, DefaultError, AnnouncementsGetResponse, ReturnType<typeof announcementsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await announcementsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: announcementsGetQueryKey(options)
});

/**
 * Update announcement
 *
 * Update an announcement
 * Requires admin permission or ownership
 */
export const announcementsUpdateMutation = (options?: Partial<Options<AnnouncementsUpdateData>>): UseMutationOptions<AnnouncementsUpdateResponse, DefaultError, Options<AnnouncementsUpdateData>> => {
    const mutationOptions: UseMutationOptions<AnnouncementsUpdateResponse, DefaultError, Options<AnnouncementsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await announcementsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Acknowledge critical announcement
 *
 * Acknowledge a critical announcement
 * Required for critical priority announcements
 */
export const announcementsAcknowledgeMutation = (options?: Partial<Options<AnnouncementsAcknowledgeData>>): UseMutationOptions<AnnouncementsAcknowledgeResponse, DefaultError, Options<AnnouncementsAcknowledgeData>> => {
    const mutationOptions: UseMutationOptions<AnnouncementsAcknowledgeResponse, DefaultError, Options<AnnouncementsAcknowledgeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await announcementsAcknowledge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Dismiss announcement
 *
 * Dismiss an announcement
 * Hides the announcement from the user's view
 */
export const announcementsDismissMutation = (options?: Partial<Options<AnnouncementsDismissData>>): UseMutationOptions<AnnouncementsDismissResponse, DefaultError, Options<AnnouncementsDismissData>> => {
    const mutationOptions: UseMutationOptions<AnnouncementsDismissResponse, DefaultError, Options<AnnouncementsDismissData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await announcementsDismiss({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Mark announcement as read
 *
 * Mark announcement as read
 * Called when user opens/expands the announcement
 */
export const announcementsMarkReadMutation = (options?: Partial<Options<AnnouncementsMarkReadData>>): UseMutationOptions<AnnouncementsMarkReadResponse, DefaultError, Options<AnnouncementsMarkReadData>> => {
    const mutationOptions: UseMutationOptions<AnnouncementsMarkReadResponse, DefaultError, Options<AnnouncementsMarkReadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await announcementsMarkRead({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const announcementsGetStatsQueryKey = (options: Options<AnnouncementsGetStatsData>) => createQueryKey('announcementsGetStats', options);

/**
 * Get announcement statistics
 *
 * Get announcement statistics
 * Returns analytics data for a specific announcement
 * Requires admin permission
 */
export const announcementsGetStatsOptions = (options: Options<AnnouncementsGetStatsData>) => queryOptions<AnnouncementsGetStatsResponse, DefaultError, AnnouncementsGetStatsResponse, ReturnType<typeof announcementsGetStatsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await announcementsGetStats({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: announcementsGetStatsQueryKey(options)
});

/**
 * Mark announcement as viewed
 *
 * Mark announcement as viewed
 * Automatically called when announcement is displayed to user
 */
export const announcementsMarkViewedMutation = (options?: Partial<Options<AnnouncementsMarkViewedData>>): UseMutationOptions<AnnouncementsMarkViewedResponse, DefaultError, Options<AnnouncementsMarkViewedData>> => {
    const mutationOptions: UseMutationOptions<AnnouncementsMarkViewedResponse, DefaultError, Options<AnnouncementsMarkViewedData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await announcementsMarkViewed({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const auditLogsListQueryKey = (options: Options<AuditLogsListData>) => createQueryKey('auditLogsList', options);

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsListOptions = (options: Options<AuditLogsListData>) => queryOptions<AuditLogsListResponse, DefaultError, AuditLogsListResponse, ReturnType<typeof auditLogsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await auditLogsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsListQueryKey(options)
});

export const auditLogsListInfiniteQueryKey = (options: Options<AuditLogsListData>): QueryKey<Options<AuditLogsListData>> => createQueryKey('auditLogsList', options, true);

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsListInfiniteOptions = (options: Options<AuditLogsListData>) => infiniteQueryOptions<AuditLogsListResponse, DefaultError, InfiniteData<AuditLogsListResponse>, QueryKey<Options<AuditLogsListData>>, number | Pick<QueryKey<Options<AuditLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<AuditLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await auditLogsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsListInfiniteQueryKey(options)
});

/**
 * Export audit logs
 *
 * Export audit logs
 *
 * Returns a download URL for audit logs in CSV or JSON format.
 * For large exports, returns 202 Accepted with a job ID.
 */
export const auditLogsExportMutation = (options?: Partial<Options<AuditLogsExportData>>): UseMutationOptions<AuditLogsExportResponse, DefaultError, Options<AuditLogsExportData>> => {
    const mutationOptions: UseMutationOptions<AuditLogsExportResponse, DefaultError, Options<AuditLogsExportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await auditLogsExport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const auditLogsGetQueryKey = (options: Options<AuditLogsGetData>) => createQueryKey('auditLogsGet', options);

/**
 * Get audit log entry
 *
 * Get a single audit log entry
 */
export const auditLogsGetOptions = (options: Options<AuditLogsGetData>) => queryOptions<AuditLogsGetResponse, DefaultError, AuditLogsGetResponse, ReturnType<typeof auditLogsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await auditLogsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsGetQueryKey(options)
});

export const examplePostsListQueryKey = (options: Options<ExamplePostsListData>) => createQueryKey('examplePostsList', options);

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsListOptions = (options: Options<ExamplePostsListData>) => queryOptions<ExamplePostsListResponse, DefaultError, ExamplePostsListResponse, ReturnType<typeof examplePostsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await examplePostsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListQueryKey(options)
});

export const examplePostsListInfiniteQueryKey = (options: Options<ExamplePostsListData>): QueryKey<Options<ExamplePostsListData>> => createQueryKey('examplePostsList', options, true);

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsListInfiniteOptions = (options: Options<ExamplePostsListData>) => infiniteQueryOptions<ExamplePostsListResponse, DefaultError, InfiniteData<ExamplePostsListResponse>, QueryKey<Options<ExamplePostsListData>>, number | Pick<QueryKey<Options<ExamplePostsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await examplePostsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListInfiniteQueryKey(options)
});

/**
 * Create example post
 *
 * Create a new post
 */
export const examplePostsCreateMutation = (options?: Partial<Options<ExamplePostsCreateData>>): UseMutationOptions<ExamplePostsCreateResponse, DefaultError, Options<ExamplePostsCreateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsCreateResponse, DefaultError, Options<ExamplePostsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch update example posts
 *
 * Batch update posts
 */
export const examplePostsBatchUpdateMutation = (options?: Partial<Options<ExamplePostsBatchUpdateData>>): UseMutationOptions<ExamplePostsBatchUpdateResponse, DefaultError, Options<ExamplePostsBatchUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchUpdateResponse, DefaultError, Options<ExamplePostsBatchUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsBatchUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch create example posts
 *
 * Batch create posts
 */
export const examplePostsBatchCreateMutation = (options?: Partial<Options<ExamplePostsBatchCreateData>>): UseMutationOptions<ExamplePostsBatchCreateResponse, DefaultError, Options<ExamplePostsBatchCreateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchCreateResponse, DefaultError, Options<ExamplePostsBatchCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsBatchCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch restore example posts
 *
 * Batch restore soft-deleted posts
 */
export const examplePostsBatchRestoreMutation = (options?: Partial<Options<ExamplePostsBatchRestoreData>>): UseMutationOptions<ExamplePostsBatchRestoreResponse, DefaultError, Options<ExamplePostsBatchRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchRestoreResponse, DefaultError, Options<ExamplePostsBatchRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsBatchRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch soft delete example posts
 *
 * Batch soft delete posts
 */
export const examplePostsBatchSoftDeleteMutation = (options?: Partial<Options<ExamplePostsBatchSoftDeleteData>>): UseMutationOptions<ExamplePostsBatchSoftDeleteResponse, DefaultError, Options<ExamplePostsBatchSoftDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchSoftDeleteResponse, DefaultError, Options<ExamplePostsBatchSoftDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsBatchSoftDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const examplePostsListCursorQueryKey = (options: Options<ExamplePostsListCursorData>) => createQueryKey('examplePostsListCursor', options);

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursorOptions = (options: Options<ExamplePostsListCursorData>) => queryOptions<ExamplePostsListCursorResponse, DefaultError, ExamplePostsListCursorResponse, ReturnType<typeof examplePostsListCursorQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await examplePostsListCursor({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListCursorQueryKey(options)
});

export const examplePostsListCursorInfiniteQueryKey = (options: Options<ExamplePostsListCursorData>): QueryKey<Options<ExamplePostsListCursorData>> => createQueryKey('examplePostsListCursor', options, true);

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursorInfiniteOptions = (options: Options<ExamplePostsListCursorData>) => infiniteQueryOptions<ExamplePostsListCursorResponse, DefaultError, InfiniteData<ExamplePostsListCursorResponse>, QueryKey<Options<ExamplePostsListCursorData>>, string | Pick<QueryKey<Options<ExamplePostsListCursorData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListCursorData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                cursor: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await examplePostsListCursor({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListCursorInfiniteQueryKey(options)
});

export const examplePostsListDeletedQueryKey = (options: Options<ExamplePostsListDeletedData>) => createQueryKey('examplePostsListDeleted', options);

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeletedOptions = (options: Options<ExamplePostsListDeletedData>) => queryOptions<ExamplePostsListDeletedResponse, DefaultError, ExamplePostsListDeletedResponse, ReturnType<typeof examplePostsListDeletedQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await examplePostsListDeleted({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListDeletedQueryKey(options)
});

export const examplePostsListDeletedInfiniteQueryKey = (options: Options<ExamplePostsListDeletedData>): QueryKey<Options<ExamplePostsListDeletedData>> => createQueryKey('examplePostsListDeleted', options, true);

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeletedInfiniteOptions = (options: Options<ExamplePostsListDeletedData>) => infiniteQueryOptions<ExamplePostsListDeletedResponse, DefaultError, InfiniteData<ExamplePostsListDeletedResponse>, QueryKey<Options<ExamplePostsListDeletedData>>, number | Pick<QueryKey<Options<ExamplePostsListDeletedData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListDeletedData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await examplePostsListDeleted({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListDeletedInfiniteQueryKey(options)
});

/**
 * Soft delete example post
 *
 * Soft delete a post (default delete behavior)
 * Post is marked as deleted but can be restored
 */
export const examplePostsDeleteMutation = (options?: Partial<Options<ExamplePostsDeleteData>>): UseMutationOptions<ExamplePostsDeleteResponse, DefaultError, Options<ExamplePostsDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsDeleteResponse, DefaultError, Options<ExamplePostsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const examplePostsGetQueryKey = (options: Options<ExamplePostsGetData>) => createQueryKey('examplePostsGet', options);

/**
 * Get example post
 *
 * Get a single post by ID
 */
export const examplePostsGetOptions = (options: Options<ExamplePostsGetData>) => queryOptions<ExamplePostsGetResponse, DefaultError, ExamplePostsGetResponse, ReturnType<typeof examplePostsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await examplePostsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsGetQueryKey(options)
});

/**
 * Update example post
 *
 * Update a post (partial update)
 */
export const examplePostsUpdateMutation = (options?: Partial<Options<ExamplePostsUpdateData>>): UseMutationOptions<ExamplePostsUpdateResponse, DefaultError, Options<ExamplePostsUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsUpdateResponse, DefaultError, Options<ExamplePostsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete example post
 *
 * Permanently delete a post (hard delete)
 * Post is permanently removed and cannot be restored
 */
export const examplePostsDeletePermanentMutation = (options?: Partial<Options<ExamplePostsDeletePermanentData>>): UseMutationOptions<ExamplePostsDeletePermanentResponse, DefaultError, Options<ExamplePostsDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsDeletePermanentResponse, DefaultError, Options<ExamplePostsDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore example post
 *
 * Restore a soft-deleted post
 */
export const examplePostsRestoreMutation = (options?: Partial<Options<ExamplePostsRestoreData>>): UseMutationOptions<ExamplePostsRestoreResponse, DefaultError, Options<ExamplePostsRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsRestoreResponse, DefaultError, Options<ExamplePostsRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exampleCommentsListQueryKey = (options: Options<ExampleCommentsListData>) => createQueryKey('exampleCommentsList', options);

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsListOptions = (options: Options<ExampleCommentsListData>) => queryOptions<ExampleCommentsListResponse, DefaultError, ExampleCommentsListResponse, ReturnType<typeof exampleCommentsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await exampleCommentsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsListQueryKey(options)
});

export const exampleCommentsListInfiniteQueryKey = (options: Options<ExampleCommentsListData>): QueryKey<Options<ExampleCommentsListData>> => createQueryKey('exampleCommentsList', options, true);

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsListInfiniteOptions = (options: Options<ExampleCommentsListData>) => infiniteQueryOptions<ExampleCommentsListResponse, DefaultError, InfiniteData<ExampleCommentsListResponse>, QueryKey<Options<ExampleCommentsListData>>, number | Pick<QueryKey<Options<ExampleCommentsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExampleCommentsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await exampleCommentsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsListInfiniteQueryKey(options)
});

/**
 * Create comment on post
 *
 * Create a new comment on a post
 */
export const exampleCommentsCreateMutation = (options?: Partial<Options<ExampleCommentsCreateData>>): UseMutationOptions<ExampleCommentsCreateResponse, DefaultError, Options<ExampleCommentsCreateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsCreateResponse, DefaultError, Options<ExampleCommentsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch create comments
 *
 * Batch create comments
 */
export const exampleCommentsBatchCreateMutation = (options?: Partial<Options<ExampleCommentsBatchCreateData>>): UseMutationOptions<ExampleCommentsBatchCreateResponse, DefaultError, Options<ExampleCommentsBatchCreateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsBatchCreateResponse, DefaultError, Options<ExampleCommentsBatchCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsBatchCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch soft delete comments
 *
 * Batch soft delete comments
 */
export const exampleCommentsBatchSoftDeleteMutation = (options?: Partial<Options<ExampleCommentsBatchSoftDeleteData>>): UseMutationOptions<ExampleCommentsBatchSoftDeleteResponse, DefaultError, Options<ExampleCommentsBatchSoftDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsBatchSoftDeleteResponse, DefaultError, Options<ExampleCommentsBatchSoftDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsBatchSoftDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Soft delete comment
 *
 * Soft delete a comment
 */
export const exampleCommentsDeleteMutation = (options?: Partial<Options<ExampleCommentsDeleteData>>): UseMutationOptions<ExampleCommentsDeleteResponse, DefaultError, Options<ExampleCommentsDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsDeleteResponse, DefaultError, Options<ExampleCommentsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exampleCommentsGetQueryKey = (options: Options<ExampleCommentsGetData>) => createQueryKey('exampleCommentsGet', options);

/**
 * Get comment
 *
 * Get a single comment by ID
 */
export const exampleCommentsGetOptions = (options: Options<ExampleCommentsGetData>) => queryOptions<ExampleCommentsGetResponse, DefaultError, ExampleCommentsGetResponse, ReturnType<typeof exampleCommentsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await exampleCommentsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsGetQueryKey(options)
});

/**
 * Update comment
 *
 * Update a comment (partial update)
 */
export const exampleCommentsUpdateMutation = (options?: Partial<Options<ExampleCommentsUpdateData>>): UseMutationOptions<ExampleCommentsUpdateResponse, DefaultError, Options<ExampleCommentsUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsUpdateResponse, DefaultError, Options<ExampleCommentsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete comment
 *
 * Permanently delete a comment (hard delete)
 */
export const exampleCommentsDeletePermanentMutation = (options?: Partial<Options<ExampleCommentsDeletePermanentData>>): UseMutationOptions<ExampleCommentsDeletePermanentResponse, DefaultError, Options<ExampleCommentsDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsDeletePermanentResponse, DefaultError, Options<ExampleCommentsDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore comment
 *
 * Restore a soft-deleted comment
 */
export const exampleCommentsRestoreMutation = (options?: Partial<Options<ExampleCommentsRestoreData>>): UseMutationOptions<ExampleCommentsRestoreResponse, DefaultError, Options<ExampleCommentsRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsRestoreResponse, DefaultError, Options<ExampleCommentsRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesListQueryKey = (options: Options<FilesListData>) => createQueryKey('filesList', options);

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesListOptions = (options: Options<FilesListData>) => queryOptions<FilesListResponse, DefaultError, FilesListResponse, ReturnType<typeof filesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesListQueryKey(options)
});

export const filesListInfiniteQueryKey = (options: Options<FilesListData>): QueryKey<Options<FilesListData>> => createQueryKey('filesList', options, true);

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesListInfiniteOptions = (options: Options<FilesListData>) => infiniteQueryOptions<FilesListResponse, DefaultError, InfiniteData<FilesListResponse>, QueryKey<Options<FilesListData>>, number | Pick<QueryKey<Options<FilesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<FilesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await filesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesListInfiniteQueryKey(options)
});

/**
 * Direct file upload
 *
 * Direct file upload (multipart/form-data)
 *
 * For simple uploads of small files (< 10 MB).
 * File is uploaded directly to the API server.
 *
 * Note: For larger files or high volume, use presigned URL upload.
 */
export const filesDirectUploadMutation = (options?: Partial<Options<FilesDirectUploadData>>): UseMutationOptions<FilesDirectUploadResponse, DefaultError, Options<FilesDirectUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesDirectUploadResponse, DefaultError, Options<FilesDirectUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDirectUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Initiate presigned URL upload
 *
 * Initiate a presigned URL upload
 *
 * Returns a presigned URL for direct upload to storage (S3/R2/GCS).
 * Client uploads directly to storage, then confirms with the API.
 *
 * Flow:
 * 1. POST /files/uploads - Get presigned URL
 * 2. PUT {presignedUrl} - Upload directly to storage
 * 3. POST /files/uploads/{uploadId}/confirm - Confirm upload
 */
export const filesInitiateUploadMutation = (options?: Partial<Options<FilesInitiateUploadData>>): UseMutationOptions<FilesInitiateUploadResponse, DefaultError, Options<FilesInitiateUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesInitiateUploadResponse, DefaultError, Options<FilesInitiateUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesInitiateUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Confirm presigned URL upload
 *
 * Confirm a presigned URL upload
 *
 * Called after client successfully uploads to the presigned URL.
 * Triggers virus scanning and creates the file record.
 */
export const filesConfirmUploadMutation = (options?: Partial<Options<FilesConfirmUploadData>>): UseMutationOptions<FilesConfirmUploadResponse, DefaultError, Options<FilesConfirmUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesConfirmUploadResponse, DefaultError, Options<FilesConfirmUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesConfirmUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete file
 *
 * Delete a file (soft delete)
 *
 * File is marked as deleted but retained for audit purposes.
 * Storage is cleaned up after retention period.
 */
export const filesDeleteMutation = (options?: Partial<Options<FilesDeleteData>>): UseMutationOptions<FilesDeleteResponse, DefaultError, Options<FilesDeleteData>> => {
    const mutationOptions: UseMutationOptions<FilesDeleteResponse, DefaultError, Options<FilesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesGetQueryKey = (options: Options<FilesGetData>) => createQueryKey('filesGet', options);

/**
 * Get file
 *
 * Get a single file by ID
 *
 * Returns file metadata including a fresh signed URL for download.
 */
export const filesGetOptions = (options: Options<FilesGetData>) => queryOptions<FilesGetResponse, DefaultError, FilesGetResponse, ReturnType<typeof filesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesGetQueryKey(options)
});

/**
 * Update file
 *
 * Update file properties
 *
 * Currently supports changing the access level (private/public).
 */
export const filesUpdateMutation = (options?: Partial<Options<FilesUpdateData>>): UseMutationOptions<FilesUpdateResponse, DefaultError, Options<FilesUpdateData>> => {
    const mutationOptions: UseMutationOptions<FilesUpdateResponse, DefaultError, Options<FilesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesDownloadQueryKey = (options: Options<FilesDownloadData>) => createQueryKey('filesDownload', options);

/**
 * Download file
 *
 * Download a file
 *
 * Returns a redirect to a signed URL for the file.
 * The signed URL expires in 5 minutes.
 */
export const filesDownloadOptions = (options: Options<FilesDownloadData>) => queryOptions<FilesDownloadResponse, DefaultError, FilesDownloadResponse, ReturnType<typeof filesDownloadQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesDownload({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesDownloadQueryKey(options)
});

/**
 * Permanently delete file
 *
 * Permanently delete a file (hard delete)
 *
 * Immediately removes file from storage.
 * Use with caution - cannot be undone.
 */
export const filesDeletePermanentMutation = (options?: Partial<Options<FilesDeletePermanentData>>): UseMutationOptions<FilesDeletePermanentResponse, DefaultError, Options<FilesDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<FilesDeletePermanentResponse, DefaultError, Options<FilesDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const jobsListQueryKey = (options: Options<JobsListData>) => createQueryKey('jobsList', options);

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant with optional filtering.
 */
export const jobsListOptions = (options: Options<JobsListData>) => queryOptions<JobsListResponse, DefaultError, JobsListResponse, ReturnType<typeof jobsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await jobsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsListQueryKey(options)
});

export const jobsListInfiniteQueryKey = (options: Options<JobsListData>): QueryKey<Options<JobsListData>> => createQueryKey('jobsList', options, true);

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant with optional filtering.
 */
export const jobsListInfiniteOptions = (options: Options<JobsListData>) => infiniteQueryOptions<JobsListResponse, DefaultError, InfiniteData<JobsListResponse>, QueryKey<Options<JobsListData>>, number | Pick<QueryKey<Options<JobsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<JobsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await jobsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsListInfiniteQueryKey(options)
});

export const jobsGetQueryKey = (options: Options<JobsGetData>) => createQueryKey('jobsGet', options);

/**
 * Get job status
 *
 * Get job status
 *
 * Poll this endpoint to check progress of async operations.
 */
export const jobsGetOptions = (options: Options<JobsGetData>) => queryOptions<JobsGetResponse, DefaultError, JobsGetResponse, ReturnType<typeof jobsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await jobsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsGetQueryKey(options)
});

/**
 * Cancel job
 *
 * Cancel a job
 *
 * Only pending or processing jobs can be cancelled.
 */
export const jobsCancelMutation = (options?: Partial<Options<JobsCancelData>>): UseMutationOptions<JobsCancelResponse, DefaultError, Options<JobsCancelData>> => {
    const mutationOptions: UseMutationOptions<JobsCancelResponse, DefaultError, Options<JobsCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await jobsCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const jobsDownloadQueryKey = (options: Options<JobsDownloadData>) => createQueryKey('jobsDownload', options);

/**
 * Download job result
 *
 * Download job result
 *
 * Downloads the file generated by a completed job (e.g., report exports).
 * Only available for jobs that produce downloadable files.
 */
export const jobsDownloadOptions = (options: Options<JobsDownloadData>) => queryOptions<JobsDownloadResponse, DefaultError, JobsDownloadResponse, ReturnType<typeof jobsDownloadQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await jobsDownload({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsDownloadQueryKey(options)
});

/**
 * Retry job
 *
 * Retry a failed job
 *
 * Creates a new job with the same parameters as the failed job.
 */
export const jobsRetryMutation = (options?: Partial<Options<JobsRetryData>>): UseMutationOptions<JobsRetryResponse, DefaultError, Options<JobsRetryData>> => {
    const mutationOptions: UseMutationOptions<JobsRetryResponse, DefaultError, Options<JobsRetryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await jobsRetry({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Export data
 *
 * Export data synchronously
 *
 * For small datasets (<10,000 rows). Returns the file directly.
 * For larger datasets, use async=true to get a job ID.
 */
export const reportExportsExportMutation = (options?: Partial<Options<ReportExportsExportData>>): UseMutationOptions<ReportExportsExportResponse, DefaultError, Options<ReportExportsExportData>> => {
    const mutationOptions: UseMutationOptions<ReportExportsExportResponse, DefaultError, Options<ReportExportsExportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reportExportsExport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Preview export
 *
 * Preview export (first N rows)
 *
 * Useful for testing templates and verifying data before full export.
 */
export const reportExportsPreviewExportMutation = (options?: Partial<Options<ReportExportsPreviewExportData>>): UseMutationOptions<ReportExportsPreviewExportResponse, DefaultError, Options<ReportExportsPreviewExportData>> => {
    const mutationOptions: UseMutationOptions<ReportExportsPreviewExportResponse, DefaultError, Options<ReportExportsPreviewExportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reportExportsPreviewExport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Stream export data
 *
 * Export data as streaming response
 *
 * For large datasets. Streams data in chunks as it's generated.
 * Only supports CSV and Excel formats.
 */
export const reportExportsStreamExportMutation = (options?: Partial<Options<ReportExportsStreamExportData>>): UseMutationOptions<ReportExportsStreamExportResponse, DefaultError, Options<ReportExportsStreamExportData>> => {
    const mutationOptions: UseMutationOptions<ReportExportsStreamExportResponse, DefaultError, Options<ReportExportsStreamExportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reportExportsStreamExport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const scheduledReportsListQueryKey = (options: Options<ScheduledReportsListData>) => createQueryKey('scheduledReportsList', options);

/**
 * List scheduled reports
 *
 * List scheduled reports in an organization
 */
export const scheduledReportsListOptions = (options: Options<ScheduledReportsListData>) => queryOptions<ScheduledReportsListResponse, DefaultError, ScheduledReportsListResponse, ReturnType<typeof scheduledReportsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await scheduledReportsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: scheduledReportsListQueryKey(options)
});

export const scheduledReportsListInfiniteQueryKey = (options: Options<ScheduledReportsListData>): QueryKey<Options<ScheduledReportsListData>> => createQueryKey('scheduledReportsList', options, true);

/**
 * List scheduled reports
 *
 * List scheduled reports in an organization
 */
export const scheduledReportsListInfiniteOptions = (options: Options<ScheduledReportsListData>) => infiniteQueryOptions<ScheduledReportsListResponse, DefaultError, InfiniteData<ScheduledReportsListResponse>, QueryKey<Options<ScheduledReportsListData>>, number | Pick<QueryKey<Options<ScheduledReportsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ScheduledReportsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await scheduledReportsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: scheduledReportsListInfiniteQueryKey(options)
});

/**
 * Create scheduled report
 *
 * Create a new scheduled report
 */
export const scheduledReportsCreateMutation = (options?: Partial<Options<ScheduledReportsCreateData>>): UseMutationOptions<ScheduledReportsCreateResponse, DefaultError, Options<ScheduledReportsCreateData>> => {
    const mutationOptions: UseMutationOptions<ScheduledReportsCreateResponse, DefaultError, Options<ScheduledReportsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await scheduledReportsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete scheduled report
 *
 * Delete a scheduled report
 */
export const scheduledReportsDeleteMutation = (options?: Partial<Options<ScheduledReportsDeleteData>>): UseMutationOptions<ScheduledReportsDeleteResponse, DefaultError, Options<ScheduledReportsDeleteData>> => {
    const mutationOptions: UseMutationOptions<ScheduledReportsDeleteResponse, DefaultError, Options<ScheduledReportsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await scheduledReportsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const scheduledReportsGetQueryKey = (options: Options<ScheduledReportsGetData>) => createQueryKey('scheduledReportsGet', options);

/**
 * Get scheduled report
 *
 * Get a scheduled report by ID
 */
export const scheduledReportsGetOptions = (options: Options<ScheduledReportsGetData>) => queryOptions<ScheduledReportsGetResponse, DefaultError, ScheduledReportsGetResponse, ReturnType<typeof scheduledReportsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await scheduledReportsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: scheduledReportsGetQueryKey(options)
});

/**
 * Update scheduled report
 *
 * Update a scheduled report
 */
export const scheduledReportsUpdateMutation = (options?: Partial<Options<ScheduledReportsUpdateData>>): UseMutationOptions<ScheduledReportsUpdateResponse, DefaultError, Options<ScheduledReportsUpdateData>> => {
    const mutationOptions: UseMutationOptions<ScheduledReportsUpdateResponse, DefaultError, Options<ScheduledReportsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await scheduledReportsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const scheduledReportsGetHistoryQueryKey = (options: Options<ScheduledReportsGetHistoryData>) => createQueryKey('scheduledReportsGetHistory', options);

/**
 * Get schedule run history
 *
 * Get run history for a scheduled report
 */
export const scheduledReportsGetHistoryOptions = (options: Options<ScheduledReportsGetHistoryData>) => queryOptions<ScheduledReportsGetHistoryResponse, DefaultError, ScheduledReportsGetHistoryResponse, ReturnType<typeof scheduledReportsGetHistoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await scheduledReportsGetHistory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: scheduledReportsGetHistoryQueryKey(options)
});

export const scheduledReportsGetHistoryInfiniteQueryKey = (options: Options<ScheduledReportsGetHistoryData>): QueryKey<Options<ScheduledReportsGetHistoryData>> => createQueryKey('scheduledReportsGetHistory', options, true);

/**
 * Get schedule run history
 *
 * Get run history for a scheduled report
 */
export const scheduledReportsGetHistoryInfiniteOptions = (options: Options<ScheduledReportsGetHistoryData>) => infiniteQueryOptions<ScheduledReportsGetHistoryResponse, DefaultError, InfiniteData<ScheduledReportsGetHistoryResponse>, QueryKey<Options<ScheduledReportsGetHistoryData>>, number | Pick<QueryKey<Options<ScheduledReportsGetHistoryData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ScheduledReportsGetHistoryData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await scheduledReportsGetHistory({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: scheduledReportsGetHistoryInfiniteQueryKey(options)
});

/**
 * Pause scheduled report
 *
 * Pause a scheduled report
 */
export const scheduledReportsPauseMutation = (options?: Partial<Options<ScheduledReportsPauseData>>): UseMutationOptions<ScheduledReportsPauseResponse, DefaultError, Options<ScheduledReportsPauseData>> => {
    const mutationOptions: UseMutationOptions<ScheduledReportsPauseResponse, DefaultError, Options<ScheduledReportsPauseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await scheduledReportsPause({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resume scheduled report
 *
 * Resume a paused scheduled report
 */
export const scheduledReportsResumeMutation = (options?: Partial<Options<ScheduledReportsResumeData>>): UseMutationOptions<ScheduledReportsResumeResponse, DefaultError, Options<ScheduledReportsResumeData>> => {
    const mutationOptions: UseMutationOptions<ScheduledReportsResumeResponse, DefaultError, Options<ScheduledReportsResumeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await scheduledReportsResume({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Run scheduled report now
 *
 * Trigger a scheduled report to run immediately
 */
export const scheduledReportsRunNowMutation = (options?: Partial<Options<ScheduledReportsRunNowData>>): UseMutationOptions<ScheduledReportsRunNowResponse, DefaultError, Options<ScheduledReportsRunNowData>> => {
    const mutationOptions: UseMutationOptions<ScheduledReportsRunNowResponse, DefaultError, Options<ScheduledReportsRunNowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await scheduledReportsRunNow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const reportTemplatesListQueryKey = (options: Options<ReportTemplatesListData>) => createQueryKey('reportTemplatesList', options);

/**
 * List report templates
 *
 * List report templates in an organization
 */
export const reportTemplatesListOptions = (options: Options<ReportTemplatesListData>) => queryOptions<ReportTemplatesListResponse, DefaultError, ReportTemplatesListResponse, ReturnType<typeof reportTemplatesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await reportTemplatesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: reportTemplatesListQueryKey(options)
});

export const reportTemplatesListInfiniteQueryKey = (options: Options<ReportTemplatesListData>): QueryKey<Options<ReportTemplatesListData>> => createQueryKey('reportTemplatesList', options, true);

/**
 * List report templates
 *
 * List report templates in an organization
 */
export const reportTemplatesListInfiniteOptions = (options: Options<ReportTemplatesListData>) => infiniteQueryOptions<ReportTemplatesListResponse, DefaultError, InfiniteData<ReportTemplatesListResponse>, QueryKey<Options<ReportTemplatesListData>>, number | Pick<QueryKey<Options<ReportTemplatesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ReportTemplatesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await reportTemplatesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: reportTemplatesListInfiniteQueryKey(options)
});

/**
 * Create report template
 *
 * Create a new report template
 */
export const reportTemplatesCreateMutation = (options?: Partial<Options<ReportTemplatesCreateData>>): UseMutationOptions<ReportTemplatesCreateResponse, DefaultError, Options<ReportTemplatesCreateData>> => {
    const mutationOptions: UseMutationOptions<ReportTemplatesCreateResponse, DefaultError, Options<ReportTemplatesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reportTemplatesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete report template
 *
 * Delete a report template
 */
export const reportTemplatesDeleteMutation = (options?: Partial<Options<ReportTemplatesDeleteData>>): UseMutationOptions<ReportTemplatesDeleteResponse, DefaultError, Options<ReportTemplatesDeleteData>> => {
    const mutationOptions: UseMutationOptions<ReportTemplatesDeleteResponse, DefaultError, Options<ReportTemplatesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reportTemplatesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const reportTemplatesGetQueryKey = (options: Options<ReportTemplatesGetData>) => createQueryKey('reportTemplatesGet', options);

/**
 * Get report template
 *
 * Get a report template by ID
 */
export const reportTemplatesGetOptions = (options: Options<ReportTemplatesGetData>) => queryOptions<ReportTemplatesGetResponse, DefaultError, ReportTemplatesGetResponse, ReturnType<typeof reportTemplatesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await reportTemplatesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: reportTemplatesGetQueryKey(options)
});

/**
 * Update report template
 *
 * Update a report template
 */
export const reportTemplatesUpdateMutation = (options?: Partial<Options<ReportTemplatesUpdateData>>): UseMutationOptions<ReportTemplatesUpdateResponse, DefaultError, Options<ReportTemplatesUpdateData>> => {
    const mutationOptions: UseMutationOptions<ReportTemplatesUpdateResponse, DefaultError, Options<ReportTemplatesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reportTemplatesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Clone report template
 *
 * Clone a report template
 */
export const reportTemplatesCloneMutation = (options?: Partial<Options<ReportTemplatesCloneData>>): UseMutationOptions<ReportTemplatesCloneResponse, DefaultError, Options<ReportTemplatesCloneData>> => {
    const mutationOptions: UseMutationOptions<ReportTemplatesCloneResponse, DefaultError, Options<ReportTemplatesCloneData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reportTemplatesClone({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test report template
 *
 * Test a report template with sample data
 */
export const reportTemplatesTestMutation = (options?: Partial<Options<ReportTemplatesTestData>>): UseMutationOptions<ReportTemplatesTestResponse, DefaultError, Options<ReportTemplatesTestData>> => {
    const mutationOptions: UseMutationOptions<ReportTemplatesTestResponse, DefaultError, Options<ReportTemplatesTestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reportTemplatesTest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tenantRolesListQueryKey = (options: Options<TenantRolesListData>) => createQueryKey('tenantRolesList', options);

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesListOptions = (options: Options<TenantRolesListData>) => queryOptions<TenantRolesListResponse, DefaultError, TenantRolesListResponse, ReturnType<typeof tenantRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await tenantRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesListQueryKey(options)
});

export const tenantRolesListInfiniteQueryKey = (options: Options<TenantRolesListData>): QueryKey<Options<TenantRolesListData>> => createQueryKey('tenantRolesList', options, true);

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesListInfiniteOptions = (options: Options<TenantRolesListData>) => infiniteQueryOptions<TenantRolesListResponse, DefaultError, InfiniteData<TenantRolesListResponse>, QueryKey<Options<TenantRolesListData>>, number | Pick<QueryKey<Options<TenantRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<TenantRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await tenantRolesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesListInfiniteQueryKey(options)
});

/**
 * Create tenant role
 *
 * Create a tenant-scoped role
 *
 * Creates a custom role for this specific tenant.
 */
export const tenantRolesCreateMutation = (options?: Partial<Options<TenantRolesCreateData>>): UseMutationOptions<TenantRolesCreateResponse, DefaultError, Options<TenantRolesCreateData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesCreateResponse, DefaultError, Options<TenantRolesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await tenantRolesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const tenantRolesDeleteMutation = (options?: Partial<Options<TenantRolesDeleteData>>): UseMutationOptions<TenantRolesDeleteResponse, DefaultError, Options<TenantRolesDeleteData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesDeleteResponse, DefaultError, Options<TenantRolesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await tenantRolesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tenantRolesGetQueryKey = (options: Options<TenantRolesGetData>) => createQueryKey('tenantRolesGet', options);

/**
 * Get role
 *
 * Get a role by ID
 */
export const tenantRolesGetOptions = (options: Options<TenantRolesGetData>) => queryOptions<TenantRolesGetResponse, DefaultError, TenantRolesGetResponse, ReturnType<typeof tenantRolesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await tenantRolesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesGetQueryKey(options)
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const tenantRolesUpdateMutation = (options?: Partial<Options<TenantRolesUpdateData>>): UseMutationOptions<TenantRolesUpdateResponse, DefaultError, Options<TenantRolesUpdateData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesUpdateResponse, DefaultError, Options<TenantRolesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await tenantRolesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create subscription
 *
 * Create subscription
 *
 * Creates a new subscription for the organization.
 * Starts trial if configured, otherwise requires payment.
 */
export const subscriptionsCreateMutation = (options?: Partial<Options<SubscriptionsCreateData>>): UseMutationOptions<SubscriptionsCreateResponse, DefaultError, Options<SubscriptionsCreateData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionsCreateResponse, DefaultError, Options<SubscriptionsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const subscriptionsGetCurrentQueryKey = (options: Options<SubscriptionsGetCurrentData>) => createQueryKey('subscriptionsGetCurrent', options);

/**
 * Get current subscription
 *
 * Get current subscription
 *
 * Returns the active subscription for the organization and application.
 */
export const subscriptionsGetCurrentOptions = (options: Options<SubscriptionsGetCurrentData>) => queryOptions<SubscriptionsGetCurrentResponse, DefaultError, SubscriptionsGetCurrentResponse, ReturnType<typeof subscriptionsGetCurrentQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await subscriptionsGetCurrent({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: subscriptionsGetCurrentQueryKey(options)
});

/**
 * Validate coupon
 *
 * Validate coupon
 *
 * Check if a coupon code is valid for a plan.
 * Does not apply the coupon.
 */
export const subscriptionsValidateCouponMutation = (options?: Partial<Options<SubscriptionsValidateCouponData>>): UseMutationOptions<SubscriptionsValidateCouponResponse, DefaultError, Options<SubscriptionsValidateCouponData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionsValidateCouponResponse, DefaultError, Options<SubscriptionsValidateCouponData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionsValidateCoupon({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update subscription
 *
 * Update subscription
 *
 * Update subscription (change plan, update settings).
 * Plan changes may be immediate or scheduled for period end.
 */
export const subscriptionsUpdateMutation = (options?: Partial<Options<SubscriptionsUpdateData>>): UseMutationOptions<SubscriptionsUpdateResponse, DefaultError, Options<SubscriptionsUpdateData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionsUpdateResponse, DefaultError, Options<SubscriptionsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cancel subscription
 *
 * Cancel subscription
 *
 * Cancel the subscription.
 * By default, access continues until period end.
 */
export const subscriptionsCancelMutation = (options?: Partial<Options<SubscriptionsCancelData>>): UseMutationOptions<SubscriptionsCancelResponse, DefaultError, Options<SubscriptionsCancelData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionsCancelResponse, DefaultError, Options<SubscriptionsCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionsCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Apply coupon
 *
 * Apply coupon
 *
 * Apply a discount coupon to the subscription.
 */
export const subscriptionsApplyCouponMutation = (options?: Partial<Options<SubscriptionsApplyCouponData>>): UseMutationOptions<SubscriptionsApplyCouponResponse, DefaultError, Options<SubscriptionsApplyCouponData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionsApplyCouponResponse, DefaultError, Options<SubscriptionsApplyCouponData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionsApplyCoupon({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resume subscription
 *
 * Resume subscription
 *
 * Reactivate a canceled subscription before it expires.
 */
export const subscriptionsResumeMutation = (options?: Partial<Options<SubscriptionsResumeData>>): UseMutationOptions<SubscriptionsResumeResponse, DefaultError, Options<SubscriptionsResumeData>> => {
    const mutationOptions: UseMutationOptions<SubscriptionsResumeResponse, DefaultError, Options<SubscriptionsResumeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await subscriptionsResume({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const userPermissionsGetQueryKey = (options: Options<UserPermissionsGetData>) => createQueryKey('userPermissionsGet', options);

/**
 * Get user effective permissions
 *
 * Get user's effective permissions in this tenant
 *
 * Returns all roles (global + tenant) and the combined effective permissions
 * after applying deny-override resolution.
 */
export const userPermissionsGetOptions = (options: Options<UserPermissionsGetData>) => queryOptions<UserPermissionsGetResponse, DefaultError, UserPermissionsGetResponse, ReturnType<typeof userPermissionsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await userPermissionsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: userPermissionsGetQueryKey(options)
});

export const userTenantRolesListQueryKey = (options: Options<UserTenantRolesListData>) => createQueryKey('userTenantRolesList', options);

/**
 * List user roles in tenant
 *
 * List roles assigned to a user in this tenant
 *
 * Returns both global and tenant-specific role assignments.
 */
export const userTenantRolesListOptions = (options: Options<UserTenantRolesListData>) => queryOptions<UserTenantRolesListResponse, DefaultError, UserTenantRolesListResponse, ReturnType<typeof userTenantRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await userTenantRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: userTenantRolesListQueryKey(options)
});

/**
 * Assign role to user
 *
 * Assign a role to a user in this tenant
 */
export const userTenantRolesAssignMutation = (options?: Partial<Options<UserTenantRolesAssignData>>): UseMutationOptions<UserTenantRolesAssignResponse, DefaultError, Options<UserTenantRolesAssignData>> => {
    const mutationOptions: UseMutationOptions<UserTenantRolesAssignResponse, DefaultError, Options<UserTenantRolesAssignData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await userTenantRolesAssign({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove role from user
 *
 * Remove a role from a user
 */
export const userTenantRolesRemoveMutation = (options?: Partial<Options<UserTenantRolesRemoveData>>): UseMutationOptions<UserTenantRolesRemoveResponse, DefaultError, Options<UserTenantRolesRemoveData>> => {
    const mutationOptions: UseMutationOptions<UserTenantRolesRemoveResponse, DefaultError, Options<UserTenantRolesRemoveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await userTenantRolesRemove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListQueryKey = (options: Options<WebhooksListData>) => createQueryKey('webhooksList', options);

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksListOptions = (options: Options<WebhooksListData>) => queryOptions<WebhooksListResponse, DefaultError, WebhooksListResponse, ReturnType<typeof webhooksListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListQueryKey(options)
});

export const webhooksListInfiniteQueryKey = (options: Options<WebhooksListData>): QueryKey<Options<WebhooksListData>> => createQueryKey('webhooksList', options, true);

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksListInfiniteOptions = (options: Options<WebhooksListData>) => infiniteQueryOptions<WebhooksListResponse, DefaultError, InfiniteData<WebhooksListResponse>, QueryKey<Options<WebhooksListData>>, number | Pick<QueryKey<Options<WebhooksListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<WebhooksListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await webhooksList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListInfiniteQueryKey(options)
});

/**
 * Create webhook
 *
 * Create a new webhook
 *
 * The secret is only returned once in the response.
 * Store it securely for signature verification.
 */
export const webhooksCreateMutation = (options?: Partial<Options<WebhooksCreateData>>): UseMutationOptions<WebhooksCreateResponse, DefaultError, Options<WebhooksCreateData>> => {
    const mutationOptions: UseMutationOptions<WebhooksCreateResponse, DefaultError, Options<WebhooksCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListEventTypesQueryKey = (options: Options<WebhooksListEventTypesData>) => createQueryKey('webhooksListEventTypes', options);

/**
 * List event types
 *
 * Get available event types
 *
 * Returns all event types that can be subscribed to.
 */
export const webhooksListEventTypesOptions = (options: Options<WebhooksListEventTypesData>) => queryOptions<WebhooksListEventTypesResponse, DefaultError, WebhooksListEventTypesResponse, ReturnType<typeof webhooksListEventTypesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksListEventTypes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListEventTypesQueryKey(options)
});

/**
 * Delete webhook
 *
 * Delete a webhook
 */
export const webhooksDeleteMutation = (options?: Partial<Options<WebhooksDeleteData>>): UseMutationOptions<WebhooksDeleteResponse, DefaultError, Options<WebhooksDeleteData>> => {
    const mutationOptions: UseMutationOptions<WebhooksDeleteResponse, DefaultError, Options<WebhooksDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksGetQueryKey = (options: Options<WebhooksGetData>) => createQueryKey('webhooksGet', options);

/**
 * Get webhook
 *
 * Get a webhook by ID
 */
export const webhooksGetOptions = (options: Options<WebhooksGetData>) => queryOptions<WebhooksGetResponse, DefaultError, WebhooksGetResponse, ReturnType<typeof webhooksGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksGetQueryKey(options)
});

/**
 * Update webhook
 *
 * Update a webhook
 */
export const webhooksUpdateMutation = (options?: Partial<Options<WebhooksUpdateData>>): UseMutationOptions<WebhooksUpdateResponse, DefaultError, Options<WebhooksUpdateData>> => {
    const mutationOptions: UseMutationOptions<WebhooksUpdateResponse, DefaultError, Options<WebhooksUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListDeliveriesQueryKey = (options: Options<WebhooksListDeliveriesData>) => createQueryKey('webhooksListDeliveries', options);

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveriesOptions = (options: Options<WebhooksListDeliveriesData>) => queryOptions<WebhooksListDeliveriesResponse, DefaultError, WebhooksListDeliveriesResponse, ReturnType<typeof webhooksListDeliveriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksListDeliveries({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListDeliveriesQueryKey(options)
});

export const webhooksListDeliveriesInfiniteQueryKey = (options: Options<WebhooksListDeliveriesData>): QueryKey<Options<WebhooksListDeliveriesData>> => createQueryKey('webhooksListDeliveries', options, true);

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveriesInfiniteOptions = (options: Options<WebhooksListDeliveriesData>) => infiniteQueryOptions<WebhooksListDeliveriesResponse, DefaultError, InfiniteData<WebhooksListDeliveriesResponse>, QueryKey<Options<WebhooksListDeliveriesData>>, number | Pick<QueryKey<Options<WebhooksListDeliveriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<WebhooksListDeliveriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await webhooksListDeliveries({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListDeliveriesInfiniteQueryKey(options)
});

export const webhooksGetDeliveryQueryKey = (options: Options<WebhooksGetDeliveryData>) => createQueryKey('webhooksGetDelivery', options);

/**
 * Get webhook delivery
 *
 * Get a specific delivery
 */
export const webhooksGetDeliveryOptions = (options: Options<WebhooksGetDeliveryData>) => queryOptions<WebhooksGetDeliveryResponse, DefaultError, WebhooksGetDeliveryResponse, ReturnType<typeof webhooksGetDeliveryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksGetDelivery({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksGetDeliveryQueryKey(options)
});

/**
 * Retry delivery
 *
 * Retry a failed delivery
 *
 * Manually triggers a retry for a failed delivery.
 */
export const webhooksRetryDeliveryMutation = (options?: Partial<Options<WebhooksRetryDeliveryData>>): UseMutationOptions<WebhooksRetryDeliveryResponse, DefaultError, Options<WebhooksRetryDeliveryData>> => {
    const mutationOptions: UseMutationOptions<WebhooksRetryDeliveryResponse, DefaultError, Options<WebhooksRetryDeliveryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksRetryDelivery({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rotate webhook secret
 *
 * Rotate webhook secret
 *
 * Generates a new secret. The old secret immediately stops working.
 */
export const webhooksRotateSecretMutation = (options?: Partial<Options<WebhooksRotateSecretData>>): UseMutationOptions<WebhooksRotateSecretResponse, DefaultError, Options<WebhooksRotateSecretData>> => {
    const mutationOptions: UseMutationOptions<WebhooksRotateSecretResponse, DefaultError, Options<WebhooksRotateSecretData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksRotateSecret({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test webhook
 *
 * Test a webhook
 *
 * Sends a test event to verify the webhook is configured correctly.
 */
export const webhooksTestMutation = (options?: Partial<Options<WebhooksTestData>>): UseMutationOptions<WebhooksTestResponse, DefaultError, Options<WebhooksTestData>> => {
    const mutationOptions: UseMutationOptions<WebhooksTestResponse, DefaultError, Options<WebhooksTestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksTest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const notificationPreferencesRoutesGetPreferencesQueryKey = (options?: Options<NotificationPreferencesRoutesGetPreferencesData>) => createQueryKey('notificationPreferencesRoutesGetPreferences', options);

/**
 * Get notification preferences
 *
 * Get notification preferences for the current user
 * Returns default values if no preferences are set
 */
export const notificationPreferencesRoutesGetPreferencesOptions = (options?: Options<NotificationPreferencesRoutesGetPreferencesData>) => queryOptions<NotificationPreferencesRoutesGetPreferencesResponse, DefaultError, NotificationPreferencesRoutesGetPreferencesResponse, ReturnType<typeof notificationPreferencesRoutesGetPreferencesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await notificationPreferencesRoutesGetPreferences({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationPreferencesRoutesGetPreferencesQueryKey(options)
});

/**
 * Update notification preferences
 *
 * Update notification preferences for the current user
 * Supports partial updates - only provided fields will be updated
 */
export const notificationPreferencesRoutesUpdatePreferencesMutation = (options?: Partial<Options<NotificationPreferencesRoutesUpdatePreferencesData>>): UseMutationOptions<NotificationPreferencesRoutesUpdatePreferencesResponse, DefaultError, Options<NotificationPreferencesRoutesUpdatePreferencesData>> => {
    const mutationOptions: UseMutationOptions<NotificationPreferencesRoutesUpdatePreferencesResponse, DefaultError, Options<NotificationPreferencesRoutesUpdatePreferencesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await notificationPreferencesRoutesUpdatePreferences({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const publicPricingListPublicPlansQueryKey = (options?: Options<PublicPricingListPublicPlansData>) => createQueryKey('publicPricingListPublicPlans', options);

/**
 * List public subscription plans
 *
 * List public plans
 *
 * Returns all public, active subscription plans.
 * Used for the public pricing page.
 */
export const publicPricingListPublicPlansOptions = (options?: Options<PublicPricingListPublicPlansData>) => queryOptions<PublicPricingListPublicPlansResponse, DefaultError, PublicPricingListPublicPlansResponse, ReturnType<typeof publicPricingListPublicPlansQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await publicPricingListPublicPlans({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: publicPricingListPublicPlansQueryKey(options)
});

export const globalRolesListQueryKey = (options?: Options<GlobalRolesListData>) => createQueryKey('globalRolesList', options);

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesListOptions = (options?: Options<GlobalRolesListData>) => queryOptions<GlobalRolesListResponse, DefaultError, GlobalRolesListResponse, ReturnType<typeof globalRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await globalRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesListQueryKey(options)
});

export const globalRolesListInfiniteQueryKey = (options?: Options<GlobalRolesListData>): QueryKey<Options<GlobalRolesListData>> => createQueryKey('globalRolesList', options, true);

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesListInfiniteOptions = (options?: Options<GlobalRolesListData>) => infiniteQueryOptions<GlobalRolesListResponse, DefaultError, InfiniteData<GlobalRolesListResponse>, QueryKey<Options<GlobalRolesListData>>, number | Pick<QueryKey<Options<GlobalRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GlobalRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await globalRolesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesListInfiniteQueryKey(options)
});

/**
 * Create global role
 *
 * Create a global role
 *
 * Creates a role that applies across all tenants.
 */
export const globalRolesCreateMutation = (options?: Partial<Options<GlobalRolesCreateData>>): UseMutationOptions<GlobalRolesCreateResponse, DefaultError, Options<GlobalRolesCreateData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesCreateResponse, DefaultError, Options<GlobalRolesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await globalRolesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const globalRolesDeleteMutation = (options?: Partial<Options<GlobalRolesDeleteData>>): UseMutationOptions<GlobalRolesDeleteResponse, DefaultError, Options<GlobalRolesDeleteData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesDeleteResponse, DefaultError, Options<GlobalRolesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await globalRolesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const globalRolesGetQueryKey = (options: Options<GlobalRolesGetData>) => createQueryKey('globalRolesGet', options);

/**
 * Get role
 *
 * Get a role by ID
 */
export const globalRolesGetOptions = (options: Options<GlobalRolesGetData>) => queryOptions<GlobalRolesGetResponse, DefaultError, GlobalRolesGetResponse, ReturnType<typeof globalRolesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await globalRolesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesGetQueryKey(options)
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const globalRolesUpdateMutation = (options?: Partial<Options<GlobalRolesUpdateData>>): UseMutationOptions<GlobalRolesUpdateResponse, DefaultError, Options<GlobalRolesUpdateData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesUpdateResponse, DefaultError, Options<GlobalRolesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await globalRolesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const availableContextsListQueryKey = (options?: Options<AvailableContextsListData>) => createQueryKey('availableContextsList', options);

/**
 * List available contexts
 *
 * List all available contexts for the current user
 *
 * Returns all applications and tenants the user has access to.
 */
export const availableContextsListOptions = (options?: Options<AvailableContextsListData>) => queryOptions<AvailableContextsListResponse, DefaultError, AvailableContextsListResponse, ReturnType<typeof availableContextsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await availableContextsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: availableContextsListQueryKey(options)
});

export const currentUserContextGetQueryKey = (options?: Options<CurrentUserContextGetData>) => createQueryKey('currentUserContextGet', options);

/**
 * Get active context
 *
 * Get current user's active context
 *
 * Returns the currently active application and tenant for the user.
 * This is for UI state management, not authorization decisions.
 */
export const currentUserContextGetOptions = (options?: Options<CurrentUserContextGetData>) => queryOptions<CurrentUserContextGetResponse, DefaultError, CurrentUserContextGetResponse, ReturnType<typeof currentUserContextGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await currentUserContextGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: currentUserContextGetQueryKey(options)
});

/**
 * Switch context
 *
 * Switch user's active context
 *
 * Changes the active application and/or tenant.
 * This is for UI state management, not authorization decisions.
 */
export const contextSwitchSwitchMutation = (options?: Partial<Options<ContextSwitchSwitchData>>): UseMutationOptions<ContextSwitchSwitchResponse, DefaultError, Options<ContextSwitchSwitchData>> => {
    const mutationOptions: UseMutationOptions<ContextSwitchSwitchResponse, DefaultError, Options<ContextSwitchSwitchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await contextSwitchSwitch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const allUserRolesListQueryKey = (options: Options<AllUserRolesListData>) => createQueryKey('allUserRolesList', options);

/**
 * List all user roles
 *
 * List user's roles across all applications and tenants
 *
 * Returns all role assignments for the user across all contexts.
 */
export const allUserRolesListOptions = (options: Options<AllUserRolesListData>) => queryOptions<AllUserRolesListResponse, DefaultError, AllUserRolesListResponse, ReturnType<typeof allUserRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await allUserRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: allUserRolesListQueryKey(options)
});

/**
 * Handle Midtrans webhook
 *
 * Midtrans webhook handler
 *
 * Receives webhook events from Midtrans.
 */
export const paymentWebhooksHandleMidtransMutation = (options?: Partial<Options<PaymentWebhooksHandleMidtransData>>): UseMutationOptions<PaymentWebhooksHandleMidtransResponse, DefaultError, Options<PaymentWebhooksHandleMidtransData>> => {
    const mutationOptions: UseMutationOptions<PaymentWebhooksHandleMidtransResponse, DefaultError, Options<PaymentWebhooksHandleMidtransData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await paymentWebhooksHandleMidtrans({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Handle Xendit webhook
 *
 * Xendit webhook handler
 *
 * Receives webhook events from Xendit.
 * Verifies signature via x-callback-token header.
 */
export const paymentWebhooksHandleXenditMutation = (options?: Partial<Options<PaymentWebhooksHandleXenditData>>): UseMutationOptions<PaymentWebhooksHandleXenditResponse, DefaultError, Options<PaymentWebhooksHandleXenditData>> => {
    const mutationOptions: UseMutationOptions<PaymentWebhooksHandleXenditResponse, DefaultError, Options<PaymentWebhooksHandleXenditData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await paymentWebhooksHandleXendit({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
