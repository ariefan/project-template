// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { allUserRolesList, apiKeysCreate, apiKeysGet, apiKeysList, apiKeysRevoke, apiKeysRotate, apiKeysUpdate, auditLogsExport, auditLogsGet, auditLogsList, availableContextsList, contextSwitchSwitch, currentUserContextGet, exampleCommentsBatchCreate, exampleCommentsBatchSoftDelete, exampleCommentsCreate, exampleCommentsDelete, exampleCommentsDeletePermanent, exampleCommentsGet, exampleCommentsList, exampleCommentsRestore, exampleCommentsUpdate, examplePostsBatchCreate, examplePostsBatchRestore, examplePostsBatchSoftDelete, examplePostsBatchUpdate, examplePostsCreate, examplePostsDelete, examplePostsDeletePermanent, examplePostsGet, examplePostsList, examplePostsListCursor, examplePostsListDeleted, examplePostsRestore, examplePostsUpdate, filesConfirmUpload, filesDelete, filesDeletePermanent, filesDirectUpload, filesDownload, filesGet, filesInitiateUpload, filesList, filesUpdate, globalRolesCreate, globalRolesDelete, globalRolesGet, globalRolesList, globalRolesUpdate, healthCheck, jobsCancel, jobsGet, jobsList, type Options, tenantRolesCreate, tenantRolesDelete, tenantRolesGet, tenantRolesList, tenantRolesUpdate, userPermissionsGet, usersBatchCreate, usersBatchSoftDelete, usersBatchUpdate, usersCreate, usersDelete, usersDeletePermanent, usersGet, usersList, usersResetPassword, usersRestore, usersUpdate, userTenantRolesAssign, userTenantRolesList, userTenantRolesRemove, webhooksCreate, webhooksDelete, webhooksGet, webhooksGetDelivery, webhooksList, webhooksListDeliveries, webhooksListEventTypes, webhooksRetryDelivery, webhooksRotateSecret, webhooksTest, webhooksUpdate } from '../sdk.gen';
import type { AllUserRolesListData, AllUserRolesListResponse, ApiKeysCreateData, ApiKeysCreateResponse, ApiKeysGetData, ApiKeysGetResponse, ApiKeysListData, ApiKeysListResponse, ApiKeysRevokeData, ApiKeysRevokeResponse, ApiKeysRotateData, ApiKeysRotateResponse, ApiKeysUpdateData, ApiKeysUpdateResponse, AuditLogsExportData, AuditLogsExportResponse, AuditLogsGetData, AuditLogsGetResponse, AuditLogsListData, AuditLogsListResponse, AvailableContextsListData, AvailableContextsListResponse, ContextSwitchSwitchData, ContextSwitchSwitchResponse, CurrentUserContextGetData, CurrentUserContextGetResponse, ExampleCommentsBatchCreateData, ExampleCommentsBatchCreateResponse, ExampleCommentsBatchSoftDeleteData, ExampleCommentsBatchSoftDeleteResponse, ExampleCommentsCreateData, ExampleCommentsCreateResponse, ExampleCommentsDeleteData, ExampleCommentsDeletePermanentData, ExampleCommentsDeletePermanentResponse, ExampleCommentsDeleteResponse, ExampleCommentsGetData, ExampleCommentsGetResponse, ExampleCommentsListData, ExampleCommentsListResponse, ExampleCommentsRestoreData, ExampleCommentsRestoreResponse, ExampleCommentsUpdateData, ExampleCommentsUpdateResponse, ExamplePostsBatchCreateData, ExamplePostsBatchCreateResponse, ExamplePostsBatchRestoreData, ExamplePostsBatchRestoreResponse, ExamplePostsBatchSoftDeleteData, ExamplePostsBatchSoftDeleteResponse, ExamplePostsBatchUpdateData, ExamplePostsBatchUpdateResponse, ExamplePostsCreateData, ExamplePostsCreateResponse, ExamplePostsDeleteData, ExamplePostsDeletePermanentData, ExamplePostsDeletePermanentResponse, ExamplePostsDeleteResponse, ExamplePostsGetData, ExamplePostsGetResponse, ExamplePostsListCursorData, ExamplePostsListCursorResponse, ExamplePostsListData, ExamplePostsListDeletedData, ExamplePostsListDeletedResponse, ExamplePostsListResponse, ExamplePostsRestoreData, ExamplePostsRestoreResponse, ExamplePostsUpdateData, ExamplePostsUpdateResponse, FilesConfirmUploadData, FilesConfirmUploadResponse, FilesDeleteData, FilesDeletePermanentData, FilesDeletePermanentResponse, FilesDeleteResponse, FilesDirectUploadData, FilesDirectUploadResponse, FilesDownloadData, FilesDownloadResponse, FilesGetData, FilesGetResponse, FilesInitiateUploadData, FilesInitiateUploadResponse, FilesListData, FilesListResponse, FilesUpdateData, FilesUpdateResponse, GlobalRolesCreateData, GlobalRolesCreateResponse, GlobalRolesDeleteData, GlobalRolesDeleteResponse, GlobalRolesGetData, GlobalRolesGetResponse, GlobalRolesListData, GlobalRolesListResponse, GlobalRolesUpdateData, GlobalRolesUpdateResponse, HealthCheckData, HealthCheckResponse, JobsCancelData, JobsCancelResponse, JobsGetData, JobsGetResponse, JobsListData, JobsListResponse, TenantRolesCreateData, TenantRolesCreateResponse, TenantRolesDeleteData, TenantRolesDeleteResponse, TenantRolesGetData, TenantRolesGetResponse, TenantRolesListData, TenantRolesListResponse, TenantRolesUpdateData, TenantRolesUpdateResponse, UserPermissionsGetData, UserPermissionsGetResponse, UsersBatchCreateData, UsersBatchCreateResponse, UsersBatchSoftDeleteData, UsersBatchSoftDeleteResponse, UsersBatchUpdateData, UsersBatchUpdateResponse, UsersCreateData, UsersCreateResponse, UsersDeleteData, UsersDeletePermanentData, UsersDeletePermanentResponse, UsersDeleteResponse, UsersGetData, UsersGetResponse, UsersListData, UsersListResponse, UsersResetPasswordData, UsersResetPasswordResponse, UsersRestoreData, UsersRestoreResponse, UsersUpdateData, UsersUpdateResponse, UserTenantRolesAssignData, UserTenantRolesAssignResponse, UserTenantRolesListData, UserTenantRolesListResponse, UserTenantRolesRemoveData, UserTenantRolesRemoveResponse, WebhooksCreateData, WebhooksCreateResponse, WebhooksDeleteData, WebhooksDeleteResponse, WebhooksGetData, WebhooksGetDeliveryData, WebhooksGetDeliveryResponse, WebhooksGetResponse, WebhooksListData, WebhooksListDeliveriesData, WebhooksListDeliveriesResponse, WebhooksListEventTypesData, WebhooksListEventTypesResponse, WebhooksListResponse, WebhooksRetryDeliveryData, WebhooksRetryDeliveryResponse, WebhooksRotateSecretData, WebhooksRotateSecretResponse, WebhooksTestData, WebhooksTestResponse, WebhooksUpdateData, WebhooksUpdateResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) => createQueryKey('healthCheck', options);

/**
 * Health check
 *
 * Check API health status
 * Returns 200 OK if the API is healthy
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) => queryOptions<HealthCheckResponse, DefaultError, HealthCheckResponse, ReturnType<typeof healthCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await healthCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthCheckQueryKey(options)
});

export const apiKeysListQueryKey = (options: Options<ApiKeysListData>) => createQueryKey('apiKeysList', options);

/**
 * List API keys
 *
 * List all API keys in an organization
 *
 * Does not return the actual key secrets.
 */
export const apiKeysListOptions = (options: Options<ApiKeysListData>) => queryOptions<ApiKeysListResponse, DefaultError, ApiKeysListResponse, ReturnType<typeof apiKeysListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await apiKeysList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: apiKeysListQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const apiKeysListInfiniteQueryKey = (options: Options<ApiKeysListData>): QueryKey<Options<ApiKeysListData>> => createQueryKey('apiKeysList', options, true);

/**
 * List API keys
 *
 * List all API keys in an organization
 *
 * Does not return the actual key secrets.
 */
export const apiKeysListInfiniteOptions = (options: Options<ApiKeysListData>) => infiniteQueryOptions<ApiKeysListResponse, DefaultError, InfiniteData<ApiKeysListResponse>, QueryKey<Options<ApiKeysListData>>, number | Pick<QueryKey<Options<ApiKeysListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ApiKeysListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await apiKeysList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: apiKeysListInfiniteQueryKey(options)
});

/**
 * Create API key
 *
 * Create a new API key
 *
 * The key secret is only returned once in the response.
 * Store it securely - it cannot be retrieved again.
 */
export const apiKeysCreateMutation = (options?: Partial<Options<ApiKeysCreateData>>): UseMutationOptions<ApiKeysCreateResponse, DefaultError, Options<ApiKeysCreateData>> => {
    const mutationOptions: UseMutationOptions<ApiKeysCreateResponse, DefaultError, Options<ApiKeysCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await apiKeysCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Revoke API key
 *
 * Revoke (delete) an API key
 *
 * The key will immediately stop working.
 * This action cannot be undone.
 */
export const apiKeysRevokeMutation = (options?: Partial<Options<ApiKeysRevokeData>>): UseMutationOptions<ApiKeysRevokeResponse, DefaultError, Options<ApiKeysRevokeData>> => {
    const mutationOptions: UseMutationOptions<ApiKeysRevokeResponse, DefaultError, Options<ApiKeysRevokeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await apiKeysRevoke({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const apiKeysGetQueryKey = (options: Options<ApiKeysGetData>) => createQueryKey('apiKeysGet', options);

/**
 * Get API key
 *
 * Get an API key by ID
 *
 * Does not return the actual key secret.
 */
export const apiKeysGetOptions = (options: Options<ApiKeysGetData>) => queryOptions<ApiKeysGetResponse, DefaultError, ApiKeysGetResponse, ReturnType<typeof apiKeysGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await apiKeysGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: apiKeysGetQueryKey(options)
});

/**
 * Update API key
 *
 * Update an API key
 *
 * Can update name, description, permissions, and active status.
 * Cannot change the key secret - create a new key instead.
 */
export const apiKeysUpdateMutation = (options?: Partial<Options<ApiKeysUpdateData>>): UseMutationOptions<ApiKeysUpdateResponse, DefaultError, Options<ApiKeysUpdateData>> => {
    const mutationOptions: UseMutationOptions<ApiKeysUpdateResponse, DefaultError, Options<ApiKeysUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await apiKeysUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rotate API key
 *
 * Rotate an API key
 *
 * Creates a new key secret while keeping the same key ID.
 * The old secret immediately stops working.
 */
export const apiKeysRotateMutation = (options?: Partial<Options<ApiKeysRotateData>>): UseMutationOptions<ApiKeysRotateResponse, DefaultError, Options<ApiKeysRotateData>> => {
    const mutationOptions: UseMutationOptions<ApiKeysRotateResponse, DefaultError, Options<ApiKeysRotateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await apiKeysRotate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const auditLogsListQueryKey = (options: Options<AuditLogsListData>) => createQueryKey('auditLogsList', options);

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsListOptions = (options: Options<AuditLogsListData>) => queryOptions<AuditLogsListResponse, DefaultError, AuditLogsListResponse, ReturnType<typeof auditLogsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await auditLogsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsListQueryKey(options)
});

export const auditLogsListInfiniteQueryKey = (options: Options<AuditLogsListData>): QueryKey<Options<AuditLogsListData>> => createQueryKey('auditLogsList', options, true);

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsListInfiniteOptions = (options: Options<AuditLogsListData>) => infiniteQueryOptions<AuditLogsListResponse, DefaultError, InfiniteData<AuditLogsListResponse>, QueryKey<Options<AuditLogsListData>>, number | Pick<QueryKey<Options<AuditLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<AuditLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await auditLogsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsListInfiniteQueryKey(options)
});

/**
 * Export audit logs
 *
 * Export audit logs
 *
 * Returns a download URL for audit logs in CSV or JSON format.
 * For large exports, returns 202 Accepted with a job ID.
 */
export const auditLogsExportMutation = (options?: Partial<Options<AuditLogsExportData>>): UseMutationOptions<AuditLogsExportResponse, DefaultError, Options<AuditLogsExportData>> => {
    const mutationOptions: UseMutationOptions<AuditLogsExportResponse, DefaultError, Options<AuditLogsExportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await auditLogsExport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const auditLogsGetQueryKey = (options: Options<AuditLogsGetData>) => createQueryKey('auditLogsGet', options);

/**
 * Get audit log entry
 *
 * Get a single audit log entry
 */
export const auditLogsGetOptions = (options: Options<AuditLogsGetData>) => queryOptions<AuditLogsGetResponse, DefaultError, AuditLogsGetResponse, ReturnType<typeof auditLogsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await auditLogsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsGetQueryKey(options)
});

export const examplePostsListQueryKey = (options: Options<ExamplePostsListData>) => createQueryKey('examplePostsList', options);

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsListOptions = (options: Options<ExamplePostsListData>) => queryOptions<ExamplePostsListResponse, DefaultError, ExamplePostsListResponse, ReturnType<typeof examplePostsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await examplePostsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListQueryKey(options)
});

export const examplePostsListInfiniteQueryKey = (options: Options<ExamplePostsListData>): QueryKey<Options<ExamplePostsListData>> => createQueryKey('examplePostsList', options, true);

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsListInfiniteOptions = (options: Options<ExamplePostsListData>) => infiniteQueryOptions<ExamplePostsListResponse, DefaultError, InfiniteData<ExamplePostsListResponse>, QueryKey<Options<ExamplePostsListData>>, number | Pick<QueryKey<Options<ExamplePostsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await examplePostsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListInfiniteQueryKey(options)
});

/**
 * Create example post
 *
 * Create a new post
 */
export const examplePostsCreateMutation = (options?: Partial<Options<ExamplePostsCreateData>>): UseMutationOptions<ExamplePostsCreateResponse, DefaultError, Options<ExamplePostsCreateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsCreateResponse, DefaultError, Options<ExamplePostsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch update example posts
 *
 * Batch update posts
 */
export const examplePostsBatchUpdateMutation = (options?: Partial<Options<ExamplePostsBatchUpdateData>>): UseMutationOptions<ExamplePostsBatchUpdateResponse, DefaultError, Options<ExamplePostsBatchUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchUpdateResponse, DefaultError, Options<ExamplePostsBatchUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsBatchUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch create example posts
 *
 * Batch create posts
 */
export const examplePostsBatchCreateMutation = (options?: Partial<Options<ExamplePostsBatchCreateData>>): UseMutationOptions<ExamplePostsBatchCreateResponse, DefaultError, Options<ExamplePostsBatchCreateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchCreateResponse, DefaultError, Options<ExamplePostsBatchCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsBatchCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch restore example posts
 *
 * Batch restore soft-deleted posts
 */
export const examplePostsBatchRestoreMutation = (options?: Partial<Options<ExamplePostsBatchRestoreData>>): UseMutationOptions<ExamplePostsBatchRestoreResponse, DefaultError, Options<ExamplePostsBatchRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchRestoreResponse, DefaultError, Options<ExamplePostsBatchRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsBatchRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch soft delete example posts
 *
 * Batch soft delete posts
 */
export const examplePostsBatchSoftDeleteMutation = (options?: Partial<Options<ExamplePostsBatchSoftDeleteData>>): UseMutationOptions<ExamplePostsBatchSoftDeleteResponse, DefaultError, Options<ExamplePostsBatchSoftDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchSoftDeleteResponse, DefaultError, Options<ExamplePostsBatchSoftDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsBatchSoftDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const examplePostsListCursorQueryKey = (options: Options<ExamplePostsListCursorData>) => createQueryKey('examplePostsListCursor', options);

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursorOptions = (options: Options<ExamplePostsListCursorData>) => queryOptions<ExamplePostsListCursorResponse, DefaultError, ExamplePostsListCursorResponse, ReturnType<typeof examplePostsListCursorQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await examplePostsListCursor({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListCursorQueryKey(options)
});

export const examplePostsListCursorInfiniteQueryKey = (options: Options<ExamplePostsListCursorData>): QueryKey<Options<ExamplePostsListCursorData>> => createQueryKey('examplePostsListCursor', options, true);

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursorInfiniteOptions = (options: Options<ExamplePostsListCursorData>) => infiniteQueryOptions<ExamplePostsListCursorResponse, DefaultError, InfiniteData<ExamplePostsListCursorResponse>, QueryKey<Options<ExamplePostsListCursorData>>, string | Pick<QueryKey<Options<ExamplePostsListCursorData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListCursorData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                cursor: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await examplePostsListCursor({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListCursorInfiniteQueryKey(options)
});

export const examplePostsListDeletedQueryKey = (options: Options<ExamplePostsListDeletedData>) => createQueryKey('examplePostsListDeleted', options);

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeletedOptions = (options: Options<ExamplePostsListDeletedData>) => queryOptions<ExamplePostsListDeletedResponse, DefaultError, ExamplePostsListDeletedResponse, ReturnType<typeof examplePostsListDeletedQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await examplePostsListDeleted({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListDeletedQueryKey(options)
});

export const examplePostsListDeletedInfiniteQueryKey = (options: Options<ExamplePostsListDeletedData>): QueryKey<Options<ExamplePostsListDeletedData>> => createQueryKey('examplePostsListDeleted', options, true);

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeletedInfiniteOptions = (options: Options<ExamplePostsListDeletedData>) => infiniteQueryOptions<ExamplePostsListDeletedResponse, DefaultError, InfiniteData<ExamplePostsListDeletedResponse>, QueryKey<Options<ExamplePostsListDeletedData>>, number | Pick<QueryKey<Options<ExamplePostsListDeletedData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListDeletedData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await examplePostsListDeleted({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListDeletedInfiniteQueryKey(options)
});

/**
 * Soft delete example post
 *
 * Soft delete a post (default delete behavior)
 * Post is marked as deleted but can be restored
 */
export const examplePostsDeleteMutation = (options?: Partial<Options<ExamplePostsDeleteData>>): UseMutationOptions<ExamplePostsDeleteResponse, DefaultError, Options<ExamplePostsDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsDeleteResponse, DefaultError, Options<ExamplePostsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const examplePostsGetQueryKey = (options: Options<ExamplePostsGetData>) => createQueryKey('examplePostsGet', options);

/**
 * Get example post
 *
 * Get a single post by ID
 */
export const examplePostsGetOptions = (options: Options<ExamplePostsGetData>) => queryOptions<ExamplePostsGetResponse, DefaultError, ExamplePostsGetResponse, ReturnType<typeof examplePostsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await examplePostsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsGetQueryKey(options)
});

/**
 * Update example post
 *
 * Update a post (partial update)
 */
export const examplePostsUpdateMutation = (options?: Partial<Options<ExamplePostsUpdateData>>): UseMutationOptions<ExamplePostsUpdateResponse, DefaultError, Options<ExamplePostsUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsUpdateResponse, DefaultError, Options<ExamplePostsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete example post
 *
 * Permanently delete a post (hard delete)
 * Post is permanently removed and cannot be restored
 */
export const examplePostsDeletePermanentMutation = (options?: Partial<Options<ExamplePostsDeletePermanentData>>): UseMutationOptions<ExamplePostsDeletePermanentResponse, DefaultError, Options<ExamplePostsDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsDeletePermanentResponse, DefaultError, Options<ExamplePostsDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore example post
 *
 * Restore a soft-deleted post
 */
export const examplePostsRestoreMutation = (options?: Partial<Options<ExamplePostsRestoreData>>): UseMutationOptions<ExamplePostsRestoreResponse, DefaultError, Options<ExamplePostsRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsRestoreResponse, DefaultError, Options<ExamplePostsRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await examplePostsRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exampleCommentsListQueryKey = (options: Options<ExampleCommentsListData>) => createQueryKey('exampleCommentsList', options);

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsListOptions = (options: Options<ExampleCommentsListData>) => queryOptions<ExampleCommentsListResponse, DefaultError, ExampleCommentsListResponse, ReturnType<typeof exampleCommentsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await exampleCommentsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsListQueryKey(options)
});

export const exampleCommentsListInfiniteQueryKey = (options: Options<ExampleCommentsListData>): QueryKey<Options<ExampleCommentsListData>> => createQueryKey('exampleCommentsList', options, true);

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsListInfiniteOptions = (options: Options<ExampleCommentsListData>) => infiniteQueryOptions<ExampleCommentsListResponse, DefaultError, InfiniteData<ExampleCommentsListResponse>, QueryKey<Options<ExampleCommentsListData>>, number | Pick<QueryKey<Options<ExampleCommentsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExampleCommentsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await exampleCommentsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsListInfiniteQueryKey(options)
});

/**
 * Create comment on post
 *
 * Create a new comment on a post
 */
export const exampleCommentsCreateMutation = (options?: Partial<Options<ExampleCommentsCreateData>>): UseMutationOptions<ExampleCommentsCreateResponse, DefaultError, Options<ExampleCommentsCreateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsCreateResponse, DefaultError, Options<ExampleCommentsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch create comments
 *
 * Batch create comments
 */
export const exampleCommentsBatchCreateMutation = (options?: Partial<Options<ExampleCommentsBatchCreateData>>): UseMutationOptions<ExampleCommentsBatchCreateResponse, DefaultError, Options<ExampleCommentsBatchCreateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsBatchCreateResponse, DefaultError, Options<ExampleCommentsBatchCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsBatchCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch soft delete comments
 *
 * Batch soft delete comments
 */
export const exampleCommentsBatchSoftDeleteMutation = (options?: Partial<Options<ExampleCommentsBatchSoftDeleteData>>): UseMutationOptions<ExampleCommentsBatchSoftDeleteResponse, DefaultError, Options<ExampleCommentsBatchSoftDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsBatchSoftDeleteResponse, DefaultError, Options<ExampleCommentsBatchSoftDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsBatchSoftDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Soft delete comment
 *
 * Soft delete a comment
 */
export const exampleCommentsDeleteMutation = (options?: Partial<Options<ExampleCommentsDeleteData>>): UseMutationOptions<ExampleCommentsDeleteResponse, DefaultError, Options<ExampleCommentsDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsDeleteResponse, DefaultError, Options<ExampleCommentsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exampleCommentsGetQueryKey = (options: Options<ExampleCommentsGetData>) => createQueryKey('exampleCommentsGet', options);

/**
 * Get comment
 *
 * Get a single comment by ID
 */
export const exampleCommentsGetOptions = (options: Options<ExampleCommentsGetData>) => queryOptions<ExampleCommentsGetResponse, DefaultError, ExampleCommentsGetResponse, ReturnType<typeof exampleCommentsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await exampleCommentsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsGetQueryKey(options)
});

/**
 * Update comment
 *
 * Update a comment (partial update)
 */
export const exampleCommentsUpdateMutation = (options?: Partial<Options<ExampleCommentsUpdateData>>): UseMutationOptions<ExampleCommentsUpdateResponse, DefaultError, Options<ExampleCommentsUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsUpdateResponse, DefaultError, Options<ExampleCommentsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete comment
 *
 * Permanently delete a comment (hard delete)
 */
export const exampleCommentsDeletePermanentMutation = (options?: Partial<Options<ExampleCommentsDeletePermanentData>>): UseMutationOptions<ExampleCommentsDeletePermanentResponse, DefaultError, Options<ExampleCommentsDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsDeletePermanentResponse, DefaultError, Options<ExampleCommentsDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore comment
 *
 * Restore a soft-deleted comment
 */
export const exampleCommentsRestoreMutation = (options?: Partial<Options<ExampleCommentsRestoreData>>): UseMutationOptions<ExampleCommentsRestoreResponse, DefaultError, Options<ExampleCommentsRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsRestoreResponse, DefaultError, Options<ExampleCommentsRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await exampleCommentsRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesListQueryKey = (options: Options<FilesListData>) => createQueryKey('filesList', options);

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesListOptions = (options: Options<FilesListData>) => queryOptions<FilesListResponse, DefaultError, FilesListResponse, ReturnType<typeof filesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesListQueryKey(options)
});

export const filesListInfiniteQueryKey = (options: Options<FilesListData>): QueryKey<Options<FilesListData>> => createQueryKey('filesList', options, true);

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesListInfiniteOptions = (options: Options<FilesListData>) => infiniteQueryOptions<FilesListResponse, DefaultError, InfiniteData<FilesListResponse>, QueryKey<Options<FilesListData>>, number | Pick<QueryKey<Options<FilesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<FilesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await filesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesListInfiniteQueryKey(options)
});

/**
 * Direct file upload
 *
 * Direct file upload (multipart/form-data)
 *
 * For simple uploads of small files (< 10 MB).
 * File is uploaded directly to the API server.
 *
 * Note: For larger files or high volume, use presigned URL upload.
 */
export const filesDirectUploadMutation = (options?: Partial<Options<FilesDirectUploadData>>): UseMutationOptions<FilesDirectUploadResponse, DefaultError, Options<FilesDirectUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesDirectUploadResponse, DefaultError, Options<FilesDirectUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDirectUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Initiate presigned URL upload
 *
 * Initiate a presigned URL upload
 *
 * Returns a presigned URL for direct upload to storage (S3/R2/GCS).
 * Client uploads directly to storage, then confirms with the API.
 *
 * Flow:
 * 1. POST /files/uploads - Get presigned URL
 * 2. PUT {presignedUrl} - Upload directly to storage
 * 3. POST /files/uploads/{uploadId}/confirm - Confirm upload
 */
export const filesInitiateUploadMutation = (options?: Partial<Options<FilesInitiateUploadData>>): UseMutationOptions<FilesInitiateUploadResponse, DefaultError, Options<FilesInitiateUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesInitiateUploadResponse, DefaultError, Options<FilesInitiateUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesInitiateUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Confirm presigned URL upload
 *
 * Confirm a presigned URL upload
 *
 * Called after client successfully uploads to the presigned URL.
 * Triggers virus scanning and creates the file record.
 */
export const filesConfirmUploadMutation = (options?: Partial<Options<FilesConfirmUploadData>>): UseMutationOptions<FilesConfirmUploadResponse, DefaultError, Options<FilesConfirmUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesConfirmUploadResponse, DefaultError, Options<FilesConfirmUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesConfirmUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete file
 *
 * Delete a file (soft delete)
 *
 * File is marked as deleted but retained for audit purposes.
 * Storage is cleaned up after retention period.
 */
export const filesDeleteMutation = (options?: Partial<Options<FilesDeleteData>>): UseMutationOptions<FilesDeleteResponse, DefaultError, Options<FilesDeleteData>> => {
    const mutationOptions: UseMutationOptions<FilesDeleteResponse, DefaultError, Options<FilesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesGetQueryKey = (options: Options<FilesGetData>) => createQueryKey('filesGet', options);

/**
 * Get file
 *
 * Get a single file by ID
 *
 * Returns file metadata including a fresh signed URL for download.
 */
export const filesGetOptions = (options: Options<FilesGetData>) => queryOptions<FilesGetResponse, DefaultError, FilesGetResponse, ReturnType<typeof filesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesGetQueryKey(options)
});

/**
 * Update file
 *
 * Update file properties
 *
 * Currently supports changing the access level (private/public).
 */
export const filesUpdateMutation = (options?: Partial<Options<FilesUpdateData>>): UseMutationOptions<FilesUpdateResponse, DefaultError, Options<FilesUpdateData>> => {
    const mutationOptions: UseMutationOptions<FilesUpdateResponse, DefaultError, Options<FilesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesDownloadQueryKey = (options: Options<FilesDownloadData>) => createQueryKey('filesDownload', options);

/**
 * Download file
 *
 * Download a file
 *
 * Returns a redirect to a signed URL for the file.
 * The signed URL expires in 5 minutes.
 */
export const filesDownloadOptions = (options: Options<FilesDownloadData>) => queryOptions<FilesDownloadResponse, DefaultError, FilesDownloadResponse, ReturnType<typeof filesDownloadQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await filesDownload({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesDownloadQueryKey(options)
});

/**
 * Permanently delete file
 *
 * Permanently delete a file (hard delete)
 *
 * Immediately removes file from storage.
 * Use with caution - cannot be undone.
 */
export const filesDeletePermanentMutation = (options?: Partial<Options<FilesDeletePermanentData>>): UseMutationOptions<FilesDeletePermanentResponse, DefaultError, Options<FilesDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<FilesDeletePermanentResponse, DefaultError, Options<FilesDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await filesDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const jobsListQueryKey = (options: Options<JobsListData>) => createQueryKey('jobsList', options);

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsListOptions = (options: Options<JobsListData>) => queryOptions<JobsListResponse, DefaultError, JobsListResponse, ReturnType<typeof jobsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await jobsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsListQueryKey(options)
});

export const jobsListInfiniteQueryKey = (options: Options<JobsListData>): QueryKey<Options<JobsListData>> => createQueryKey('jobsList', options, true);

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsListInfiniteOptions = (options: Options<JobsListData>) => infiniteQueryOptions<JobsListResponse, DefaultError, InfiniteData<JobsListResponse>, QueryKey<Options<JobsListData>>, number | Pick<QueryKey<Options<JobsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<JobsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await jobsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsListInfiniteQueryKey(options)
});

export const jobsGetQueryKey = (options: Options<JobsGetData>) => createQueryKey('jobsGet', options);

/**
 * Get job status
 *
 * Get job status
 *
 * Poll this endpoint to check progress of async operations.
 */
export const jobsGetOptions = (options: Options<JobsGetData>) => queryOptions<JobsGetResponse, DefaultError, JobsGetResponse, ReturnType<typeof jobsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await jobsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsGetQueryKey(options)
});

/**
 * Cancel job
 *
 * Cancel a job
 *
 * Only pending or processing jobs can be cancelled.
 */
export const jobsCancelMutation = (options?: Partial<Options<JobsCancelData>>): UseMutationOptions<JobsCancelResponse, DefaultError, Options<JobsCancelData>> => {
    const mutationOptions: UseMutationOptions<JobsCancelResponse, DefaultError, Options<JobsCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await jobsCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tenantRolesListQueryKey = (options: Options<TenantRolesListData>) => createQueryKey('tenantRolesList', options);

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesListOptions = (options: Options<TenantRolesListData>) => queryOptions<TenantRolesListResponse, DefaultError, TenantRolesListResponse, ReturnType<typeof tenantRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await tenantRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesListQueryKey(options)
});

export const tenantRolesListInfiniteQueryKey = (options: Options<TenantRolesListData>): QueryKey<Options<TenantRolesListData>> => createQueryKey('tenantRolesList', options, true);

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesListInfiniteOptions = (options: Options<TenantRolesListData>) => infiniteQueryOptions<TenantRolesListResponse, DefaultError, InfiniteData<TenantRolesListResponse>, QueryKey<Options<TenantRolesListData>>, number | Pick<QueryKey<Options<TenantRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<TenantRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await tenantRolesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesListInfiniteQueryKey(options)
});

/**
 * Create tenant role
 *
 * Create a tenant-scoped role
 *
 * Creates a custom role for this specific tenant.
 */
export const tenantRolesCreateMutation = (options?: Partial<Options<TenantRolesCreateData>>): UseMutationOptions<TenantRolesCreateResponse, DefaultError, Options<TenantRolesCreateData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesCreateResponse, DefaultError, Options<TenantRolesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await tenantRolesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const tenantRolesDeleteMutation = (options?: Partial<Options<TenantRolesDeleteData>>): UseMutationOptions<TenantRolesDeleteResponse, DefaultError, Options<TenantRolesDeleteData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesDeleteResponse, DefaultError, Options<TenantRolesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await tenantRolesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tenantRolesGetQueryKey = (options: Options<TenantRolesGetData>) => createQueryKey('tenantRolesGet', options);

/**
 * Get role
 *
 * Get a role by ID
 */
export const tenantRolesGetOptions = (options: Options<TenantRolesGetData>) => queryOptions<TenantRolesGetResponse, DefaultError, TenantRolesGetResponse, ReturnType<typeof tenantRolesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await tenantRolesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesGetQueryKey(options)
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const tenantRolesUpdateMutation = (options?: Partial<Options<TenantRolesUpdateData>>): UseMutationOptions<TenantRolesUpdateResponse, DefaultError, Options<TenantRolesUpdateData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesUpdateResponse, DefaultError, Options<TenantRolesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await tenantRolesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersListQueryKey = (options: Options<UsersListData>) => createQueryKey('usersList', options);

/**
 * List users
 *
 * List users in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const usersListOptions = (options: Options<UsersListData>) => queryOptions<UsersListResponse, DefaultError, UsersListResponse, ReturnType<typeof usersListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await usersList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersListQueryKey(options)
});

export const usersListInfiniteQueryKey = (options: Options<UsersListData>): QueryKey<Options<UsersListData>> => createQueryKey('usersList', options, true);

/**
 * List users
 *
 * List users in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const usersListInfiniteOptions = (options: Options<UsersListData>) => infiniteQueryOptions<UsersListResponse, DefaultError, InfiniteData<UsersListResponse>, QueryKey<Options<UsersListData>>, number | Pick<QueryKey<Options<UsersListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<UsersListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await usersList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersListInfiniteQueryKey(options)
});

/**
 * Create user
 *
 * Create a new user
 */
export const usersCreateMutation = (options?: Partial<Options<UsersCreateData>>): UseMutationOptions<UsersCreateResponse, DefaultError, Options<UsersCreateData>> => {
    const mutationOptions: UseMutationOptions<UsersCreateResponse, DefaultError, Options<UsersCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch update users
 *
 * Batch update users
 */
export const usersBatchUpdateMutation = (options?: Partial<Options<UsersBatchUpdateData>>): UseMutationOptions<UsersBatchUpdateResponse, DefaultError, Options<UsersBatchUpdateData>> => {
    const mutationOptions: UseMutationOptions<UsersBatchUpdateResponse, DefaultError, Options<UsersBatchUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersBatchUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch create users
 *
 * Batch create users
 */
export const usersBatchCreateMutation = (options?: Partial<Options<UsersBatchCreateData>>): UseMutationOptions<UsersBatchCreateResponse, DefaultError, Options<UsersBatchCreateData>> => {
    const mutationOptions: UseMutationOptions<UsersBatchCreateResponse, DefaultError, Options<UsersBatchCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersBatchCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch soft delete users
 *
 * Batch soft delete users
 */
export const usersBatchSoftDeleteMutation = (options?: Partial<Options<UsersBatchSoftDeleteData>>): UseMutationOptions<UsersBatchSoftDeleteResponse, DefaultError, Options<UsersBatchSoftDeleteData>> => {
    const mutationOptions: UseMutationOptions<UsersBatchSoftDeleteResponse, DefaultError, Options<UsersBatchSoftDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersBatchSoftDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Soft delete user
 *
 * Soft delete a user (default delete behavior)
 * User is marked as deleted but can be restored
 */
export const usersDeleteMutation = (options?: Partial<Options<UsersDeleteData>>): UseMutationOptions<UsersDeleteResponse, DefaultError, Options<UsersDeleteData>> => {
    const mutationOptions: UseMutationOptions<UsersDeleteResponse, DefaultError, Options<UsersDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersGetQueryKey = (options: Options<UsersGetData>) => createQueryKey('usersGet', options);

/**
 * Get user
 *
 * Get a single user by ID
 */
export const usersGetOptions = (options: Options<UsersGetData>) => queryOptions<UsersGetResponse, DefaultError, UsersGetResponse, ReturnType<typeof usersGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await usersGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: usersGetQueryKey(options)
});

/**
 * Update user
 *
 * Update a user (partial update)
 */
export const usersUpdateMutation = (options?: Partial<Options<UsersUpdateData>>): UseMutationOptions<UsersUpdateResponse, DefaultError, Options<UsersUpdateData>> => {
    const mutationOptions: UseMutationOptions<UsersUpdateResponse, DefaultError, Options<UsersUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset user password
 *
 * Custom action: Reset user password
 */
export const usersResetPasswordMutation = (options?: Partial<Options<UsersResetPasswordData>>): UseMutationOptions<UsersResetPasswordResponse, DefaultError, Options<UsersResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<UsersResetPasswordResponse, DefaultError, Options<UsersResetPasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersResetPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete user
 *
 * Permanently delete a user (hard delete)
 * User is permanently removed and cannot be restored
 */
export const usersDeletePermanentMutation = (options?: Partial<Options<UsersDeletePermanentData>>): UseMutationOptions<UsersDeletePermanentResponse, DefaultError, Options<UsersDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<UsersDeletePermanentResponse, DefaultError, Options<UsersDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore user
 *
 * Restore a soft-deleted user
 */
export const usersRestoreMutation = (options?: Partial<Options<UsersRestoreData>>): UseMutationOptions<UsersRestoreResponse, DefaultError, Options<UsersRestoreData>> => {
    const mutationOptions: UseMutationOptions<UsersRestoreResponse, DefaultError, Options<UsersRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await usersRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const userPermissionsGetQueryKey = (options: Options<UserPermissionsGetData>) => createQueryKey('userPermissionsGet', options);

/**
 * Get user effective permissions
 *
 * Get user's effective permissions in this tenant
 *
 * Returns all roles (global + tenant) and the combined effective permissions
 * after applying deny-override resolution.
 */
export const userPermissionsGetOptions = (options: Options<UserPermissionsGetData>) => queryOptions<UserPermissionsGetResponse, DefaultError, UserPermissionsGetResponse, ReturnType<typeof userPermissionsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await userPermissionsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: userPermissionsGetQueryKey(options)
});

export const userTenantRolesListQueryKey = (options: Options<UserTenantRolesListData>) => createQueryKey('userTenantRolesList', options);

/**
 * List user roles in tenant
 *
 * List roles assigned to a user in this tenant
 *
 * Returns both global and tenant-specific role assignments.
 */
export const userTenantRolesListOptions = (options: Options<UserTenantRolesListData>) => queryOptions<UserTenantRolesListResponse, DefaultError, UserTenantRolesListResponse, ReturnType<typeof userTenantRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await userTenantRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: userTenantRolesListQueryKey(options)
});

/**
 * Assign role to user
 *
 * Assign a role to a user in this tenant
 */
export const userTenantRolesAssignMutation = (options?: Partial<Options<UserTenantRolesAssignData>>): UseMutationOptions<UserTenantRolesAssignResponse, DefaultError, Options<UserTenantRolesAssignData>> => {
    const mutationOptions: UseMutationOptions<UserTenantRolesAssignResponse, DefaultError, Options<UserTenantRolesAssignData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await userTenantRolesAssign({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove role from user
 *
 * Remove a role from a user
 */
export const userTenantRolesRemoveMutation = (options?: Partial<Options<UserTenantRolesRemoveData>>): UseMutationOptions<UserTenantRolesRemoveResponse, DefaultError, Options<UserTenantRolesRemoveData>> => {
    const mutationOptions: UseMutationOptions<UserTenantRolesRemoveResponse, DefaultError, Options<UserTenantRolesRemoveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await userTenantRolesRemove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListQueryKey = (options: Options<WebhooksListData>) => createQueryKey('webhooksList', options);

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksListOptions = (options: Options<WebhooksListData>) => queryOptions<WebhooksListResponse, DefaultError, WebhooksListResponse, ReturnType<typeof webhooksListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListQueryKey(options)
});

export const webhooksListInfiniteQueryKey = (options: Options<WebhooksListData>): QueryKey<Options<WebhooksListData>> => createQueryKey('webhooksList', options, true);

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksListInfiniteOptions = (options: Options<WebhooksListData>) => infiniteQueryOptions<WebhooksListResponse, DefaultError, InfiniteData<WebhooksListResponse>, QueryKey<Options<WebhooksListData>>, number | Pick<QueryKey<Options<WebhooksListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<WebhooksListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await webhooksList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListInfiniteQueryKey(options)
});

/**
 * Create webhook
 *
 * Create a new webhook
 *
 * The secret is only returned once in the response.
 * Store it securely for signature verification.
 */
export const webhooksCreateMutation = (options?: Partial<Options<WebhooksCreateData>>): UseMutationOptions<WebhooksCreateResponse, DefaultError, Options<WebhooksCreateData>> => {
    const mutationOptions: UseMutationOptions<WebhooksCreateResponse, DefaultError, Options<WebhooksCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListEventTypesQueryKey = (options: Options<WebhooksListEventTypesData>) => createQueryKey('webhooksListEventTypes', options);

/**
 * List event types
 *
 * Get available event types
 *
 * Returns all event types that can be subscribed to.
 */
export const webhooksListEventTypesOptions = (options: Options<WebhooksListEventTypesData>) => queryOptions<WebhooksListEventTypesResponse, DefaultError, WebhooksListEventTypesResponse, ReturnType<typeof webhooksListEventTypesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksListEventTypes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListEventTypesQueryKey(options)
});

/**
 * Delete webhook
 *
 * Delete a webhook
 */
export const webhooksDeleteMutation = (options?: Partial<Options<WebhooksDeleteData>>): UseMutationOptions<WebhooksDeleteResponse, DefaultError, Options<WebhooksDeleteData>> => {
    const mutationOptions: UseMutationOptions<WebhooksDeleteResponse, DefaultError, Options<WebhooksDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksGetQueryKey = (options: Options<WebhooksGetData>) => createQueryKey('webhooksGet', options);

/**
 * Get webhook
 *
 * Get a webhook by ID
 */
export const webhooksGetOptions = (options: Options<WebhooksGetData>) => queryOptions<WebhooksGetResponse, DefaultError, WebhooksGetResponse, ReturnType<typeof webhooksGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksGetQueryKey(options)
});

/**
 * Update webhook
 *
 * Update a webhook
 */
export const webhooksUpdateMutation = (options?: Partial<Options<WebhooksUpdateData>>): UseMutationOptions<WebhooksUpdateResponse, DefaultError, Options<WebhooksUpdateData>> => {
    const mutationOptions: UseMutationOptions<WebhooksUpdateResponse, DefaultError, Options<WebhooksUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListDeliveriesQueryKey = (options: Options<WebhooksListDeliveriesData>) => createQueryKey('webhooksListDeliveries', options);

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveriesOptions = (options: Options<WebhooksListDeliveriesData>) => queryOptions<WebhooksListDeliveriesResponse, DefaultError, WebhooksListDeliveriesResponse, ReturnType<typeof webhooksListDeliveriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksListDeliveries({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListDeliveriesQueryKey(options)
});

export const webhooksListDeliveriesInfiniteQueryKey = (options: Options<WebhooksListDeliveriesData>): QueryKey<Options<WebhooksListDeliveriesData>> => createQueryKey('webhooksListDeliveries', options, true);

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveriesInfiniteOptions = (options: Options<WebhooksListDeliveriesData>) => infiniteQueryOptions<WebhooksListDeliveriesResponse, DefaultError, InfiniteData<WebhooksListDeliveriesResponse>, QueryKey<Options<WebhooksListDeliveriesData>>, number | Pick<QueryKey<Options<WebhooksListDeliveriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<WebhooksListDeliveriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await webhooksListDeliveries({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListDeliveriesInfiniteQueryKey(options)
});

export const webhooksGetDeliveryQueryKey = (options: Options<WebhooksGetDeliveryData>) => createQueryKey('webhooksGetDelivery', options);

/**
 * Get webhook delivery
 *
 * Get a specific delivery
 */
export const webhooksGetDeliveryOptions = (options: Options<WebhooksGetDeliveryData>) => queryOptions<WebhooksGetDeliveryResponse, DefaultError, WebhooksGetDeliveryResponse, ReturnType<typeof webhooksGetDeliveryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await webhooksGetDelivery({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksGetDeliveryQueryKey(options)
});

/**
 * Retry delivery
 *
 * Retry a failed delivery
 *
 * Manually triggers a retry for a failed delivery.
 */
export const webhooksRetryDeliveryMutation = (options?: Partial<Options<WebhooksRetryDeliveryData>>): UseMutationOptions<WebhooksRetryDeliveryResponse, DefaultError, Options<WebhooksRetryDeliveryData>> => {
    const mutationOptions: UseMutationOptions<WebhooksRetryDeliveryResponse, DefaultError, Options<WebhooksRetryDeliveryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksRetryDelivery({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rotate webhook secret
 *
 * Rotate webhook secret
 *
 * Generates a new secret. The old secret immediately stops working.
 */
export const webhooksRotateSecretMutation = (options?: Partial<Options<WebhooksRotateSecretData>>): UseMutationOptions<WebhooksRotateSecretResponse, DefaultError, Options<WebhooksRotateSecretData>> => {
    const mutationOptions: UseMutationOptions<WebhooksRotateSecretResponse, DefaultError, Options<WebhooksRotateSecretData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksRotateSecret({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test webhook
 *
 * Test a webhook
 *
 * Sends a test event to verify the webhook is configured correctly.
 */
export const webhooksTestMutation = (options?: Partial<Options<WebhooksTestData>>): UseMutationOptions<WebhooksTestResponse, DefaultError, Options<WebhooksTestData>> => {
    const mutationOptions: UseMutationOptions<WebhooksTestResponse, DefaultError, Options<WebhooksTestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await webhooksTest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const globalRolesListQueryKey = (options?: Options<GlobalRolesListData>) => createQueryKey('globalRolesList', options);

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesListOptions = (options?: Options<GlobalRolesListData>) => queryOptions<GlobalRolesListResponse, DefaultError, GlobalRolesListResponse, ReturnType<typeof globalRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await globalRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesListQueryKey(options)
});

export const globalRolesListInfiniteQueryKey = (options?: Options<GlobalRolesListData>): QueryKey<Options<GlobalRolesListData>> => createQueryKey('globalRolesList', options, true);

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesListInfiniteOptions = (options?: Options<GlobalRolesListData>) => infiniteQueryOptions<GlobalRolesListResponse, DefaultError, InfiniteData<GlobalRolesListResponse>, QueryKey<Options<GlobalRolesListData>>, number | Pick<QueryKey<Options<GlobalRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GlobalRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await globalRolesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesListInfiniteQueryKey(options)
});

/**
 * Create global role
 *
 * Create a global role
 *
 * Creates a role that applies across all tenants.
 */
export const globalRolesCreateMutation = (options?: Partial<Options<GlobalRolesCreateData>>): UseMutationOptions<GlobalRolesCreateResponse, DefaultError, Options<GlobalRolesCreateData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesCreateResponse, DefaultError, Options<GlobalRolesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await globalRolesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const globalRolesDeleteMutation = (options?: Partial<Options<GlobalRolesDeleteData>>): UseMutationOptions<GlobalRolesDeleteResponse, DefaultError, Options<GlobalRolesDeleteData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesDeleteResponse, DefaultError, Options<GlobalRolesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await globalRolesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const globalRolesGetQueryKey = (options: Options<GlobalRolesGetData>) => createQueryKey('globalRolesGet', options);

/**
 * Get role
 *
 * Get a role by ID
 */
export const globalRolesGetOptions = (options: Options<GlobalRolesGetData>) => queryOptions<GlobalRolesGetResponse, DefaultError, GlobalRolesGetResponse, ReturnType<typeof globalRolesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await globalRolesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesGetQueryKey(options)
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const globalRolesUpdateMutation = (options?: Partial<Options<GlobalRolesUpdateData>>): UseMutationOptions<GlobalRolesUpdateResponse, DefaultError, Options<GlobalRolesUpdateData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesUpdateResponse, DefaultError, Options<GlobalRolesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await globalRolesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const availableContextsListQueryKey = (options?: Options<AvailableContextsListData>) => createQueryKey('availableContextsList', options);

/**
 * List available contexts
 *
 * List all available contexts for the current user
 *
 * Returns all applications and tenants the user has access to.
 */
export const availableContextsListOptions = (options?: Options<AvailableContextsListData>) => queryOptions<AvailableContextsListResponse, DefaultError, AvailableContextsListResponse, ReturnType<typeof availableContextsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await availableContextsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: availableContextsListQueryKey(options)
});

export const currentUserContextGetQueryKey = (options?: Options<CurrentUserContextGetData>) => createQueryKey('currentUserContextGet', options);

/**
 * Get active context
 *
 * Get current user's active context
 *
 * Returns the currently active application and tenant for the user.
 * This is for UI state management, not authorization decisions.
 */
export const currentUserContextGetOptions = (options?: Options<CurrentUserContextGetData>) => queryOptions<CurrentUserContextGetResponse, DefaultError, CurrentUserContextGetResponse, ReturnType<typeof currentUserContextGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await currentUserContextGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: currentUserContextGetQueryKey(options)
});

/**
 * Switch context
 *
 * Switch user's active context
 *
 * Changes the active application and/or tenant.
 * This is for UI state management, not authorization decisions.
 */
export const contextSwitchSwitchMutation = (options?: Partial<Options<ContextSwitchSwitchData>>): UseMutationOptions<ContextSwitchSwitchResponse, DefaultError, Options<ContextSwitchSwitchData>> => {
    const mutationOptions: UseMutationOptions<ContextSwitchSwitchResponse, DefaultError, Options<ContextSwitchSwitchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await contextSwitchSwitch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const allUserRolesListQueryKey = (options: Options<AllUserRolesListData>) => createQueryKey('allUserRolesList', options);

/**
 * List all user roles
 *
 * List user's roles across all applications and tenants
 *
 * Returns all role assignments for the user across all contexts.
 */
export const allUserRolesListOptions = (options: Options<AllUserRolesListData>) => queryOptions<AllUserRolesListResponse, DefaultError, AllUserRolesListResponse, ReturnType<typeof allUserRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await allUserRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: allUserRolesListQueryKey(options)
});
