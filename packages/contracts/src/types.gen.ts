// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.example.com' | 'http://localhost:3001' | (string & {});
};

/**
 * Record user acceptance
 */
export type AcceptLegalDocumentRequest = {
    /**
     * Document type being accepted
     */
    documentType: LegalDocumentType;
    /**
     * Version ID being accepted
     */
    versionId: string;
};

/**
 * Acknowledge announcement response
 */
export type AcknowledgeAnnouncementResponse = {
    data: {
        /**
         * Announcement ID
         */
        announcementId: string;
        /**
         * Timestamp when acknowledged
         */
        acknowledgedAt: string;
    };
    meta: ResponseMeta;
};

/**
 * User's active context (current app/tenant selection)
 */
export type ActiveContext = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Currently active application ID
     */
    activeApplicationId: string;
    /**
     * Currently active tenant ID (null if no tenant selected)
     */
    activeTenantId?: string;
    /**
     * When the context was last updated
     */
    updatedAt: string;
};

/**
 * Active context response
 */
export type ActiveContextResponse = {
    data: ActiveContext;
    meta: ResponseMeta;
};

/**
 * Active public document response (for users)
 */
export type ActiveLegalDocumentResponse = {
    data: {
        /**
         * Document ID
         */
        id: string;
        /**
         * Document type
         */
        type: LegalDocumentType;
        /**
         * Version ID
         */
        versionId: string;
        /**
         * Version number
         */
        version: number;
        /**
         * Title
         */
        title: string;
        /**
         * Content
         */
        content: string;
        /**
         * When published
         */
        publishedAt: string;
        /**
         * Whether user has accepted this version
         */
        hasAccepted?: boolean;
        /**
         * When user accepted (if applicable)
         */
        acceptedAt?: string;
    };
    meta: ResponseMeta;
};

/**
 * List of active documents for public consumption
 */
export type ActiveLegalDocumentsListResponse = {
    data: Array<{
        /**
         * Document ID
         */
        id: string;
        /**
         * Document type
         */
        type: LegalDocumentType;
        /**
         * Version ID
         */
        versionId: string;
        /**
         * Title
         */
        title: string;
        /**
         * When published
         */
        publishedAt: string;
        /**
         * Whether user has accepted
         */
        hasAccepted?: boolean;
    }>;
    meta: ResponseMeta;
};

/**
 * Announcement resource model
 */
export type Announcement = {
    /**
     * Unique announcement identifier
     */
    id: string;
    /**
     * Organization ID (null for system-wide announcements)
     */
    orgId?: string;
    /**
     * Announcement title
     */
    title: string;
    /**
     * Announcement content (supports Markdown for links, formatting, and equations)
     */
    content: string;
    /**
     * Optional link URL
     */
    linkUrl?: string;
    /**
     * Optional link text (default: "Learn more")
     */
    linkText?: string;
    /**
     * Priority level
     */
    priority: AnnouncementPriority;
    /**
     * Scope of announcement
     */
    scope: AnnouncementScope;
    /**
     * Target roles (empty array means all roles)
     */
    targetRoles: Array<AnnouncementTargetRole>;
    /**
     * Whether users can dismiss this announcement
     */
    isDismissible: boolean;
    /**
     * Scheduled publish date/time
     */
    publishAt: string;
    /**
     * Optional expiration date/time
     */
    expiresAt?: string;
    /**
     * Whether announcement is active (manually toggled)
     */
    isActive: boolean;
    /**
     * User ID who created the announcement
     */
    createdBy: string;
    /**
     * Timestamp when created
     */
    createdAt: string;
    /**
     * Timestamp when last updated
     */
    updatedAt: string;
    /**
     * Timestamp when soft deleted
     */
    deletedAt?: string;
    /**
     * Analytics: total view count
     */
    viewCount?: number;
    /**
     * Analytics: total read count
     */
    readCount?: number;
    /**
     * Analytics: total acknowledgment count
     */
    acknowledgeCount?: number;
    /**
     * Analytics: total dismissal count
     */
    dismissCount?: number;
};

/**
 * Announcement interaction tracking
 */
export type AnnouncementInteraction = {
    /**
     * Unique interaction identifier
     */
    id: string;
    /**
     * Announcement ID
     */
    announcementId: string;
    /**
     * User ID
     */
    userId: string;
    /**
     * Timestamp when user first viewed the announcement
     */
    viewedAt?: string;
    /**
     * Timestamp when user read (opened/expanded) the announcement
     */
    readAt?: string;
    /**
     * Timestamp when user dismissed the announcement
     */
    dismissedAt?: string;
    /**
     * Timestamp when user acknowledged the announcement (critical only)
     */
    acknowledgedAt?: string;
    /**
     * Timestamp when created
     */
    createdAt: string;
    /**
     * Timestamp when last updated
     */
    updatedAt: string;
};

/**
 * Announcement collection response
 */
export type AnnouncementListResponse = {
    data: Array<AnnouncementWithInteraction>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Announcement priority level
 */
export type AnnouncementPriority = 'info' | 'warning' | 'critical' | 'success';

/**
 * Single announcement response
 */
export type AnnouncementResponse = {
    data: Announcement;
    meta: ResponseMeta;
};

/**
 * Announcement scope
 */
export type AnnouncementScope = 'system' | 'organization';

/**
 * Announcement statistics response
 */
export type AnnouncementStatsResponse = {
    data: {
        /**
         * Total view count
         */
        viewCount: number;
        /**
         * Total read count
         */
        readCount: number;
        /**
         * Total acknowledgment count
         */
        acknowledgeCount: number;
        /**
         * Total dismissal count
         */
        dismissCount: number;
        /**
         * View rate percentage
         */
        viewRate: number;
        /**
         * Read rate percentage
         */
        readRate: number;
        /**
         * Acknowledgment rate percentage (for critical announcements)
         */
        acknowledgeRate: number;
    };
    meta: ResponseMeta;
};

/**
 * User role for targeting
 */
export type AnnouncementTargetRole = 'all' | 'admin' | 'member';

/**
 * Announcement with user interaction data
 */
export type AnnouncementWithInteraction = {
    /**
     * Unique announcement identifier
     */
    id: string;
    /**
     * Organization ID (null for system-wide announcements)
     */
    orgId?: string;
    /**
     * Announcement title
     */
    title: string;
    /**
     * Announcement content (supports Markdown for links, formatting, and equations)
     */
    content: string;
    /**
     * Optional link URL
     */
    linkUrl?: string;
    /**
     * Optional link text (default: "Learn more")
     */
    linkText?: string;
    /**
     * Priority level
     */
    priority: AnnouncementPriority;
    /**
     * Scope of announcement
     */
    scope: AnnouncementScope;
    /**
     * Target roles (empty array means all roles)
     */
    targetRoles: Array<AnnouncementTargetRole>;
    /**
     * Whether users can dismiss this announcement
     */
    isDismissible: boolean;
    /**
     * Scheduled publish date/time
     */
    publishAt: string;
    /**
     * Optional expiration date/time
     */
    expiresAt?: string;
    /**
     * Whether announcement is active (manually toggled)
     */
    isActive: boolean;
    /**
     * User ID who created the announcement
     */
    createdBy: string;
    /**
     * Timestamp when created
     */
    createdAt: string;
    /**
     * Timestamp when last updated
     */
    updatedAt: string;
    /**
     * Timestamp when soft deleted
     */
    deletedAt?: string;
    /**
     * Analytics: total view count
     */
    viewCount?: number;
    /**
     * Analytics: total read count
     */
    readCount?: number;
    /**
     * Analytics: total acknowledgment count
     */
    acknowledgeCount?: number;
    /**
     * Analytics: total dismissal count
     */
    dismissCount?: number;
    /**
     * User's interaction with this announcement
     */
    interaction?: AnnouncementInteraction;
    /**
     * Whether current user has viewed
     */
    hasViewed?: boolean;
    /**
     * Whether current user has read
     */
    hasRead?: boolean;
    /**
     * Whether current user has dismissed
     */
    hasDismissed?: boolean;
    /**
     * Whether current user has acknowledged
     */
    hasAcknowledged?: boolean;
};

/**
 * Announcement with interaction response
 */
export type AnnouncementWithInteractionResponse = {
    data: AnnouncementWithInteraction;
    meta: ResponseMeta;
};

/**
 * Apply coupon request
 */
export type ApplyCouponRequest = {
    /**
     * Coupon code to apply
     */
    couponCode: string;
};

/**
 * Request to assign a role to a user
 */
export type AssignRoleRequest = {
    /**
     * Role ID to assign
     */
    roleId: string;
};

/**
 * Async export response (returns job info)
 */
export type AsyncExportResponse = {
    /**
     * Job ID for tracking
     */
    jobId: string;
    /**
     * Current status
     */
    status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';
    /**
     * URL to check job status
     */
    statusUrl: string;
    /**
     * Estimated completion time
     */
    estimatedCompletion?: string;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Response for async operations that return 202 Accepted
 */
export type AsyncJobResponse = {
    /**
     * Unique job identifier
     */
    jobId: string;
    /**
     * Current job status
     */
    status: 'pending' | 'processing' | 'completed' | 'failed';
    /**
     * URL to check job status
     */
    statusUrl: string;
    /**
     * Estimated completion time
     */
    estimatedCompletion?: string;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Actor who performed the action
 */
export type AuditActor = {
    /**
     * Type of actor
     */
    type: AuditActorType;
    /**
     * Actor ID (user ID, service account ID, or "system")
     */
    id: string;
    /**
     * Actor email (for users)
     */
    email?: string;
    /**
     * IP address of the actor
     */
    ipAddress?: string;
    /**
     * User agent string
     */
    userAgent?: string;
};

/**
 * Actor type - who performed the action
 */
export type AuditActorType = 'user' | 'service' | 'system';

/**
 * Change record for a single field
 */
export type AuditChange = {
    /**
     * Value before the change
     */
    old: unknown;
    /**
     * Value after the change
     */
    new: unknown;
};

/**
 * Audit log entry
 *
 * Immutable record of an action in the system.
 */
export type AuditLog = {
    /**
     * Unique event identifier (format: evt_abc123)
     */
    eventId: string;
    /**
     * Event type (format: resource.action)
     */
    eventType: string;
    /**
     * When the event occurred
     */
    timestamp: string;
    /**
     * Tenant where the event occurred
     */
    tenantId: string;
    /**
     * Who performed the action
     */
    actor: AuditActor;
    /**
     * What resource was affected
     */
    resource: AuditResource;
    /**
     * Changes made (for update operations)
     */
    changes?: {
        [key: string]: AuditChange;
    };
    /**
     * Full resource state before the action (for deletes, sensitive ops)
     */
    resourceBefore?: {
        [key: string]: unknown;
    };
    /**
     * Full resource state after the action (for creates, sensitive ops)
     */
    resourceAfter?: {
        [key: string]: unknown;
    };
    /**
     * Additional context
     */
    metadata?: AuditMetadata;
};

/**
 * Audit log list response
 */
export type AuditLogListResponse = {
    data: Array<AuditLog>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single audit log response
 */
export type AuditLogResponse = {
    data: AuditLog;
    meta: ResponseMeta;
};

/**
 * Additional metadata for the audit event
 */
export type AuditMetadata = {
    /**
     * Request ID for correlation
     */
    requestId?: string;
    /**
     * Session ID
     */
    sessionId?: string;
    /**
     * Reason for the action (if provided)
     */
    reason?: string;
    /**
     * Additional context-specific data
     */
    extra?: {
        [key: string]: unknown;
    };
};

/**
 * Resource affected by the action
 */
export type AuditResource = {
    /**
     * Resource type
     */
    type: string;
    /**
     * Resource ID
     */
    id: string;
    /**
     * API endpoint that was called
     */
    endpoint?: string;
    /**
     * HTTP method used
     */
    method?: string;
};

/**
 * Backup resource
 *
 * Represents a point-in-time snapshot of organization or system data.
 */
export type Backup = {
    /**
     * Unique backup identifier
     */
    id: string;
    /**
     * Organization ID (null for system backups)
     */
    organizationId?: string;
    /**
     * Backup type
     */
    type: BackupType;
    /**
     * Backup format
     */
    format: BackupFormat;
    /**
     * Current status
     */
    status: BackupStatus;
    /**
     * Path in storage
     */
    filePath?: string;
    /**
     * File size in bytes
     */
    fileSize?: number;
    /**
     * SHA-256 checksum
     */
    checksum?: string;
    /**
     * Tables included in backup
     */
    includedTables?: Array<string>;
    /**
     * Backup metadata
     */
    metadata?: BackupMetadata;
    /**
     * When backup expires (for auto-cleanup)
     */
    expiresAt?: string;
    /**
     * Who created the backup
     */
    createdBy: string;
    /**
     * When the backup was created
     */
    createdAt: string;
    /**
     * When the backup completed
     */
    completedAt?: string;
};

/**
 * Backup format
 */
export type BackupFormat = 'json' | 'pg_dump';

/**
 * Backup list response
 */
export type BackupListResponse = {
    data: Array<Backup>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Backup metadata
 */
export type BackupMetadata = {
    /**
     * Row counts per table
     */
    rowCounts?: {
        [key: string]: number;
    };
    /**
     * Number of files included
     */
    filesCount?: number;
    /**
     * Total size of files
     */
    filesSize?: number;
    /**
     * Duration in milliseconds
     */
    duration?: number;
    /**
     * Error message (if failed)
     */
    error?: string;
};

/**
 * Single backup response
 */
export type BackupResponse = {
    data: Backup;
    meta: ResponseMeta;
};

/**
 * Backup status
 */
export type BackupStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

/**
 * Backup type
 */
export type BackupType = 'organization' | 'system';

/**
 * Batch delete response envelope
 */
export type BatchDeleteResponse = {
    /**
     * Results for each item in the batch
     */
    results: Array<BatchDeleteResult>;
    /**
     * Summary of operation results
     */
    summary: BatchSummary;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Batch delete result (soft delete)
 */
export type BatchDeleteResult = {
    /**
     * Index of the item in the original request array
     */
    index: number;
    /**
     * Status of the operation for this item
     */
    status: 'success' | 'error' | 'skipped';
    /**
     * Deleted item info (present if status is success)
     */
    data?: {
        /**
         * ID of the deleted item
         */
        id: string;
        /**
         * Timestamp when the item was deleted
         */
        deletedAt: string;
    };
    /**
     * Error details (present if status is error)
     */
    error?: {
        /**
         * Error code
         */
        code: string;
        /**
         * Error message
         */
        message: string;
    };
};

/**
 * Options for batch operations
 */
export type BatchOptions = {
    /**
     * If true, all items succeed or all fail (transactional)
     */
    atomic?: boolean;
    /**
     * If true, return created/updated records in response
     */
    returnRecords?: boolean;
    /**
     * If true, skip items that already exist (duplicates)
     */
    skipDuplicates?: boolean;
    /**
     * If true, validate without actually creating/updating
     */
    validateOnly?: boolean;
};

/**
 * Summary of batch operation results
 */
export type BatchSummary = {
    /**
     * Total number of items in the request
     */
    total: number;
    /**
     * Number of successfully processed items
     */
    successful: number;
    /**
     * Number of failed items
     */
    failed: number;
    /**
     * Number of skipped items (e.g., duplicates)
     */
    skipped: number;
};

/**
 * Cancel subscription request
 */
export type CancelSubscriptionRequest = {
    /**
     * Cancel immediately (vs. at period end)
     */
    immediate?: boolean;
    /**
     * Optional cancellation reason
     */
    reason?: string;
};

/**
 * Column alignment
 */
export type ColumnAlignment = 'left' | 'center' | 'right';

/**
 * Column data format
 */
export type ColumnFormat = 'text' | 'number' | 'currency' | 'date' | 'datetime' | 'boolean' | 'percentage';

/**
 * Request to confirm an upload completed successfully
 */
export type ConfirmUploadRequest = {
    /**
     * Optional: ETag from S3 response for verification
     */
    etag?: string;
};

/**
 * Discount coupon
 *
 * Represents a promotional discount code.
 */
export type Coupon = {
    /**
     * Unique coupon identifier (format: coupon_abc123)
     */
    id: string;
    /**
     * Coupon code that users enter
     */
    code: string;
    /**
     * Internal name for reference
     */
    name?: string;
    /**
     * Discount type
     */
    type: CouponType;
    /**
     * Percentage off (for percent type, 1-100)
     */
    percentOff?: number;
    /**
     * Amount off in cents (for fixed type)
     */
    amountOffCents?: number;
    /**
     * Trial extension in days (for trial_extension type)
     */
    trialExtensionDays?: number;
    /**
     * Whether coupon is active
     */
    isActive: boolean;
    /**
     * When coupon becomes valid
     */
    startsAt?: string;
    /**
     * When coupon expires
     */
    expiresAt?: string;
    /**
     * Maximum number of redemptions (null = unlimited)
     */
    maxRedemptions?: number;
    /**
     * Current redemption count
     */
    currentRedemptions: number;
    /**
     * Only valid for first-time customers
     */
    firstTimeOnly: boolean;
    /**
     * Comma-separated plan IDs (null = all plans)
     */
    planIds?: string;
    /**
     * When the coupon was created
     */
    createdAt: string;
    /**
     * When the coupon was last updated
     */
    updatedAt: string;
};

/**
 * Coupon list response
 */
export type CouponListResponse = {
    data: Array<Coupon>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Coupon response
 */
export type CouponResponse = {
    data: Coupon;
    meta: ResponseMeta;
};

/**
 * Coupon discount type
 */
export type CouponType = 'percent' | 'fixed' | 'trial_extension';

/**
 * Request body for creating an announcement
 */
export type CreateAnnouncementRequest = {
    /**
     * Organization ID (null for system-wide announcements visible to all organizations)
     */
    orgId?: string | null;
    /**
     * Announcement title
     */
    title: string;
    /**
     * Announcement content (supports Markdown for links, formatting, and equations)
     */
    content: string;
    /**
     * Optional link URL
     */
    linkUrl?: string;
    /**
     * Optional link text
     */
    linkText?: string;
    /**
     * Priority level (default: info)
     */
    priority?: AnnouncementPriority;
    /**
     * Scope (default: organization)
     */
    scope?: AnnouncementScope;
    /**
     * Target roles (empty means all roles)
     */
    targetRoles?: Array<AnnouncementTargetRole>;
    /**
     * Whether users can dismiss (default: true)
     */
    isDismissible?: boolean;
    /**
     * Scheduled publish date/time (default: now)
     */
    publishAt?: string;
    /**
     * Optional expiration date/time
     */
    expiresAt?: string;
    /**
     * Whether announcement is active (default: true)
     */
    isActive?: boolean;
};

/**
 * Create backup request
 */
export type CreateBackupRequest = {
    /**
     * Optional description
     */
    description?: string;
    /**
     * Include storage files in backup
     */
    includeFiles?: boolean;
    /**
     * Encrypt the backup
     */
    encrypt?: boolean;
    /**
     * Password for encryption (required if encrypt is true)
     */
    password?: string;
};

/**
 * Create coupon request
 */
export type CreateCouponRequest = {
    /**
     * Coupon code (uppercase recommended)
     */
    code: string;
    /**
     * Internal name
     */
    name?: string;
    /**
     * Discount type
     */
    type: CouponType;
    /**
     * Percentage off (required if type=percent)
     */
    percentOff?: number;
    /**
     * Amount off in cents (required if type=fixed)
     */
    amountOffCents?: number;
    /**
     * Trial extension days (required if type=trial_extension)
     */
    trialExtensionDays?: number;
    /**
     * Is active
     */
    isActive?: boolean;
    /**
     * Validity start
     */
    startsAt?: string;
    /**
     * Validity end
     */
    expiresAt?: string;
    /**
     * Max redemptions
     */
    maxRedemptions?: number;
    /**
     * First-time only
     */
    firstTimeOnly?: boolean;
    /**
     * Plan IDs (comma-separated)
     */
    planIds?: string;
};

/**
 * Request body for creating a new comment
 */
export type CreateExampleCommentRequest = {
    /**
     * Comment content
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
};

/**
 * Request body for creating a new post
 */
export type CreateExamplePostRequest = {
    /**
     * Post title
     */
    title: string;
    /**
     * Post content (supports markdown)
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Post category
     */
    category?: string;
    /**
     * Post tags
     */
    tags?: Array<string>;
    /**
     * Whether the post is featured
     */
    isFeatured?: boolean;
    /**
     * Scheduled publish date
     */
    publishDate?: string;
    /**
     * Cover image file ID
     */
    coverImageId?: string;
    /**
     * Attachment file ID
     */
    attachmentFileId?: string;
    /**
     * Gallery images (file IDs)
     */
    galleryImageIds?: Array<string>;
    /**
     * Attached documents (file IDs)
     */
    documentFileIds?: Array<string>;
    /**
     * Post status (default: draft)
     */
    status?: ExamplePostStatus;
};

/**
 * Request to create a new job
 */
export type CreateJobRequest = {
    /**
     * Job type (e.g., "report", "import", "export", "my-custom-job")
     */
    type: string;
    /**
     * Job input parameters (job-specific)
     */
    input?: {
        [key: string]: unknown;
    };
    /**
     * Job metadata (references, format, etc.)
     */
    metadata?: JobMetadata;
};

/**
 * Create a new legal document
 */
export type CreateLegalDocumentRequest = {
    /**
     * Document type
     */
    type: LegalDocumentType;
    /**
     * URL-friendly slug (auto-generated if not provided)
     */
    slug?: string;
    /**
     * Locale/language code
     */
    locale?: string;
    /**
     * Initial version title
     */
    title: string;
    /**
     * Initial version content
     */
    content: string;
};

/**
 * Create a new version of a document
 */
export type CreateLegalDocumentVersionRequest = {
    /**
     * Version title
     */
    title: string;
    /**
     * Full content
     */
    content: string;
    /**
     * Summary of changes
     */
    changelog?: string;
    /**
     * Whether users must re-accept
     */
    requiresReAcceptance?: boolean;
};

/**
 * Create subscription plan request
 */
export type CreatePlanRequest = {
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Plan name
     */
    name: string;
    /**
     * Plan slug
     */
    slug: string;
    /**
     * Plan description
     */
    description?: string;
    /**
     * Price in cents
     */
    priceCents: number;
    /**
     * Currency code
     */
    currency?: string;
    /**
     * Billing period
     */
    billingPeriod: PlanBillingPeriod;
    /**
     * Trial days
     */
    trialDays?: number;
    /**
     * Features
     */
    features?: PlanFeatures;
    /**
     * Metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Sort order
     */
    sortOrder?: number;
    /**
     * Visibility
     */
    visibility?: PlanVisibility;
    /**
     * Is active
     */
    isActive?: boolean;
    /**
     * Is popular
     */
    isPopular?: boolean;
};

/**
 * Request body for creating a new report template
 */
export type CreateReportTemplateRequest = {
    /**
     * Template name
     */
    name: string;
    /**
     * Template description
     */
    description?: string;
    /**
     * Output format
     */
    format: ReportFormat;
    /**
     * Template content (Eta template string)
     */
    templateContent: string;
    /**
     * Format-specific options
     */
    options?: ReportOptions;
    /**
     * Data source configuration
     */
    dataSource?: DataSourceConfig;
    /**
     * Column definitions
     */
    columns: Array<ReportColumnConfig>;
    /**
     * Whether template is visible to all org members (default: false)
     */
    isPublic?: boolean;
};

/**
 * Request to create a custom role
 */
export type CreateRoleRequest = {
    /**
     * Role name
     */
    name: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions to grant
     */
    permissions: Array<PermissionInput>;
};

/**
 * Request body for creating a scheduled job
 */
export type CreateScheduledJobRequest = {
    /**
     * Job type to run
     */
    jobType: string;
    /**
     * Job configuration passed to the job handler
     */
    jobConfig?: {
        [key: string]: unknown;
    };
    /**
     * Schedule name
     */
    name: string;
    /**
     * Schedule description
     */
    description?: string;
    /**
     * Schedule frequency
     */
    frequency: ScheduleFrequency;
    /**
     * Cron expression (required when frequency is custom)
     */
    cronExpression?: string;
    /**
     * Day of week (for weekly frequency)
     */
    dayOfWeek?: DayOfWeek;
    /**
     * Day of month (for monthly frequency)
     */
    dayOfMonth?: number;
    /**
     * Hour to run (0-23)
     */
    hour?: number;
    /**
     * Minute to run (0-59)
     */
    minute?: number;
    /**
     * Timezone for scheduling
     */
    timezone?: string;
    /**
     * Start date for the schedule
     */
    startDate?: string;
    /**
     * End date for the schedule
     */
    endDate?: string;
    /**
     * Delivery method for job results
     */
    deliveryMethod?: JobDeliveryMethod;
    /**
     * Delivery configuration
     */
    deliveryConfig?: DeliveryConfig;
    /**
     * Whether the schedule is active (default: true)
     */
    isActive?: boolean;
};

/**
 * Create subscription request
 */
export type CreateSubscriptionRequest = {
    /**
     * Plan ID to subscribe to
     */
    planId: string;
    /**
     * Optional coupon code to apply
     */
    couponCode?: string;
    /**
     * Payment method ID (if already exists)
     */
    paymentMethodId?: string;
    /**
     * Return URL after payment setup
     */
    returnUrl?: string;
};

/**
 * Subscription creation response (with payment link)
 */
export type CreateSubscriptionResponse = {
    data: Subscription;
    /**
     * Payment method linking URL (if payment setup required)
     */
    linkingUrl?: string;
    meta: ResponseMeta;
};

/**
 * Request to create a webhook
 */
export type CreateWebhookRequest = {
    /**
     * URL to receive webhook payloads (must be HTTPS)
     */
    url: string;
    /**
     * Human-readable name
     */
    name?: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Event types to subscribe to
     */
    events: Array<string>;
    /**
     * Whether the webhook is active (default: true)
     */
    isActive?: boolean;
};

/**
 * Cursor-based pagination for large datasets or real-time data
 */
export type CursorPagination = {
    /**
     * Maximum items returned per page
     */
    limit: number;
    /**
     * Whether there is a next page
     */
    hasNext: boolean;
    /**
     * Cursor for fetching the next page (null if no more pages)
     */
    nextCursor: string | null;
    /**
     * Cursor for fetching the previous page (null if on first page)
     */
    previousCursor: string | null;
};

/**
 * Data source configuration for report templates
 */
export type DataSourceConfig = {
    /**
     * Data source type
     */
    type: 'query' | 'api' | 'custom';
    /**
     * SQL query or API endpoint path
     */
    source?: string;
    /**
     * Default parameters for the query/API
     */
    defaultParams?: {
        [key: string]: unknown;
    };
};

/**
 * Data source configuration for report templates
 */
export type DataSourceConfigUpdate = {
    /**
     * Data source type
     */
    type?: 'query' | 'api' | 'custom';
    /**
     * SQL query or API endpoint path
     */
    source?: string;
    /**
     * Default parameters for the query/API
     */
    defaultParams?: {
        [key: string]: unknown;
    };
};

/**
 * Day of week for weekly schedules
 */
export type DayOfWeek = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

/**
 * Combined delivery configuration
 */
export type DeliveryConfig = {
    /**
     * Email delivery settings (when deliveryMethod is email)
     */
    email?: EmailDeliveryConfig;
    /**
     * Webhook delivery settings (when deliveryMethod is webhook)
     */
    webhook?: WebhookDeliveryConfig;
    /**
     * Storage delivery settings (when deliveryMethod is storage)
     */
    storage?: StorageDeliveryConfig;
};

/**
 * Combined delivery configuration
 */
export type DeliveryConfigUpdate = {
    /**
     * Email delivery settings (when deliveryMethod is email)
     */
    email?: EmailDeliveryConfigUpdate;
    /**
     * Webhook delivery settings (when deliveryMethod is webhook)
     */
    webhook?: WebhookDeliveryConfigUpdate;
    /**
     * Storage delivery settings (when deliveryMethod is storage)
     */
    storage?: StorageDeliveryConfigUpdate;
};

/**
 * Dismiss announcement response
 */
export type DismissAnnouncementResponse = {
    data: {
        /**
         * Announcement ID
         */
        announcementId: string;
        /**
         * Timestamp when dismissed
         */
        dismissedAt: string;
    };
    meta: ResponseMeta;
};

/**
 * Email delivery configuration
 */
export type EmailDeliveryConfig = {
    /**
     * Email recipients
     */
    recipients: Array<string>;
    /**
     * Email subject (supports template variables)
     */
    subject?: string;
    /**
     * Email body text (supports template variables)
     */
    body?: string;
    /**
     * CC recipients
     */
    cc?: Array<string>;
    /**
     * BCC recipients
     */
    bcc?: Array<string>;
};

/**
 * Email delivery configuration
 */
export type EmailDeliveryConfigUpdate = {
    /**
     * Email recipients
     */
    recipients?: Array<string>;
    /**
     * Email subject (supports template variables)
     */
    subject?: string;
    /**
     * Email body text (supports template variables)
     */
    body?: string;
    /**
     * CC recipients
     */
    cc?: Array<string>;
    /**
     * BCC recipients
     */
    bcc?: Array<string>;
};

/**
 * Standard error object
 */
export type Error = {
    /**
     * Machine-readable error code
     */
    code: string;
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Array of detailed error information (e.g., validation errors)
     */
    details?: Array<ErrorDetail>;
    /**
     * Request ID for tracking and debugging
     */
    requestId: string;
    /**
     * URL to documentation about this error (optional)
     */
    documentationUrl?: string;
};

/**
 * Detailed error information for a specific field or validation
 */
export type ErrorDetail = {
    /**
     * The field that caused the error (for validation errors)
     */
    field: string;
    /**
     * Specific error code for this detail
     */
    code: string;
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Additional metadata about the error
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Standard error response envelope
 */
export type ErrorResponse = {
    /**
     * The error object
     */
    error: Error;
};

/**
 * ExampleComment resource model (nested under ExamplePost)
 *
 * Demonstrates:
 * - Nested sub-resource pattern (belongs to a post)
 * - Multi-tenant scoping (orgId)
 * - Soft delete with restore capability
 */
export type ExampleComment = {
    /**
     * Unique comment identifier (format: cmt_{randomString})
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    orgId: string;
    /**
     * Parent post ID
     */
    postId: string;
    /**
     * Comment content
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Whether the comment is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the comment was soft deleted
     */
    deletedAt?: string;
    /**
     * User ID who deleted this comment
     */
    deletedBy?: string;
    /**
     * Timestamp when the comment was created
     */
    createdAt: string;
    /**
     * Timestamp when the comment was last updated
     */
    updatedAt: string;
};

/**
 * Comment collection response
 */
export type ExampleCommentListResponse = {
    data: Array<ExampleComment>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single comment response
 */
export type ExampleCommentResponse = {
    data: ExampleComment;
    meta: ResponseMeta;
};

/**
 * ExamplePost resource model
 *
 * Demonstrates a typical content resource with:
 * - Multi-tenant scoping (orgId)
 * - Status workflow (draft → published → archived)
 * - Soft delete with restore capability
 */
export type ExamplePost = {
    /**
     * Unique post identifier (format: post_{randomString})
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    orgId: string;
    /**
     * Post title
     */
    title: string;
    /**
     * Post content (supports markdown)
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Post category
     */
    category?: string;
    /**
     * Post tags
     */
    tags: Array<string>;
    /**
     * Whether the post is featured
     */
    isFeatured: boolean;
    /**
     * Scheduled publish date
     */
    publishDate?: string;
    /**
     * Cover image file ID
     */
    coverImageId?: string;
    /**
     * Attachment file ID
     */
    attachmentFileId?: string;
    /**
     * Gallery images (file IDs)
     */
    galleryImageIds: Array<string>;
    /**
     * Attached documents (file IDs)
     */
    documentFileIds: Array<string>;
    /**
     * Post status
     */
    status: ExamplePostStatus;
    /**
     * Timestamp when the post was published (null if not published)
     */
    publishedAt?: string;
    /**
     * Whether the post is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the post was soft deleted (null if not deleted)
     */
    deletedAt?: string;
    /**
     * User ID who deleted this post (null if not deleted)
     */
    deletedBy?: string;
    /**
     * Timestamp when the post was created
     */
    createdAt: string;
    /**
     * Timestamp when the post was last updated
     */
    updatedAt: string;
};

/**
 * Post collection response (cursor-based)
 *
 * Used for streaming/real-time scenarios or large datasets
 */
export type ExamplePostCursorListResponse = {
    data: Array<ExamplePost>;
    pagination: CursorPagination;
    meta: ResponseMeta;
};

/**
 * Post collection response (page-based)
 */
export type ExamplePostListResponse = {
    data: Array<ExamplePost>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single post response
 */
export type ExamplePostResponse = {
    data: ExamplePost;
    meta: ResponseMeta;
};

/**
 * Post status enum
 */
export type ExamplePostStatus = 'draft' | 'published' | 'archived';

/**
 * Export acceptances request (for compliance)
 */
export type ExportAcceptancesRequest = {
    /**
     * Document ID to export acceptances for
     */
    documentId?: string;
    /**
     * Version ID to export acceptances for
     */
    versionId?: string;
    /**
     * Start date filter
     */
    startDate?: string;
    /**
     * End date filter
     */
    endDate?: string;
    /**
     * Export format
     */
    format?: 'csv' | 'json';
};

/**
 * Request body for triggering an export
 */
export type ExportRequest = {
    /**
     * Report template ID (optional, for template-based exports)
     */
    templateId?: string;
    /**
     * Output format (required if no templateId)
     */
    format?: ReportFormat;
    /**
     * Data to export (for client-side data)
     */
    data?: Array<unknown>;
    /**
     * Column definitions (required if no templateId)
     */
    columns?: Array<ReportColumnConfig>;
    /**
     * Format-specific options
     */
    options?: ReportOptions;
    /**
     * Filters to apply to data source
     */
    filters?: {
        [key: string]: unknown;
    };
    /**
     * Sort configuration
     */
    sort?: Array<{
        field: string;
        direction: 'asc' | 'desc';
    }>;
    /**
     * Additional parameters for template
     */
    parameters?: {
        [key: string]: unknown;
    };
    /**
     * Export only selected rows (by ID)
     */
    selectedIds?: Array<string>;
    /**
     * Use async processing (returns job ID)
     */
    async?: boolean;
};

/**
 * File resource model
 *
 * Represents an uploaded file with metadata, security status, and access info.
 */
export type File = {
    /**
     * Unique file identifier (format: file_abc123)
     */
    id: string;
    /**
     * Original filename (sanitized)
     */
    filename: string;
    /**
     * File size in bytes
     */
    size: number;
    /**
     * MIME type (verified via magic bytes, not client-provided)
     */
    mimeType: string;
    /**
     * Inferred file kind
     */
    kind: FileKind;
    /**
     * Storage path (internal, not exposed to clients in production)
     */
    storagePath: string;
    /**
     * Signed URL for file access (time-limited)
     */
    url?: string;
    /**
     * File metadata (user-provided)
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     * User ID who uploaded the file
     */
    uploadedBy: string;
    /**
     * Timestamp when the file was uploaded
     */
    uploadedAt: string;
    /**
     * Virus scan status
     */
    virusScanStatus: VirusScanStatus;
    /**
     * Timestamp when virus scan completed
     */
    virusScanCompletedAt?: string;
    /**
     * Access level
     */
    access: FileAccess;
    /**
     * File lifecycle status
     */
    status: FileStatus;
    /**
     * Whether the file is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the file was deleted
     */
    deletedAt?: string;
    /**
     * User ID who deleted this file
     */
    deletedBy?: string;
};

/**
 * File access level
 */
export type FileAccess = 'private' | 'public';

/**
 * File deletion response
 */
export type FileDeleteResponse = {
    data: {
        /**
         * ID of the deleted file
         */
        id: string;
        /**
         * When the file was deleted
         */
        deletedAt: string;
        /**
         * Who deleted the file
         */
        deletedBy: string;
    };
    meta: ResponseMeta;
};

/**
 * File kind
 */
export type FileKind = 'image' | 'video' | 'audio' | 'document' | 'archive' | 'other';

/**
 * File list response with pagination
 */
export type FileListResponse = {
    data: Array<File>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single file response
 */
export type FileResponse = {
    data: File;
    meta: ResponseMeta;
};

/**
 * File status
 */
export type FileStatus = 'temporary' | 'persistent';

/**
 * Request to initiate a presigned URL upload
 */
export type InitiateUploadRequest = {
    /**
     * Original filename
     */
    filename: string;
    /**
     * MIME type of the file
     */
    contentType: string;
    /**
     * File size in bytes
     */
    size: number;
    /**
     * Optional metadata
     */
    metadata?: {
        [key: string]: string;
    };
};

/**
 * Response with presigned URL for direct upload to storage
 */
export type InitiateUploadResponse = {
    data: {
        /**
         * Upload ID for confirmation step
         */
        uploadId: string;
        /**
         * Presigned URL to upload to
         */
        presignedUrl: string;
        /**
         * HTTP method to use
         */
        method: 'PUT';
        /**
         * Required headers for the upload
         */
        headers: {
            [key: string]: string;
        };
        /**
         * When the presigned URL expires
         */
        expiresAt: string;
        /**
         * Maximum allowed file size
         */
        maxSize: number;
    };
    meta: ResponseMeta;
};

/**
 * Async job resource
 *
 * Represents a long-running operation that can be polled for status.
 * Unified job system with pg-boss queue integration.
 */
export type Job = {
    /**
     * Unique job identifier (format: job_abc123)
     */
    jobId: string;
    /**
     * Tenant this job belongs to
     */
    tenantId: string;
    /**
     * Type of operation (e.g., "report", "import", "export")
     */
    type: string;
    /**
     * Current job status
     */
    status: JobStatus;
    /**
     * Progress percentage (0-100, if available)
     */
    progress?: number;
    /**
     * Human-readable status message
     */
    message?: string;
    /**
     * Total items to process
     */
    totalItems?: number;
    /**
     * Items processed so far
     */
    processedItems?: number;
    /**
     * Job input parameters
     */
    input?: {
        [key: string]: unknown;
    };
    /**
     * Job output/result data (when completed)
     */
    output?: {
        [key: string]: unknown;
    };
    /**
     * Job metadata (references, format, etc.)
     */
    metadata?: JobMetadata;
    /**
     * Error details (when failed)
     */
    error?: JobError;
    /**
     * Who initiated the job
     */
    createdBy: string;
    /**
     * When the job was created
     */
    createdAt: string;
    /**
     * When the job started processing
     */
    startedAt?: string;
    /**
     * When the job completed (success or failure)
     */
    completedAt?: string;
    /**
     * Estimated completion time (if available)
     */
    estimatedCompletion?: string;
};

/**
 * Generic job delivery method (extends DeliveryMethod with "none" option)
 */
export type JobDeliveryMethod = 'email' | 'download' | 'webhook' | 'storage' | 'none';

/**
 * Job error details
 */
export type JobError = {
    /**
     * Error code
     */
    code: string;
    /**
     * Error message
     */
    message: string;
    /**
     * Whether the error is retryable
     */
    retryable?: boolean;
};

/**
 * Job list response
 */
export type JobListResponse = {
    data: Array<Job>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Job metadata for type-specific references
 */
export type JobMetadata = {
    /**
     * Template ID (for report jobs)
     */
    templateId?: string;
    /**
     * Scheduled report ID (for scheduled report jobs)
     */
    scheduledReportId?: string;
    /**
     * Format (for report jobs)
     */
    format?: string;
    /**
     * Parent job ID (for retried jobs)
     */
    parentJobId?: string;
    /**
     * Retry count
     */
    retryCount?: number;
};

/**
 * Job status response
 */
export type JobResponse = {
    data: Job;
    meta: ResponseMeta;
};

/**
 * Job status
 */
export type JobStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';

/**
 * Job type information for UI
 *
 * Describes a registered job handler's metadata for building
 * schedule configuration forms.
 */
export type JobTypeInfo = {
    /**
     * Job type identifier
     */
    type: string;
    /**
     * Human-readable label
     */
    label: string;
    /**
     * Description of what the job does
     */
    description: string;
    /**
     * JSON schema description for configuration
     */
    configSchema?: string;
    /**
     * Example configuration
     */
    exampleConfig?: {
        [key: string]: unknown;
    };
};

/**
 * Job types list response
 */
export type JobTypesListResponse = {
    data: Array<JobTypeInfo>;
    meta: ResponseMeta;
};

/**
 * Legal document metadata (container for versions)
 */
export type LegalDocument = {
    /**
     * Unique document identifier
     */
    id: string;
    /**
     * Document type
     */
    type: LegalDocumentType;
    /**
     * URL-friendly slug
     */
    slug: string;
    /**
     * Locale/language code (ISO 639-1)
     */
    locale: string;
    /**
     * Current status
     */
    status: LegalDocumentStatus;
    /**
     * Currently active version ID (if published)
     */
    activeVersionId?: string;
    /**
     * User who created this document
     */
    createdBy: string;
    /**
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Last update timestamp
     */
    updatedAt: string;
    /**
     * Soft delete timestamp
     */
    deletedAt?: string;
};

/**
 * User acceptance record for compliance tracking
 */
export type LegalDocumentAcceptance = {
    /**
     * Unique acceptance identifier
     */
    id: string;
    /**
     * User who accepted
     */
    userId: string;
    /**
     * Version that was accepted
     */
    versionId: string;
    /**
     * Document ID (denormalized for queries)
     */
    documentId: string;
    /**
     * Document type (denormalized for queries)
     */
    documentType: LegalDocumentType;
    /**
     * When the user accepted
     */
    acceptedAt: string;
    /**
     * IP address at time of acceptance
     */
    ipAddress?: string;
    /**
     * User agent string at time of acceptance
     */
    userAgent?: string;
};

/**
 * Acceptance list response
 */
export type LegalDocumentAcceptanceListResponse = {
    data: Array<LegalDocumentAcceptance>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Acceptance response
 */
export type LegalDocumentAcceptanceResponse = {
    data: LegalDocumentAcceptance;
    meta: ResponseMeta;
};

/**
 * Audit log entry for document changes
 */
export type LegalDocumentAuditLog = {
    /**
     * Unique log identifier
     */
    id: string;
    /**
     * Document ID
     */
    documentId: string;
    /**
     * Version ID (if applicable)
     */
    versionId?: string;
    /**
     * Action performed
     */
    action: string;
    /**
     * User who performed the action
     */
    actorId: string;
    /**
     * Actor name (denormalized)
     */
    actorName?: string;
    /**
     * JSON of changes made
     */
    changes?: string;
    /**
     * Timestamp
     */
    createdAt: string;
};

/**
 * Audit log list response
 */
export type LegalDocumentAuditLogListResponse = {
    data: Array<LegalDocumentAuditLog>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Legal document list response
 */
export type LegalDocumentListResponse = {
    data: Array<LegalDocumentWithVersion>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single legal document response
 */
export type LegalDocumentResponse = {
    data: LegalDocument;
    meta: ResponseMeta;
};

/**
 * Status of a legal document or version
 */
export type LegalDocumentStatus = 'draft' | 'published' | 'archived';

/**
 * Type of legal document
 */
export type LegalDocumentType = 'terms_of_service' | 'privacy_policy' | 'cookie_policy' | 'eula' | 'community_guidelines';

/**
 * Legal document version with content
 */
export type LegalDocumentVersion = {
    /**
     * Unique version identifier
     */
    id: string;
    /**
     * Parent document ID
     */
    documentId: string;
    /**
     * Version number (semantic: 1, 2, 3...)
     */
    version: number;
    /**
     * Version title
     */
    title: string;
    /**
     * Full content (Markdown supported)
     */
    content: string;
    /**
     * Summary of changes from previous version
     */
    changelog?: string;
    /**
     * Version status
     */
    status: LegalDocumentStatus;
    /**
     * When this version was published
     */
    publishedAt?: string;
    /**
     * Scheduled publish time (for future publishing)
     */
    scheduledAt?: string;
    /**
     * Whether users must re-accept when this version is published
     */
    requiresReAcceptance: boolean;
    /**
     * User who created this version
     */
    createdBy: string;
    /**
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Last update timestamp
     */
    updatedAt: string;
    /**
     * Archive timestamp
     */
    archivedAt?: string;
};

/**
 * Version list response
 */
export type LegalDocumentVersionListResponse = {
    data: Array<LegalDocumentVersion>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single version response
 */
export type LegalDocumentVersionResponse = {
    data: LegalDocumentVersion;
    meta: ResponseMeta;
};

/**
 * Legal document with active version details
 */
export type LegalDocumentWithVersion = {
    /**
     * Unique document identifier
     */
    id: string;
    /**
     * Document type
     */
    type: LegalDocumentType;
    /**
     * URL-friendly slug
     */
    slug: string;
    /**
     * Locale/language code (ISO 639-1)
     */
    locale: string;
    /**
     * Current status
     */
    status: LegalDocumentStatus;
    /**
     * Currently active version ID (if published)
     */
    activeVersionId?: string;
    /**
     * User who created this document
     */
    createdBy: string;
    /**
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Last update timestamp
     */
    updatedAt: string;
    /**
     * Soft delete timestamp
     */
    deletedAt?: string;
    /**
     * Active version details
     */
    activeVersion?: LegalDocumentVersion;
    /**
     * Total version count
     */
    versionCount?: number;
};

/**
 * Document with version response
 */
export type LegalDocumentWithVersionResponse = {
    data: LegalDocumentWithVersion;
    meta: ResponseMeta;
};

/**
 * Mark all as read response
 */
export type MarkAllReadResponse = {
    data: {
        /**
         * Number of notifications marked as read
         */
        markedCount: number;
    };
    meta: ResponseMeta;
};

/**
 * Mark as read response
 */
export type MarkReadResponse = {
    data: {
        /**
         * Announcement ID
         */
        announcementId: string;
        /**
         * Timestamp when read
         */
        readAt: string;
    };
    meta: ResponseMeta;
};

/**
 * Mark as viewed response
 */
export type MarkViewedResponse = {
    data: {
        /**
         * Announcement ID
         */
        announcementId: string;
        /**
         * Timestamp when viewed
         */
        viewedAt: string;
    };
    meta: ResponseMeta;
};

/**
 * Version lifecycle status
 */
export type MigrationStatus = 'current' | 'deprecated' | 'sunset';

/**
 * Migration status for an API version
 */
export type MigrationStatusResponse = {
    /**
     * API version (e.g., "v1")
     */
    version: string;
    /**
     * Version lifecycle status
     */
    status: MigrationStatus;
    /**
     * ISO 8601 date when this version will be removed (if deprecated)
     */
    sunsetDate?: string;
    /**
     * Days remaining until sunset (if deprecated)
     */
    daysUntilSunset?: number;
    /**
     * Version to migrate to (if deprecated)
     */
    replacementVersion?: string;
    /**
     * URL to the migration guide
     */
    migrationGuideUrl?: string;
    /**
     * List of breaking changes in the replacement version
     */
    breakingChanges?: Array<string>;
    /**
     * Steps to complete the migration
     */
    migrationChecklist?: Array<string>;
};

/**
 * User's acceptance history
 */
export type MyAcceptancesResponse = {
    data: {
        /**
         * User ID
         */
        userId: string;
        /**
         * List of acceptances
         */
        acceptances: Array<LegalDocumentAcceptance>;
    };
    meta: ResponseMeta;
};

/**
 * Notification resource model
 */
export type Notification = {
    /**
     * Unique notification identifier
     */
    id: string;
    /**
     * User ID who should receive this notification
     */
    userId?: string;
    /**
     * Notification channel
     */
    channel: NotificationChannel;
    /**
     * Notification category
     */
    category: NotificationCategory;
    /**
     * Notification priority
     */
    priority: NotificationPriority;
    /**
     * Current notification status
     */
    status: NotificationStatus;
    /**
     * Email address this was sent to
     */
    recipientEmail?: string;
    /**
     * Phone number this was sent to
     */
    recipientPhone?: string;
    /**
     * Telegram ID this was sent to
     */
    recipientTelegramId?: string;
    /**
     * Template ID used (if any)
     */
    templateId?: string;
    /**
     * Subject line (for email)
     */
    subject?: string;
    /**
     * Plain text body
     */
    body?: string;
    /**
     * HTML body (for email)
     */
    bodyHtml?: string;
    /**
     * Template data used for rendering
     */
    templateData?: {
        [key: string]: unknown;
    };
    /**
     * Campaign ID for bulk sends
     */
    campaignId?: string;
    /**
     * Provider used to send (e.g., "nodemailer", "twilio")
     */
    provider?: string;
    /**
     * Provider's message ID
     */
    providerMessageId?: string;
    /**
     * Timestamp when notification was sent
     */
    sentAt?: string;
    /**
     * Timestamp when notification was delivered
     */
    deliveredAt?: string;
    /**
     * Timestamp when notification failed
     */
    failedAt?: string;
    /**
     * Timestamp when notification was read by user
     */
    readAt?: string;
    /**
     * Timestamp when notification was soft deleted
     */
    deletedAt?: string;
    /**
     * Number of retry attempts
     */
    retryCount: number;
    /**
     * Maximum retry attempts allowed
     */
    maxRetries: number;
    /**
     * Next retry timestamp
     */
    nextRetryAt?: string;
    /**
     * Status message (error details if failed)
     */
    statusMessage?: string;
    /**
     * Metadata for custom data
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Timestamp when notification was created
     */
    createdAt: string;
    /**
     * Timestamp when notification was last updated
     */
    updatedAt: string;
};

/**
 * Notification category enum
 */
export type NotificationCategory = 'transactional' | 'marketing' | 'security' | 'system';

/**
 * Notification channel enum
 */
export type NotificationChannel = 'email' | 'sms' | 'whatsapp' | 'telegram' | 'push' | 'none';

/**
 * Notification collection response
 */
export type NotificationListResponse = {
    data: Array<Notification>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Notification preferences model
 */
export type NotificationPreferences = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Email notifications enabled
     */
    emailEnabled: boolean;
    /**
     * SMS notifications enabled
     */
    smsEnabled: boolean;
    /**
     * WhatsApp notifications enabled
     */
    whatsappEnabled: boolean;
    /**
     * Telegram notifications enabled
     */
    telegramEnabled: boolean;
    /**
     * Push notifications enabled
     */
    pushEnabled: boolean;
    /**
     * Marketing notifications enabled
     */
    marketingEnabled: boolean;
    /**
     * Transactional notifications enabled
     */
    transactionalEnabled: boolean;
    /**
     * Security notifications enabled
     */
    securityEnabled: boolean;
    /**
     * System notifications enabled
     */
    systemEnabled: boolean;
    /**
     * Preferred email address
     */
    preferredEmail?: string | null;
    /**
     * Preferred phone number
     */
    preferredPhone?: string | null;
    /**
     * Preferred Telegram ID
     */
    preferredTelegramId?: string | null;
    /**
     * Quiet hours enabled
     */
    quietHoursEnabled: boolean;
    /**
     * Quiet hours start time (HH:mm format)
     */
    quietHoursStart?: string | null;
    /**
     * Quiet hours end time (HH:mm format)
     */
    quietHoursEnd?: string | null;
    /**
     * Quiet hours timezone (IANA format)
     */
    quietHoursTimezone?: string | null;
    /**
     * Timestamp when created
     */
    createdAt: string;
    /**
     * Timestamp when last updated
     */
    updatedAt: string;
};

/**
 * Notification preferences response
 */
export type NotificationPreferencesResponse = {
    data: NotificationPreferences;
    meta?: ResponseMeta;
};

/**
 * Notification priority enum
 */
export type NotificationPriority = 'urgent' | 'high' | 'normal' | 'low';

/**
 * Notification recipient information
 */
export type NotificationRecipient = {
    /**
     * Email address (required for email channel)
     */
    email?: string;
    /**
     * Phone number in E.164 format (required for SMS/WhatsApp)
     */
    phone?: string;
    /**
     * Telegram chat ID (required for Telegram channel)
     */
    telegramId?: string;
};

/**
 * Single notification response
 */
export type NotificationResponse = {
    data: Notification;
    meta: ResponseMeta;
};

/**
 * Notification status enum
 */
export type NotificationStatus = 'pending' | 'queued' | 'processing' | 'sent' | 'delivered' | 'failed' | 'bounced';

/**
 * Page-based pagination metadata for collection responses
 */
export type Pagination = {
    /**
     * Current page number (1-indexed)
     */
    page: number;
    /**
     * Number of items per page
     */
    pageSize: number;
    /**
     * Total number of pages
     */
    totalPages: number;
    /**
     * Total number of items across all pages
     */
    totalCount: number;
    /**
     * Whether there is a next page
     */
    hasNext: boolean;
    /**
     * Whether there is a previous page
     */
    hasPrevious: boolean;
    /**
     * Navigation links for pagination
     */
    links?: PaginationLinks;
    /**
     * Original requested page size (included if pageSize was capped)
     */
    requestedPageSize?: number;
};

/**
 * Pagination links for navigating through paginated results
 */
export type PaginationLinks = {
    /**
     * URL for the first page
     */
    first: string | null;
    /**
     * URL for the previous page (null if on first page)
     */
    previous: string | null;
    /**
     * URL for the next page (null if on last page)
     */
    next: string | null;
    /**
     * URL for the last page
     */
    last: string | null;
};

/**
 * Check for pending acceptances
 */
export type PendingAcceptancesResponse = {
    data: {
        /**
         * Whether there are documents requiring acceptance
         */
        hasPending: boolean;
        /**
         * List of documents requiring acceptance
         */
        pendingDocuments: Array<LegalDocumentWithVersion>;
    };
    meta: ResponseMeta;
};

/**
 * Permission definition
 *
 * Permissions define what actions can be performed on resources.
 * They support allow/deny effects and optional conditions.
 */
export type Permission = {
    /**
     * Resource identifier (e.g., "users", "invoices", "settings")
     */
    resource: string;
    /**
     * Action to perform on the resource
     */
    action: PermissionAction | string;
    /**
     * Whether to allow or deny this action
     */
    effect: PermissionEffect;
    /**
     * Optional condition for when this permission applies
     */
    condition?: PermissionCondition;
};

/**
 * Permission actions
 */
export type PermissionAction = 'read' | 'create' | 'update' | 'delete' | 'manage' | '*';

/**
 * Permission condition - when the permission applies
 *
 * Conditions enable dynamic, context-aware access control.
 */
export type PermissionCondition = '' | 'owner' | 'shared';

/**
 * Permission effect - whether to allow or deny access
 *
 * When a user has multiple roles, permissions are combined:
 * - If ANY role denies an action, it is denied (deny wins)
 * - If no role denies and ANY role allows, it is allowed
 * - If no rules match, access is denied (default deny)
 */
export type PermissionEffect = 'allow' | 'deny';

/**
 * Permission input for creating/updating roles
 */
export type PermissionInput = {
    /**
     * Resource identifier
     */
    resource: string;
    /**
     * Action to perform
     */
    action: string;
    /**
     * Effect (defaults to "allow" if not specified)
     */
    effect?: PermissionEffect;
    /**
     * Optional condition
     */
    condition?: PermissionCondition;
};

/**
 * Billing period for subscription plans
 */
export type PlanBillingPeriod = 'monthly' | 'yearly';

/**
 * Plan feature configuration
 */
export type PlanFeatures = {
    /**
     * Maximum users allowed (-1 = unlimited)
     */
    maxUsers?: number;
    /**
     * Maximum locations allowed (-1 = unlimited)
     */
    maxLocations?: number;
    /**
     * Maximum storage in GB (-1 = unlimited)
     */
    maxStorageGb?: number;
    /**
     * Access to advanced reporting
     */
    advancedReporting?: boolean;
    /**
     * API access enabled
     */
    apiAccess?: boolean;
    /**
     * Custom branding enabled
     */
    customBranding?: boolean;
    /**
     * Priority support
     */
    prioritySupport?: boolean;
};

/**
 * Subscription plan list response
 */
export type PlanListResponse = {
    data: Array<SubscriptionPlan>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Subscription plan response
 */
export type PlanResponse = {
    data: SubscriptionPlan;
    meta: ResponseMeta;
};

/**
 * Plan visibility level
 */
export type PlanVisibility = 'public' | 'private' | 'archived';

/**
 * Request body for previewing an email template
 */
export type PreviewEmailRequest = {
    /**
     * Template ID to preview
     */
    templateId: string;
    /**
     * Data for template rendering
     */
    templateData?: {
        [key: string]: unknown;
    };
};

/**
 * Email preview response
 */
export type PreviewEmailResponse = {
    data: {
        /**
         * Rendered HTML content
         */
        html: string;
        /**
         * Rendered plain text content
         */
        text: string;
        /**
         * Email subject
         */
        subject: string;
    };
    meta: ResponseMeta;
};

/**
 * Publish a version
 */
export type PublishVersionRequest = {
    /**
     * Schedule for future (optional)
     */
    scheduledAt?: string;
};

/**
 * Column configuration for reports
 */
export type ReportColumnConfig = {
    /**
     * Column identifier
     */
    id: string;
    /**
     * Display header text
     */
    header: string;
    /**
     * Property key to access data (e.g., "user.name")
     */
    accessorKey?: string;
    /**
     * Custom accessor function (JavaScript expression)
     */
    accessorFn?: string;
    /**
     * Column width in pixels
     */
    width?: number;
    /**
     * Text alignment
     */
    align?: ColumnAlignment;
    /**
     * Data format type
     */
    format?: ColumnFormat;
    /**
     * Custom format pattern (e.g., "yyyy-MM-dd" for dates)
     */
    formatPattern?: string;
    /**
     * Whether column is hidden by default
     */
    hidden?: boolean;
};

/**
 * Report output format
 */
export type ReportFormat = 'csv' | 'excel' | 'pdf' | 'thermal' | 'dotmatrix';

/**
 * Report format-specific options
 */
export type ReportOptions = {
    /**
     * CSV delimiter character
     */
    delimiter?: string;
    /**
     * Include header row in CSV
     */
    includeHeaders?: boolean;
    /**
     * Excel sheet name
     */
    sheetName?: string;
    /**
     * Enable auto-filter in Excel
     */
    autoFilter?: boolean;
    /**
     * Freeze header row in Excel
     */
    freezeHeader?: boolean;
    /**
     * Page orientation for PDF
     */
    orientation?: ReportOrientation;
    /**
     * Page size for PDF
     */
    pageSize?: ReportPageSize;
    /**
     * Top margin in mm
     */
    marginTop?: number;
    /**
     * Right margin in mm
     */
    marginRight?: number;
    /**
     * Bottom margin in mm
     */
    marginBottom?: number;
    /**
     * Left margin in mm
     */
    marginLeft?: number;
    /**
     * Report title (displayed at top)
     */
    title?: string;
    /**
     * Report subtitle
     */
    subtitle?: string;
    /**
     * Watermark text
     */
    watermark?: string;
    /**
     * Include page numbers
     */
    includePageNumbers?: boolean;
    /**
     * Include generation timestamp
     */
    includeTimestamp?: boolean;
    /**
     * Printer paper width (58mm or 80mm)
     */
    printerWidth?: number;
    /**
     * Character encoding
     */
    encoding?: string;
    /**
     * Cut paper after printing
     */
    autoCut?: boolean;
};

/**
 * Page orientation for PDF reports
 */
export type ReportOrientation = 'portrait' | 'landscape';

/**
 * Page size for PDF reports
 */
export type ReportPageSize = 'a4' | 'letter' | 'legal' | 'a3';

/**
 * Report Template resource model
 *
 * Defines reusable report configurations with:
 * - Multiple output formats (CSV, Excel, PDF, Thermal, Dot-Matrix)
 * - Eta template engine for custom layouts
 * - Column definitions with formatting
 * - Data source configuration
 * - Multi-tenant scoping
 */
export type ReportTemplate = {
    /**
     * Unique template identifier (format: tpl_{randomString})
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    orgId: string;
    /**
     * Template name
     */
    name: string;
    /**
     * Template description
     */
    description?: string;
    /**
     * Output format
     */
    format: ReportFormat;
    /**
     * Template engine (currently only eta supported)
     */
    templateEngine: string;
    /**
     * Template content (Eta template string)
     */
    templateContent: string;
    /**
     * Format-specific options
     */
    options?: ReportOptions;
    /**
     * Data source configuration
     */
    dataSource?: DataSourceConfig;
    /**
     * Column definitions
     */
    columns: Array<ReportColumnConfig>;
    /**
     * Whether template is visible to all org members
     */
    isPublic: boolean;
    /**
     * User ID who created the template
     */
    createdBy: string;
    /**
     * Timestamp when the template was created
     */
    createdAt: string;
    /**
     * Timestamp when the template was last updated
     */
    updatedAt: string;
    /**
     * Timestamp when the template was soft deleted (null if not deleted)
     */
    deletedAt?: string;
};

/**
 * Report template collection response (page-based)
 */
export type ReportTemplateListResponse = {
    data: Array<ReportTemplate>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single report template response
 */
export type ReportTemplateResponse = {
    data: ReportTemplate;
    meta: ResponseMeta;
};

/**
 * Response metadata included in all API responses
 */
export type ResponseMeta = {
    /**
     * Unique request identifier for tracking and debugging
     */
    requestId: string;
    /**
     * Timestamp when the response was generated
     */
    timestamp: string;
    /**
     * API version used for this request
     */
    apiVersion?: string;
    /**
     * Tenant/organization ID for multi-tenant requests
     */
    tenantId?: string;
    /**
     * Tenant/organization name for multi-tenant requests
     */
    tenantName?: string;
    /**
     * Processing time in milliseconds
     */
    durationMs?: number;
};

/**
 * Role resource model
 *
 * Roles can be:
 * - **Global roles**: App-scoped (tenantId is null), apply across all tenants
 * - **Tenant roles**: Scoped to a specific organization
 *
 * Users can have multiple roles, and permissions are combined with
 * deny-override semantics.
 */
export type Role = {
    /**
     * Unique role identifier (format: role_abc123)
     */
    id: string;
    /**
     * Application this role belongs to
     */
    applicationId: string;
    /**
     * Tenant this role belongs to (null for global roles)
     */
    tenantId?: string;
    /**
     * Role name
     */
    name: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions granted by this role
     */
    permissions: Array<Permission>;
    /**
     * Whether this is a system-defined role (cannot be deleted or renamed)
     */
    isSystemRole: boolean;
    /**
     * Whether this is a global role (tenantId is null)
     */
    isGlobalRole: boolean;
    /**
     * Timestamp when the role was created
     */
    createdAt: string;
    /**
     * Timestamp when the role was last updated
     */
    updatedAt: string;
    /**
     * User who created this role
     */
    createdBy?: string;
};

/**
 * Role list response
 */
export type RoleListResponse = {
    data: Array<Role>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single role response
 */
export type RoleResponse = {
    data: Role;
    meta: ResponseMeta;
};

/**
 * ============================================================================
 * SCHEDULE COMMON TYPES
 * ============================================================================
 *
 * Shared types used by both scheduled reports and scheduled jobs.
 * These types are generic and can be used for any scheduled operation.
 * ============================================================================Schedule frequency
 */
export type ScheduleFrequency = 'once' | 'daily' | 'weekly' | 'monthly' | 'custom';

/**
 * Scheduled Job resource model
 *
 * Defines automated job execution with:
 * - Flexible scheduling (daily, weekly, monthly, custom cron)
 * - Multiple delivery methods (email, webhook, storage)
 * - Generic job type support (report, export, import, custom)
 * - Multi-tenant scoping
 */
export type ScheduledJob = {
    /**
     * Unique schedule identifier (format: sched_{randomString})
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    orgId: string;
    /**
     * Job type to run (e.g., "report", "export", "import", "custom-job")
     */
    jobType: string;
    /**
     * Job configuration passed to the job handler (e.g., templateId, parameters)
     */
    jobConfig?: {
        [key: string]: unknown;
    };
    /**
     * Schedule name
     */
    name: string;
    /**
     * Schedule description
     */
    description?: string;
    /**
     * Schedule frequency
     */
    frequency: ScheduleFrequency;
    /**
     * Cron expression (required when frequency is custom)
     */
    cronExpression?: string;
    /**
     * Day of week (for weekly frequency)
     */
    dayOfWeek?: DayOfWeek;
    /**
     * Day of month (for monthly frequency, 1-28)
     */
    dayOfMonth?: number;
    /**
     * Hour to run (0-23)
     */
    hour?: number;
    /**
     * Minute to run (0-59)
     */
    minute?: number;
    /**
     * Timezone for scheduling
     */
    timezone: string;
    /**
     * Start date for the schedule
     */
    startDate: string;
    /**
     * End date for the schedule (null = runs indefinitely)
     */
    endDate?: string;
    /**
     * Delivery method for job results
     */
    deliveryMethod: JobDeliveryMethod;
    /**
     * Delivery configuration
     */
    deliveryConfig?: DeliveryConfig;
    /**
     * Whether the schedule is active
     */
    isActive: boolean;
    /**
     * Timestamp of last successful run
     */
    lastRunAt?: string;
    /**
     * Timestamp of next scheduled run
     */
    nextRunAt?: string;
    /**
     * Number of consecutive failures
     */
    failureCount: number;
    /**
     * Last job ID created by this schedule
     */
    lastJobId?: string;
    /**
     * User ID who created the schedule
     */
    createdBy: string;
    /**
     * Timestamp when the schedule was created
     */
    createdAt: string;
    /**
     * Timestamp when the schedule was last updated
     */
    updatedAt: string;
    /**
     * Timestamp when the schedule was soft deleted
     */
    deletedAt?: string;
};

/**
 * Scheduled job run history response
 */
export type ScheduledJobHistoryResponse = {
    data: {
        /**
         * Schedule ID
         */
        scheduleId: string;
        /**
         * Jobs created by this schedule
         */
        jobs: Array<{
            /**
             * Job ID
             */
            jobId: string;
            /**
             * Job status
             */
            status: string;
            /**
             * When the job was created
             */
            createdAt: string;
            /**
             * When the job completed
             */
            completedAt?: string;
            /**
             * Whether the job succeeded
             */
            success: boolean;
            /**
             * Error message if failed
             */
            error?: string;
        }>;
    };
    meta: ResponseMeta;
};

/**
 * Scheduled job collection response (page-based)
 */
export type ScheduledJobListResponse = {
    data: Array<ScheduledJob>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single scheduled job response
 */
export type ScheduledJobResponse = {
    data: ScheduledJob;
    meta: ResponseMeta;
};

/**
 * Request body for sending a notification
 */
export type SendNotificationRequest = {
    /**
     * Notification channel
     */
    channel: NotificationChannel;
    /**
     * Notification category
     */
    category: NotificationCategory;
    /**
     * Notification priority (default: normal)
     */
    priority?: NotificationPriority;
    /**
     * Recipient information
     */
    recipient: NotificationRecipient;
    /**
     * Template ID to use for rendering
     */
    templateId?: string;
    /**
     * Data for template rendering
     */
    templateData?: {
        [key: string]: unknown;
    };
    /**
     * Subject line (for email, required if not using template)
     */
    subject?: string;
    /**
     * Plain text body (required if not using template)
     */
    body?: string;
    /**
     * HTML body (for email)
     */
    bodyHtml?: string;
    /**
     * Custom metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Send notification success response
 */
export type SendNotificationResponse = {
    data: {
        /**
         * Message ID assigned to the notification
         */
        messageId: string;
        /**
         * Provider used to send
         */
        provider: string;
    };
    meta: ResponseMeta;
};

/**
 * Response for soft delete operations
 *
 * Includes resource ID, deletion metadata, and restore information
 */
export type SoftDeleteResponse = {
    data: {
        /**
         * ID of the deleted resource
         */
        id: string;
        /**
         * Timestamp when the resource was soft deleted
         */
        deletedAt: string;
        /**
         * User ID who performed the deletion
         */
        deletedBy: string;
        /**
         * Reason for deletion (optional, from request)
         */
        deletionReason?: string;
        /**
         * Whether the resource can be restored
         */
        canRestore: boolean;
        /**
         * Deadline for restoration (after which hard delete may occur)
         */
        restoreUntil?: string;
    };
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Storage delivery configuration
 */
export type StorageDeliveryConfig = {
    /**
     * Storage path template (supports variables like {{date}}, {{name}})
     */
    pathTemplate: string;
    /**
     * Storage provider (local, s3, etc.)
     */
    provider?: string;
    /**
     * Storage bucket (for cloud providers)
     */
    bucket?: string;
};

/**
 * Storage delivery configuration
 */
export type StorageDeliveryConfigUpdate = {
    /**
     * Storage path template (supports variables like {{date}}, {{name}})
     */
    pathTemplate?: string;
    /**
     * Storage provider (local, s3, etc.)
     */
    provider?: string;
    /**
     * Storage bucket (for cloud providers)
     */
    bucket?: string;
};

/**
 * Request body for streaming export
 */
export type StreamExportRequest = {
    /**
     * Report template ID
     */
    templateId?: string;
    /**
     * Output format (only csv and excel supported)
     */
    format: 'csv' | 'excel';
    /**
     * Filters to apply
     */
    filters?: {
        [key: string]: unknown;
    };
    /**
     * Sort configuration
     */
    sort?: Array<{
        field: string;
        direction: 'asc' | 'desc';
    }>;
    /**
     * Batch size for streaming
     */
    batchSize?: number;
};

/**
 * Organization subscription
 *
 * Represents an active subscription for an organization.
 */
export type Subscription = {
    /**
     * Unique subscription identifier (format: sub_abc123)
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Current plan ID
     */
    planId: string;
    /**
     * Subscription status
     */
    status: SubscriptionStatus;
    /**
     * Trial start date
     */
    trialStartsAt?: string;
    /**
     * Trial end date
     */
    trialEndsAt?: string;
    /**
     * Current billing period start
     */
    currentPeriodStart: string;
    /**
     * Current billing period end
     */
    currentPeriodEnd: string;
    /**
     * Applied coupon ID
     */
    couponId?: string;
    /**
     * Discount percentage (for percent coupons)
     */
    discountPercent?: number;
    /**
     * Discount amount in cents (for fixed coupons)
     */
    discountAmountCents?: number;
    /**
     * Cancel at end of current period
     */
    cancelAtPeriodEnd: boolean;
    /**
     * When subscription was canceled
     */
    canceledAt?: string;
    /**
     * Payment provider subscription ID (Xendit, Stripe, etc.)
     */
    providerSubscriptionId?: string;
    /**
     * Payment provider customer ID
     */
    providerCustomerId?: string;
    /**
     * When the subscription was created
     */
    createdAt: string;
    /**
     * When the subscription was last updated
     */
    updatedAt: string;
    /**
     * Nested plan details (populated when requested)
     */
    plan?: SubscriptionPlan;
};

/**
 * Subscription plan
 *
 * Represents a pricing tier with features and limits.
 */
export type SubscriptionPlan = {
    /**
     * Unique plan identifier (format: plan_basic_monthly)
     */
    id: string;
    /**
     * Application this plan belongs to
     */
    applicationId: string;
    /**
     * Plan display name
     */
    name: string;
    /**
     * URL-friendly slug
     */
    slug: string;
    /**
     * Plan description
     */
    description?: string;
    /**
     * Price in smallest currency unit (cents for USD, sen for IDR)
     */
    priceCents: number;
    /**
     * Currency code
     */
    currency: string;
    /**
     * Billing period
     */
    billingPeriod: PlanBillingPeriod;
    /**
     * Trial period in days (0 = no trial)
     */
    trialDays?: number;
    /**
     * Plan features and limits
     */
    features?: PlanFeatures;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Sort order for display
     */
    sortOrder?: number;
    /**
     * Visibility level
     */
    visibility: PlanVisibility;
    /**
     * Whether plan is active
     */
    isActive: boolean;
    /**
     * Whether to show "Popular" badge
     */
    isPopular?: boolean;
    /**
     * When the plan was created
     */
    createdAt: string;
    /**
     * When the plan was last updated
     */
    updatedAt: string;
};

/**
 * Subscription response
 */
export type SubscriptionResponse = {
    data: Subscription;
    meta: ResponseMeta;
};

/**
 * Subscription status
 */
export type SubscriptionStatus = 'trialing' | 'active' | 'past_due' | 'canceled' | 'paused' | 'expired';

/**
 * Request to switch active context (application and/or tenant)
 */
export type SwitchContextRequest = {
    /**
     * Target application ID (optional, defaults to current)
     */
    applicationId?: string;
    /**
     * Target tenant ID (optional, null to clear tenant context)
     */
    tenantId?: string;
};

/**
 * Context switch response
 */
export type SwitchContextResponse = {
    data: {
        /**
         * New active application ID
         */
        applicationId: string;
        /**
         * New active tenant ID (null if no tenant)
         */
        tenantId?: string;
        /**
         * Tenant name (if tenant selected)
         */
        tenantName?: string;
        /**
         * Roles in the new context
         */
        roles: Array<string>;
        /**
         * Effective permissions in the new context
         */
        permissions: Array<Permission>;
    };
    meta: ResponseMeta;
};

/**
 * System organization model
 */
export type SystemOrganization = {
    /**
     * Organization ID
     */
    id: string;
    /**
     * Organization name
     */
    name: string;
    /**
     * Organization slug
     */
    slug: string;
    /**
     * Organization logo URL
     */
    logo: string | null;
    /**
     * Creation date
     */
    createdAt: string;
    /**
     * Metadata (JSON string or object)
     */
    metadata: string | null;
    /**
     * Total number of members in the organization
     */
    memberCount?: number;
};

/**
 * List of system organizations response
 */
export type SystemOrganizationListResponse = {
    /**
     * Array of resources
     */
    data: Array<SystemOrganization>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * System organization response
 */
export type SystemOrganizationResponse = {
    /**
     * The resource data
     */
    data: SystemOrganization;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Unread announcement count response
 */
export type UnreadAnnouncementsResponse = {
    data: {
        /**
         * Number of unread announcements
         */
        unreadCount: number;
        /**
         * Number of critical announcements requiring acknowledgment
         */
        criticalCount: number;
    };
    meta: ResponseMeta;
};

/**
 * Unread count response
 */
export type UnreadCountResponse = {
    data: {
        /**
         * Number of unread notifications
         */
        unreadCount: number;
    };
    meta: ResponseMeta;
};

/**
 * Request body for updating an announcement
 */
export type UpdateAnnouncementRequest = {
    /**
     * Organization ID (null for system-wide announcements visible to all organizations)
     */
    orgId?: string | null;
    /**
     * Scope (system or organization)
     */
    scope?: AnnouncementScope;
    /**
     * Announcement title
     */
    title?: string;
    /**
     * Announcement content (supports Markdown for links, formatting, and equations)
     */
    content?: string;
    /**
     * Optional link URL
     */
    linkUrl?: string;
    /**
     * Optional link text
     */
    linkText?: string;
    /**
     * Priority level
     */
    priority?: AnnouncementPriority;
    /**
     * Target roles
     */
    targetRoles?: Array<AnnouncementTargetRole>;
    /**
     * Whether users can dismiss
     */
    isDismissible?: boolean;
    /**
     * Scheduled publish date/time
     */
    publishAt?: string;
    /**
     * Optional expiration date/time
     */
    expiresAt?: string;
    /**
     * Whether announcement is active
     */
    isActive?: boolean;
};

/**
 * Update coupon request
 */
export type UpdateCouponRequest = {
    /**
     * Internal name
     */
    name?: string;
    /**
     * Percentage off
     */
    percentOff?: number;
    /**
     * Amount off in cents
     */
    amountOffCents?: number;
    /**
     * Trial extension days
     */
    trialExtensionDays?: number;
    /**
     * Is active
     */
    isActive?: boolean;
    /**
     * Validity start
     */
    startsAt?: string;
    /**
     * Validity end
     */
    expiresAt?: string;
    /**
     * Max redemptions
     */
    maxRedemptions?: number;
    /**
     * First-time only
     */
    firstTimeOnly?: boolean;
    /**
     * Plan IDs (comma-separated)
     */
    planIds?: string;
};

/**
 * Request body for updating a comment
 */
export type UpdateExampleCommentRequest = {
    /**
     * Comment content (optional)
     */
    content?: string;
};

/**
 * Request body for updating a post
 */
export type UpdateExamplePostRequest = {
    /**
     * Post title (optional)
     */
    title?: string;
    /**
     * Post content (optional)
     */
    content?: string;
    /**
     * Post category
     */
    category?: string;
    /**
     * Post tags
     */
    tags?: Array<string>;
    /**
     * Whether the post is featured
     */
    isFeatured?: boolean;
    /**
     * Scheduled publish date
     */
    publishDate?: string;
    /**
     * Cover image file ID
     */
    coverImageId?: string;
    /**
     * Attachment file ID
     */
    attachmentFileId?: string;
    /**
     * Gallery images (file IDs)
     */
    galleryImageIds?: Array<string>;
    /**
     * Attached documents (file IDs)
     */
    documentFileIds?: Array<string>;
    /**
     * Post status (optional)
     */
    status?: ExamplePostStatus;
};

/**
 * Request to update file properties
 */
export type UpdateFileRequest = {
    /**
     * New access level
     */
    access?: FileAccess;
};

/**
 * Update document metadata
 */
export type UpdateLegalDocumentRequest = {
    /**
     * URL-friendly slug
     */
    slug?: string;
    /**
     * Locale/language code
     */
    locale?: string;
};

/**
 * Update a draft version
 */
export type UpdateLegalDocumentVersionRequest = {
    /**
     * Version title
     */
    title?: string;
    /**
     * Full content
     */
    content?: string;
    /**
     * Summary of changes
     */
    changelog?: string;
    /**
     * Whether users must re-accept
     */
    requiresReAcceptance?: boolean;
};

/**
 * Update subscription plan request
 */
export type UpdatePlanRequest = {
    /**
     * Plan name
     */
    name?: string;
    /**
     * Plan slug
     */
    slug?: string;
    /**
     * Plan description
     */
    description?: string;
    /**
     * Price in cents
     */
    priceCents?: number;
    /**
     * Currency code
     */
    currency?: string;
    /**
     * Billing period
     */
    billingPeriod?: PlanBillingPeriod;
    /**
     * Trial days
     */
    trialDays?: number;
    /**
     * Features
     */
    features?: PlanFeatures;
    /**
     * Metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Sort order
     */
    sortOrder?: number;
    /**
     * Visibility
     */
    visibility?: PlanVisibility;
    /**
     * Is active
     */
    isActive?: boolean;
    /**
     * Is popular
     */
    isPopular?: boolean;
};

/**
 * Request body for updating notification preferences
 */
export type UpdatePreferencesRequest = {
    /**
     * Email notifications enabled
     */
    emailEnabled?: boolean;
    /**
     * SMS notifications enabled
     */
    smsEnabled?: boolean;
    /**
     * WhatsApp notifications enabled
     */
    whatsappEnabled?: boolean;
    /**
     * Telegram notifications enabled
     */
    telegramEnabled?: boolean;
    /**
     * Push notifications enabled
     */
    pushEnabled?: boolean;
    /**
     * Marketing notifications enabled
     */
    marketingEnabled?: boolean;
    /**
     * Transactional notifications enabled
     */
    transactionalEnabled?: boolean;
    /**
     * Security notifications enabled
     */
    securityEnabled?: boolean;
    /**
     * System notifications enabled
     */
    systemEnabled?: boolean;
    /**
     * Preferred email address
     */
    preferredEmail?: string;
    /**
     * Preferred phone number
     */
    preferredPhone?: string;
    /**
     * Preferred Telegram ID
     */
    preferredTelegramId?: string;
    /**
     * Quiet hours enabled
     */
    quietHoursEnabled?: boolean;
    /**
     * Quiet hours start time (HH:mm format)
     */
    quietHoursStart?: string;
    /**
     * Quiet hours end time (HH:mm format)
     */
    quietHoursEnd?: string;
    /**
     * Quiet hours timezone (IANA format)
     */
    quietHoursTimezone?: string;
};

/**
 * Request body for updating a report template
 */
export type UpdateReportTemplateRequest = {
    /**
     * Template name
     */
    name?: string;
    /**
     * Template description
     */
    description?: string;
    /**
     * Output format
     */
    format?: ReportFormat;
    /**
     * Template content
     */
    templateContent?: string;
    /**
     * Format-specific options
     */
    options?: ReportOptions;
    /**
     * Data source configuration
     */
    dataSource?: DataSourceConfigUpdate;
    /**
     * Column definitions
     */
    columns?: Array<ReportColumnConfig>;
    /**
     * Whether template is visible to all org members
     */
    isPublic?: boolean;
};

/**
 * Request to update a role
 */
export type UpdateRoleRequest = {
    /**
     * Role name
     */
    name?: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions to grant (replaces existing permissions)
     */
    permissions?: Array<PermissionInput>;
};

/**
 * Request body for updating a scheduled job
 */
export type UpdateScheduledJobRequest = {
    /**
     * Job type to run
     */
    jobType?: string;
    /**
     * Job configuration passed to the job handler
     */
    jobConfig?: {
        [key: string]: unknown;
    };
    /**
     * Schedule name
     */
    name?: string;
    /**
     * Schedule description
     */
    description?: string;
    /**
     * Schedule frequency
     */
    frequency?: ScheduleFrequency;
    /**
     * Cron expression
     */
    cronExpression?: string;
    /**
     * Day of week
     */
    dayOfWeek?: DayOfWeek;
    /**
     * Day of month
     */
    dayOfMonth?: number;
    /**
     * Hour to run
     */
    hour?: number;
    /**
     * Minute to run
     */
    minute?: number;
    /**
     * Timezone
     */
    timezone?: string;
    /**
     * Start date
     */
    startDate?: string;
    /**
     * End date
     */
    endDate?: string;
    /**
     * Delivery method
     */
    deliveryMethod?: JobDeliveryMethod;
    /**
     * Delivery configuration
     */
    deliveryConfig?: DeliveryConfigUpdate;
    /**
     * Whether the schedule is active
     */
    isActive?: boolean;
};

/**
 * Update subscription request
 */
export type UpdateSubscriptionRequest = {
    /**
     * New plan ID (for upgrade/downgrade)
     */
    planId?: string;
    /**
     * Cancel at end of period
     */
    cancelAtPeriodEnd?: boolean;
};

/**
 * Request to update a system organization
 */
export type UpdateSystemOrganizationRequest = {
    name?: string;
    slug?: string;
    logo?: string | null;
    metadata?: string | null;
};

/**
 * Request to update a webhook
 */
export type UpdateWebhookRequest = {
    /**
     * URL to receive webhook payloads
     */
    url?: string;
    /**
     * Human-readable name
     */
    name?: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Event types to subscribe to
     */
    events?: Array<string>;
    /**
     * Whether the webhook is active
     */
    isActive?: boolean;
};

/**
 * User's context across applications and tenants
 */
export type UserContext = {
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Application name
     */
    applicationName: string;
    /**
     * Tenant ID
     */
    tenantId: string;
    /**
     * Tenant name
     */
    tenantName: string;
    /**
     * Role names in this context
     */
    roles: Array<string>;
};

/**
 * User available contexts response (all apps/tenants user belongs to)
 */
export type UserContextListResponse = {
    data: Array<UserContext>;
    meta: ResponseMeta;
};

/**
 * User's effective permissions
 *
 * Represents the combined permissions from all roles assigned to a user
 * within a specific application and tenant context.
 */
export type UserEffectivePermissions = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Tenant ID (context for permission calculation)
     */
    tenantId?: string;
    /**
     * Global roles (app-scoped, no tenant)
     */
    globalRoles: Array<{
        /**
         * Role ID
         */
        id: string;
        /**
         * Role name
         */
        name: string;
        /**
         * Permissions from this role
         */
        permissions: Array<Permission>;
    }>;
    /**
     * Tenant-specific roles
     */
    tenantRoles: Array<{
        /**
         * Role ID
         */
        id: string;
        /**
         * Role name
         */
        name: string;
        /**
         * Permissions from this role
         */
        permissions: Array<Permission>;
    }>;
    /**
     * Combined effective permissions (after deny-override resolution)
     */
    effectivePermissions: Array<Permission>;
    /**
     * Simple list of allowed actions (for quick checks)
     */
    allowedActions: Array<string>;
};

/**
 * User effective permissions response
 */
export type UserEffectivePermissionsResponse = {
    data: UserEffectivePermissions;
    meta: ResponseMeta;
};

/**
 * User's role assignment
 *
 * Represents a single role assigned to a user within a specific
 * application and optional tenant context.
 */
export type UserRoleAssignment = {
    /**
     * Assignment ID
     */
    id: string;
    /**
     * User ID
     */
    userId: string;
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Tenant ID (null for global role assignments)
     */
    tenantId?: string;
    /**
     * Role ID
     */
    roleId: string;
    /**
     * Role name (denormalized for convenience)
     */
    roleName: string;
    /**
     * Whether this is a global role assignment
     */
    isGlobalRole: boolean;
    /**
     * When the role was assigned
     */
    assignedAt: string;
    /**
     * Who assigned the role
     */
    assignedBy?: string;
};

/**
 * User role assignments list response
 */
export type UserRoleAssignmentListResponse = {
    data: Array<UserRoleAssignment>;
    meta: ResponseMeta;
};

/**
 * User role assignment response
 */
export type UserRoleAssignmentResponse = {
    data: UserRoleAssignment;
    meta: ResponseMeta;
};

/**
 * Validate coupon request
 */
export type ValidateCouponRequest = {
    /**
     * Coupon code to validate
     */
    code: string;
    /**
     * Plan ID to apply coupon to
     */
    planId: string;
};

/**
 * Coupon validation response
 */
export type ValidateCouponResponse = {
    /**
     * Whether the coupon is valid
     */
    valid: boolean;
    /**
     * Coupon details (if valid)
     */
    coupon?: Coupon;
    /**
     * Calculated discount amount in cents (if applicable)
     */
    discountAmount?: number;
    /**
     * Validation message
     */
    message?: string;
};

/**
 * Virus scan status for uploaded files
 */
export type VirusScanStatus = 'pending' | 'scanning' | 'clean' | 'infected' | 'failed';

/**
 * Warning message included in responses for non-fatal issues
 *
 * Examples: deprecated endpoints, capped page size, rate limit approaching
 */
export type Warning = {
    /**
     * Warning code (e.g., endpointDeprecated, pageSizeCapped)
     */
    code: string;
    /**
     * Human-readable warning message
     */
    message: string;
    /**
     * URL to documentation about this warning (optional)
     */
    documentationUrl?: string;
};

/**
 * Webhook configuration
 *
 * Defines an endpoint to receive event notifications.
 */
export type Webhook = {
    /**
     * Unique webhook identifier (format: wh_abc123)
     */
    id: string;
    /**
     * Tenant this webhook belongs to
     */
    tenantId: string;
    /**
     * URL to receive webhook payloads
     */
    url: string;
    /**
     * Human-readable name for this webhook
     */
    name?: string;
    /**
     * Description of what this webhook is used for
     */
    description?: string;
    /**
     * Event types to subscribe to (e.g., "user.created", "invoice.paid")
     */
    events: Array<string>;
    /**
     * Secret for HMAC-SHA256 signature verification (masked after creation)
     */
    secret: string;
    /**
     * Whether the webhook is currently active
     */
    isActive: boolean;
    /**
     * Number of consecutive failures (resets on success)
     */
    consecutiveFailures: number;
    /**
     * When the webhook was last triggered
     */
    lastTriggeredAt?: string;
    /**
     * When the webhook last succeeded
     */
    lastSuccessAt?: string;
    /**
     * When the webhook last failed
     */
    lastFailureAt?: string;
    /**
     * User who created this webhook
     */
    createdBy: string;
    /**
     * When the webhook was created
     */
    createdAt: string;
    /**
     * When the webhook was last updated
     */
    updatedAt: string;
};

/**
 * Webhook received acknowledgment
 */
export type WebhookAcknowledgment = {
    /**
     * Whether webhook was received
     */
    received: boolean;
    /**
     * Event ID (if processed)
     */
    eventId?: string;
    /**
     * Processing note
     */
    note?: string;
};

/**
 * Webhook creation response (includes secret once)
 */
export type WebhookCreatedResponse = {
    data: WebhookWithSecret;
    meta: ResponseMeta;
};

/**
 * Webhook delivery attempt record
 *
 * Tracks each attempt to deliver a webhook payload.
 */
export type WebhookDelivery = {
    /**
     * Unique delivery identifier (format: whd_abc123)
     */
    id: string;
    /**
     * Webhook ID this delivery belongs to
     */
    webhookId: string;
    /**
     * Event ID that triggered this delivery
     */
    eventId: string;
    /**
     * Event type
     */
    eventType: string;
    /**
     * Delivery status
     */
    status: WebhookDeliveryStatus;
    /**
     * Number of delivery attempts made
     */
    attemptCount: number;
    /**
     * HTTP status code from last attempt (null if not yet attempted)
     */
    httpStatus?: number;
    /**
     * Response body from last attempt (truncated)
     */
    responseBody?: string;
    /**
     * Error message if failed
     */
    errorMessage?: string;
    /**
     * Duration of last request in milliseconds
     */
    durationMs?: number;
    /**
     * When the next retry will be attempted
     */
    nextRetryAt?: string;
    /**
     * When this delivery was created
     */
    createdAt: string;
    /**
     * When the delivery was last attempted
     */
    lastAttemptAt?: string;
    /**
     * When the delivery completed (success or exhausted)
     */
    completedAt?: string;
};

/**
 * Webhook delivery configuration
 */
export type WebhookDeliveryConfig = {
    /**
     * Webhook URL to POST the result
     */
    url: string;
    /**
     * Custom headers to include
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * Include result as attachment or inline base64
     */
    attachmentMode?: 'attachment' | 'base64';
};

/**
 * Webhook delivery configuration
 */
export type WebhookDeliveryConfigUpdate = {
    /**
     * Webhook URL to POST the result
     */
    url?: string;
    /**
     * Custom headers to include
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * Include result as attachment or inline base64
     */
    attachmentMode?: 'attachment' | 'base64';
};

/**
 * Webhook delivery list response
 */
export type WebhookDeliveryListResponse = {
    data: Array<WebhookDelivery>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Webhook delivery response
 */
export type WebhookDeliveryResponse = {
    data: WebhookDelivery;
    meta: ResponseMeta;
};

/**
 * Webhook delivery status
 */
export type WebhookDeliveryStatus = 'pending' | 'delivered' | 'failed' | 'exhausted';

/**
 * Available webhook event types
 */
export type WebhookEventTypesResponse = {
    data: {
        /**
         * Available event types grouped by resource
         */
        eventTypes: {
            [key: string]: Array<string>;
        };
    };
    meta: ResponseMeta;
};

/**
 * Webhook list response
 */
export type WebhookListResponse = {
    data: Array<Webhook>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Webhook response (secret masked)
 */
export type WebhookResponse = {
    data: Webhook;
    meta: ResponseMeta;
};

/**
 * Webhook with unmasked secret (only returned on creation)
 */
export type WebhookWithSecret = {
    /**
     * Unique webhook identifier
     */
    id: string;
    /**
     * Tenant this webhook belongs to
     */
    tenantId: string;
    /**
     * URL to receive webhook payloads
     */
    url: string;
    /**
     * Webhook name
     */
    name?: string;
    /**
     * Event types subscribed to
     */
    events: Array<string>;
    /**
     * The webhook secret - ONLY RETURNED ONCE
     * Use this for signature verification
     */
    secret: string;
    /**
     * Whether the webhook is active
     */
    isActive: boolean;
    /**
     * When the webhook was created
     */
    createdAt: string;
};

export type HealthCheckData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type HealthCheckResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Service status
         */
        status: 'ok' | 'degraded' | 'down';
        /**
         * Current timestamp
         */
        timestamp: string;
        /**
         * API version
         */
        version?: string;
        /**
         * Additional service information
         */
        services?: {
            database?: 'ok' | 'degraded' | 'down';
            cache?: 'ok' | 'degraded' | 'down';
            storage?: 'ok' | 'degraded' | 'down';
        };
    };
};

export type HealthCheckResponse = HealthCheckResponses[keyof HealthCheckResponses];

export type CouponsAdminListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by coupon type
         */
        type?: CouponType;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Search by code
         */
        code?: string;
        /**
         * Sort by field
         */
        sortBy?: string;
        /**
         * Sort order
         */
        sortOrder?: string;
    };
    url: '/v1/admin/coupons';
};

export type CouponsAdminListResponses = {
    /**
     * The request has succeeded.
     */
    200: CouponListResponse | ErrorResponse;
};

export type CouponsAdminListResponse = CouponsAdminListResponses[keyof CouponsAdminListResponses];

export type CouponsAdminCreateData = {
    /**
     * Coupon details
     */
    body: CreateCouponRequest;
    path?: never;
    query?: never;
    url: '/v1/admin/coupons';
};

export type CouponsAdminCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: CouponResponse;
};

export type CouponsAdminCreateResponse = CouponsAdminCreateResponses[keyof CouponsAdminCreateResponses];

export type CouponsAdminDeleteData = {
    body?: never;
    path: {
        /**
         * Coupon ID
         */
        couponId: string;
    };
    query?: never;
    url: '/v1/admin/coupons/{couponId}';
};

export type CouponsAdminDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type CouponsAdminDeleteResponse = CouponsAdminDeleteResponses[keyof CouponsAdminDeleteResponses];

export type CouponsAdminGetData = {
    body?: never;
    path: {
        /**
         * Coupon ID
         */
        couponId: string;
    };
    query?: never;
    url: '/v1/admin/coupons/{couponId}';
};

export type CouponsAdminGetResponses = {
    /**
     * The request has succeeded.
     */
    200: CouponResponse | ErrorResponse;
};

export type CouponsAdminGetResponse = CouponsAdminGetResponses[keyof CouponsAdminGetResponses];

export type CouponsAdminUpdateData = {
    /**
     * Updated coupon details
     */
    body: UpdateCouponRequest;
    path: {
        /**
         * Coupon ID
         */
        couponId: string;
    };
    query?: never;
    url: '/v1/admin/coupons/{couponId}';
};

export type CouponsAdminUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: CouponResponse | ErrorResponse;
};

export type CouponsAdminUpdateResponse = CouponsAdminUpdateResponses[keyof CouponsAdminUpdateResponses];

export type LegalDocumentsAdminListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Items per page
         */
        pageSize?: number;
        /**
         * Filter by type
         */
        type?: LegalDocumentType;
        /**
         * Filter by status
         */
        status?: LegalDocumentStatus;
        /**
         * Filter by locale
         */
        locale?: string;
        /**
         * Include deleted documents
         */
        includeDeleted?: boolean;
    };
    url: '/v1/admin/legal-documents';
};

export type LegalDocumentsAdminListResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentListResponse | ErrorResponse;
};

export type LegalDocumentsAdminListResponse = LegalDocumentsAdminListResponses[keyof LegalDocumentsAdminListResponses];

export type LegalDocumentsAdminCreateData = {
    /**
     * Document data
     */
    body: CreateLegalDocumentRequest;
    path?: never;
    query?: never;
    url: '/v1/admin/legal-documents';
};

export type LegalDocumentsAdminCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: LegalDocumentWithVersionResponse;
};

export type LegalDocumentsAdminCreateResponse = LegalDocumentsAdminCreateResponses[keyof LegalDocumentsAdminCreateResponses];

export type LegalDocumentsAdminExportAcceptancesData = {
    /**
     * Export options
     */
    body: ExportAcceptancesRequest;
    path?: never;
    query?: never;
    url: '/v1/admin/legal-documents/export-acceptances';
};

export type LegalDocumentsAdminExportAcceptancesResponses = {
    /**
     * The request has succeeded.
     */
    200: AsyncJobResponse | ErrorResponse;
};

export type LegalDocumentsAdminExportAcceptancesResponse = LegalDocumentsAdminExportAcceptancesResponses[keyof LegalDocumentsAdminExportAcceptancesResponses];

export type LegalDocumentsAdminDeleteData = {
    body?: never;
    path: {
        /**
         * Document ID
         */
        documentId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}';
};

export type LegalDocumentsAdminDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type LegalDocumentsAdminDeleteResponse = LegalDocumentsAdminDeleteResponses[keyof LegalDocumentsAdminDeleteResponses];

export type LegalDocumentsAdminGetData = {
    body?: never;
    path: {
        /**
         * Document ID
         */
        documentId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}';
};

export type LegalDocumentsAdminGetResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentWithVersionResponse | ErrorResponse;
};

export type LegalDocumentsAdminGetResponse = LegalDocumentsAdminGetResponses[keyof LegalDocumentsAdminGetResponses];

export type LegalDocumentsAdminUpdateData = {
    /**
     * Updated data
     */
    body: UpdateLegalDocumentRequest;
    path: {
        /**
         * Document ID
         */
        documentId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}';
};

export type LegalDocumentsAdminUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentResponse | ErrorResponse;
};

export type LegalDocumentsAdminUpdateResponse = LegalDocumentsAdminUpdateResponses[keyof LegalDocumentsAdminUpdateResponses];

export type LegalDocumentsAdminListAcceptancesData = {
    body?: never;
    path: {
        /**
         * Document ID
         */
        documentId: string;
    };
    query?: {
        /**
         * Filter by version
         */
        versionId?: string;
        /**
         * Page number
         */
        page?: number;
        /**
         * Items per page
         */
        pageSize?: number;
    };
    url: '/v1/admin/legal-documents/{documentId}/acceptances';
};

export type LegalDocumentsAdminListAcceptancesResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentAcceptanceListResponse | ErrorResponse;
};

export type LegalDocumentsAdminListAcceptancesResponse = LegalDocumentsAdminListAcceptancesResponses[keyof LegalDocumentsAdminListAcceptancesResponses];

export type LegalDocumentsAdminGetAuditLogData = {
    body?: never;
    path: {
        /**
         * Document ID
         */
        documentId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Items per page
         */
        pageSize?: number;
    };
    url: '/v1/admin/legal-documents/{documentId}/audit-log';
};

export type LegalDocumentsAdminGetAuditLogResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentAuditLogListResponse | ErrorResponse;
};

export type LegalDocumentsAdminGetAuditLogResponse = LegalDocumentsAdminGetAuditLogResponses[keyof LegalDocumentsAdminGetAuditLogResponses];

export type LegalDocumentsAdminListVersionsData = {
    body?: never;
    path: {
        /**
         * Document ID
         */
        documentId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Items per page
         */
        pageSize?: number;
        /**
         * Filter by status
         */
        status?: LegalDocumentStatus;
    };
    url: '/v1/admin/legal-documents/{documentId}/versions';
};

export type LegalDocumentsAdminListVersionsResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentVersionListResponse | ErrorResponse;
};

export type LegalDocumentsAdminListVersionsResponse = LegalDocumentsAdminListVersionsResponses[keyof LegalDocumentsAdminListVersionsResponses];

export type LegalDocumentsAdminCreateVersionData = {
    /**
     * Version data
     */
    body: CreateLegalDocumentVersionRequest;
    path: {
        /**
         * Document ID
         */
        documentId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}/versions';
};

export type LegalDocumentsAdminCreateVersionResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: LegalDocumentVersionResponse;
};

export type LegalDocumentsAdminCreateVersionResponse = LegalDocumentsAdminCreateVersionResponses[keyof LegalDocumentsAdminCreateVersionResponses];

export type LegalDocumentsAdminGetVersionData = {
    body?: never;
    path: {
        /**
         * Document ID
         */
        documentId: string;
        /**
         * Version ID
         */
        versionId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}/versions/{versionId}';
};

export type LegalDocumentsAdminGetVersionResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentVersionResponse | ErrorResponse;
};

export type LegalDocumentsAdminGetVersionResponse = LegalDocumentsAdminGetVersionResponses[keyof LegalDocumentsAdminGetVersionResponses];

export type LegalDocumentsAdminUpdateVersionData = {
    /**
     * Updated data
     */
    body: UpdateLegalDocumentVersionRequest;
    path: {
        /**
         * Document ID
         */
        documentId: string;
        /**
         * Version ID
         */
        versionId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}/versions/{versionId}';
};

export type LegalDocumentsAdminUpdateVersionResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentVersionResponse | ErrorResponse;
};

export type LegalDocumentsAdminUpdateVersionResponse = LegalDocumentsAdminUpdateVersionResponses[keyof LegalDocumentsAdminUpdateVersionResponses];

export type LegalDocumentsAdminPreviewVersionData = {
    body?: never;
    path: {
        /**
         * Document ID
         */
        documentId: string;
        /**
         * Version ID
         */
        versionId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}/versions/{versionId}/preview';
};

export type LegalDocumentsAdminPreviewVersionResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentVersionResponse | ErrorResponse;
};

export type LegalDocumentsAdminPreviewVersionResponse = LegalDocumentsAdminPreviewVersionResponses[keyof LegalDocumentsAdminPreviewVersionResponses];

export type LegalDocumentsAdminPublishVersionData = {
    /**
     * Publish options
     */
    body?: PublishVersionRequest;
    path: {
        /**
         * Document ID
         */
        documentId: string;
        /**
         * Version ID
         */
        versionId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}/versions/{versionId}/publish';
};

export type LegalDocumentsAdminPublishVersionResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentVersionResponse | ErrorResponse;
};

export type LegalDocumentsAdminPublishVersionResponse = LegalDocumentsAdminPublishVersionResponses[keyof LegalDocumentsAdminPublishVersionResponses];

export type LegalDocumentsAdminUnpublishVersionData = {
    body?: never;
    path: {
        /**
         * Document ID
         */
        documentId: string;
        /**
         * Version ID
         */
        versionId: string;
    };
    query?: never;
    url: '/v1/admin/legal-documents/{documentId}/versions/{versionId}/unpublish';
};

export type LegalDocumentsAdminUnpublishVersionResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentVersionResponse | ErrorResponse;
};

export type LegalDocumentsAdminUnpublishVersionResponse = LegalDocumentsAdminUnpublishVersionResponses[keyof LegalDocumentsAdminUnpublishVersionResponses];

export type SubscriptionPlansAdminListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by application ID
         */
        applicationId?: string;
        /**
         * Filter by visibility
         */
        visibility?: PlanVisibility;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Filter by billing period
         */
        billingPeriod?: PlanBillingPeriod;
        /**
         * Sort by field
         */
        sortBy?: string;
        /**
         * Sort order
         */
        sortOrder?: string;
    };
    url: '/v1/admin/plans';
};

export type SubscriptionPlansAdminListResponses = {
    /**
     * The request has succeeded.
     */
    200: PlanListResponse | ErrorResponse;
};

export type SubscriptionPlansAdminListResponse = SubscriptionPlansAdminListResponses[keyof SubscriptionPlansAdminListResponses];

export type SubscriptionPlansAdminCreateData = {
    /**
     * Plan details
     */
    body: CreatePlanRequest;
    path?: never;
    query?: never;
    url: '/v1/admin/plans';
};

export type SubscriptionPlansAdminCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PlanResponse;
};

export type SubscriptionPlansAdminCreateResponse = SubscriptionPlansAdminCreateResponses[keyof SubscriptionPlansAdminCreateResponses];

export type SubscriptionPlansAdminDeleteData = {
    body?: never;
    path: {
        /**
         * Plan ID
         */
        planId: string;
    };
    query?: never;
    url: '/v1/admin/plans/{planId}';
};

export type SubscriptionPlansAdminDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type SubscriptionPlansAdminDeleteResponse = SubscriptionPlansAdminDeleteResponses[keyof SubscriptionPlansAdminDeleteResponses];

export type SubscriptionPlansAdminGetData = {
    body?: never;
    path: {
        /**
         * Plan ID
         */
        planId: string;
    };
    query?: never;
    url: '/v1/admin/plans/{planId}';
};

export type SubscriptionPlansAdminGetResponses = {
    /**
     * The request has succeeded.
     */
    200: PlanResponse | ErrorResponse;
};

export type SubscriptionPlansAdminGetResponse = SubscriptionPlansAdminGetResponses[keyof SubscriptionPlansAdminGetResponses];

export type SubscriptionPlansAdminUpdateData = {
    /**
     * Updated plan details
     */
    body: UpdatePlanRequest;
    path: {
        /**
         * Plan ID
         */
        planId: string;
    };
    query?: never;
    url: '/v1/admin/plans/{planId}';
};

export type SubscriptionPlansAdminUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: PlanResponse | ErrorResponse;
};

export type SubscriptionPlansAdminUpdateResponse = SubscriptionPlansAdminUpdateResponses[keyof SubscriptionPlansAdminUpdateResponses];

export type JobTypesListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/job-types';
};

export type JobTypesListResponses = {
    /**
     * The request has succeeded.
     */
    200: JobTypesListResponse | ErrorResponse;
};

export type JobTypesListResponse2 = JobTypesListResponses[keyof JobTypesListResponses];

export type LegalDocumentsPublicListActiveData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by locale (uses user preference if not specified)
         */
        locale?: string;
    };
    url: '/v1/legal';
};

export type LegalDocumentsPublicListActiveResponses = {
    /**
     * The request has succeeded.
     */
    200: ActiveLegalDocumentsListResponse | ErrorResponse;
};

export type LegalDocumentsPublicListActiveResponse = LegalDocumentsPublicListActiveResponses[keyof LegalDocumentsPublicListActiveResponses];

export type LegalDocumentsPublicAcceptData = {
    /**
     * Acceptance data
     */
    body: AcceptLegalDocumentRequest;
    path?: never;
    query?: never;
    url: '/v1/legal/accept';
};

export type LegalDocumentsPublicAcceptResponses = {
    /**
     * The request has succeeded.
     */
    200: LegalDocumentAcceptanceResponse | ErrorResponse;
};

export type LegalDocumentsPublicAcceptResponse = LegalDocumentsPublicAcceptResponses[keyof LegalDocumentsPublicAcceptResponses];

export type LegalDocumentsPublicGetMyAcceptancesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/legal/my-acceptances';
};

export type LegalDocumentsPublicGetMyAcceptancesResponses = {
    /**
     * The request has succeeded.
     */
    200: MyAcceptancesResponse | ErrorResponse;
};

export type LegalDocumentsPublicGetMyAcceptancesResponse = LegalDocumentsPublicGetMyAcceptancesResponses[keyof LegalDocumentsPublicGetMyAcceptancesResponses];

export type LegalDocumentsPublicCheckPendingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Locale override
         */
        locale?: string;
    };
    url: '/v1/legal/pending';
};

export type LegalDocumentsPublicCheckPendingResponses = {
    /**
     * The request has succeeded.
     */
    200: PendingAcceptancesResponse | ErrorResponse;
};

export type LegalDocumentsPublicCheckPendingResponse = LegalDocumentsPublicCheckPendingResponses[keyof LegalDocumentsPublicCheckPendingResponses];

export type LegalDocumentsPublicGetActiveData = {
    body?: never;
    path: {
        /**
         * Document type
         */
        documentType: LegalDocumentType;
    };
    query?: {
        /**
         * Locale override
         */
        locale?: string;
    };
    url: '/v1/legal/{documentType}';
};

export type LegalDocumentsPublicGetActiveResponses = {
    /**
     * The request has succeeded.
     */
    200: ActiveLegalDocumentResponse | ErrorResponse;
};

export type LegalDocumentsPublicGetActiveResponse = LegalDocumentsPublicGetActiveResponses[keyof LegalDocumentsPublicGetActiveResponses];

export type MigrationGetStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/migration/status';
};

export type MigrationGetStatusResponses = {
    /**
     * The request has succeeded.
     */
    200: MigrationStatusResponse;
};

export type MigrationGetStatusResponse = MigrationGetStatusResponses[keyof MigrationGetStatusResponses];

export type NotificationsListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number (1-indexed, default: 1)
         */
        page?: number;
        /**
         * Number of items per page (max: 100, default: 20)
         */
        pageSize?: number;
        /**
         * Filter by notification channel
         */
        channel?: NotificationChannel;
        /**
         * Filter by notification category
         */
        category?: NotificationCategory;
        /**
         * Filter by notification status
         */
        status?: NotificationStatus;
        /**
         * Filter by read status ("read" or "unread")
         */
        readStatus?: 'read' | 'unread';
        /**
         * Sort order. Use "-field" for descending, "field" for ascending. Supports: sentAt, createdAt
         */
        orderBy?: string;
    };
    url: '/v1/notifications';
};

export type NotificationsListResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationListResponse | ErrorResponse;
};

export type NotificationsListResponse = NotificationsListResponses[keyof NotificationsListResponses];

export type NotificationsMarkAllReadData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/notifications/mark-all-read';
};

export type NotificationsMarkAllReadResponses = {
    /**
     * The request has succeeded.
     */
    200: MarkAllReadResponse | ErrorResponse;
};

export type NotificationsMarkAllReadResponse = NotificationsMarkAllReadResponses[keyof NotificationsMarkAllReadResponses];

export type NotificationsPreviewEmailData = {
    body: PreviewEmailRequest;
    path?: never;
    query?: never;
    url: '/v1/notifications/preview-email';
};

export type NotificationsPreviewEmailResponses = {
    /**
     * The request has succeeded.
     */
    200: PreviewEmailResponse | ErrorResponse;
};

export type NotificationsPreviewEmailResponse = NotificationsPreviewEmailResponses[keyof NotificationsPreviewEmailResponses];

export type NotificationsSendData = {
    body: SendNotificationRequest;
    path?: never;
    query?: never;
    url: '/v1/notifications/send';
};

export type NotificationsSendResponses = {
    /**
     * The request has succeeded.
     */
    200: SendNotificationResponse | ErrorResponse;
};

export type NotificationsSendResponse = NotificationsSendResponses[keyof NotificationsSendResponses];

export type NotificationsGetUnreadCountData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/notifications/unread/count';
};

export type NotificationsGetUnreadCountResponses = {
    /**
     * The request has succeeded.
     */
    200: UnreadCountResponse | ErrorResponse;
};

export type NotificationsGetUnreadCountResponse = NotificationsGetUnreadCountResponses[keyof NotificationsGetUnreadCountResponses];

export type NotificationsDeleteData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}';
};

export type NotificationsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsDeleteResponse = NotificationsDeleteResponses[keyof NotificationsDeleteResponses];

export type NotificationsGetData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}';
};

export type NotificationsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationResponse | ErrorResponse;
};

export type NotificationsGetResponse = NotificationsGetResponses[keyof NotificationsGetResponses];

export type NotificationsMarkReadData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/read';
};

export type NotificationsMarkReadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsMarkReadResponse = NotificationsMarkReadResponses[keyof NotificationsMarkReadResponses];

export type NotificationsRestoreData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/restore';
};

export type NotificationsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsRestoreResponse = NotificationsRestoreResponses[keyof NotificationsRestoreResponses];

export type NotificationsMarkUnreadData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/unread';
};

export type NotificationsMarkUnreadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsMarkUnreadResponse = NotificationsMarkUnreadResponses[keyof NotificationsMarkUnreadResponses];

export type AnnouncementsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed, default: 1)
         */
        page?: number;
        /**
         * Number of items per page (max: 100, default: 20)
         */
        pageSize?: number;
        /**
         * Filter by priority
         */
        priority?: AnnouncementPriority;
        /**
         * Filter by scope
         */
        scope?: AnnouncementScope;
        /**
         * Filter by read status ("read" or "unread")
         */
        readStatus?: 'read' | 'unread';
        /**
         * Filter by dismissed status ("dismissed" or "not-dismissed")
         */
        dismissedStatus?: 'dismissed' | 'not-dismissed';
        /**
         * Include expired announcements (default: false)
         */
        includeExpired?: boolean;
        /**
         * Include inactive announcements (default: false)
         */
        includeInactive?: boolean;
        /**
         * Sort order. Use "-field" for descending. Supports: publishAt, createdAt, priority
         */
        orderBy?: string;
    };
    url: '/v1/orgs/{orgId}/announcements';
};

export type AnnouncementsListResponses = {
    /**
     * The request has succeeded.
     */
    200: AnnouncementListResponse | ErrorResponse;
};

export type AnnouncementsListResponse = AnnouncementsListResponses[keyof AnnouncementsListResponses];

export type AnnouncementsCreateData = {
    /**
     * Announcement data
     */
    body: CreateAnnouncementRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements';
};

export type AnnouncementsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: AnnouncementResponse;
};

export type AnnouncementsCreateResponse = AnnouncementsCreateResponses[keyof AnnouncementsCreateResponses];

export type AnnouncementsGetUnreadCountData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/unread-count';
};

export type AnnouncementsGetUnreadCountResponses = {
    /**
     * The request has succeeded.
     */
    200: UnreadAnnouncementsResponse | ErrorResponse;
};

export type AnnouncementsGetUnreadCountResponse = AnnouncementsGetUnreadCountResponses[keyof AnnouncementsGetUnreadCountResponses];

export type AnnouncementsDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Announcement ID
         */
        announcementId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/{announcementId}';
};

export type AnnouncementsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type AnnouncementsDeleteResponse = AnnouncementsDeleteResponses[keyof AnnouncementsDeleteResponses];

export type AnnouncementsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Announcement ID
         */
        announcementId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/{announcementId}';
};

export type AnnouncementsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: AnnouncementWithInteractionResponse | ErrorResponse;
};

export type AnnouncementsGetResponse = AnnouncementsGetResponses[keyof AnnouncementsGetResponses];

export type AnnouncementsUpdateData = {
    /**
     * Updated announcement data
     */
    body: UpdateAnnouncementRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Announcement ID
         */
        announcementId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/{announcementId}';
};

export type AnnouncementsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: AnnouncementResponse | ErrorResponse;
};

export type AnnouncementsUpdateResponse = AnnouncementsUpdateResponses[keyof AnnouncementsUpdateResponses];

export type AnnouncementsAcknowledgeData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Announcement ID
         */
        announcementId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/acknowledge';
};

export type AnnouncementsAcknowledgeResponses = {
    /**
     * The request has succeeded.
     */
    200: AcknowledgeAnnouncementResponse | ErrorResponse;
};

export type AnnouncementsAcknowledgeResponse = AnnouncementsAcknowledgeResponses[keyof AnnouncementsAcknowledgeResponses];

export type AnnouncementsDismissData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Announcement ID
         */
        announcementId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/dismiss';
};

export type AnnouncementsDismissResponses = {
    /**
     * The request has succeeded.
     */
    200: DismissAnnouncementResponse | ErrorResponse;
};

export type AnnouncementsDismissResponse = AnnouncementsDismissResponses[keyof AnnouncementsDismissResponses];

export type AnnouncementsMarkReadData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Announcement ID
         */
        announcementId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/read';
};

export type AnnouncementsMarkReadResponses = {
    /**
     * The request has succeeded.
     */
    200: MarkReadResponse | ErrorResponse;
};

export type AnnouncementsMarkReadResponse = AnnouncementsMarkReadResponses[keyof AnnouncementsMarkReadResponses];

export type AnnouncementsGetStatsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Announcement ID
         */
        announcementId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/stats';
};

export type AnnouncementsGetStatsResponses = {
    /**
     * The request has succeeded.
     */
    200: AnnouncementStatsResponse | ErrorResponse;
};

export type AnnouncementsGetStatsResponse = AnnouncementsGetStatsResponses[keyof AnnouncementsGetStatsResponses];

export type AnnouncementsMarkViewedData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Announcement ID
         */
        announcementId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/announcements/{announcementId}/view';
};

export type AnnouncementsMarkViewedResponses = {
    /**
     * The request has succeeded.
     */
    200: MarkViewedResponse | ErrorResponse;
};

export type AnnouncementsMarkViewedResponse = AnnouncementsMarkViewedResponses[keyof AnnouncementsMarkViewedResponses];

export type AuditLogsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Filter by event type (e.g., "user.created", "user.*")
         */
        eventType?: string;
        /**
         * Filter by actor ID
         */
        actorId?: string;
        /**
         * Filter by actor type
         */
        actorType?: AuditActorType;
        /**
         * Filter by resource type (e.g., "user", "invoice")
         */
        resourceType?: string;
        /**
         * Filter by resource ID
         */
        resourceId?: string;
        /**
         * Filter events after this timestamp
         */
        timestampAfter?: string;
        /**
         * Filter events before this timestamp
         */
        timestampBefore?: string;
        /**
         * Filter by IP address
         */
        ipAddress?: string;
        /**
         * Filter by request ID
         */
        requestId?: string;
    };
    url: '/v1/orgs/{orgId}/audit-logs';
};

export type AuditLogsListResponses = {
    /**
     * The request has succeeded.
     */
    200: AuditLogListResponse | ErrorResponse;
};

export type AuditLogsListResponse = AuditLogsListResponses[keyof AuditLogsListResponses];

export type AuditLogsExportData = {
    /**
     * Export configuration
     */
    body: {
        /**
         * Export format
         */
        format: 'csv' | 'json';
        /**
         * Filter events after this timestamp
         */
        timestampAfter?: string;
        /**
         * Filter events before this timestamp
         */
        timestampBefore?: string;
        /**
         * Event types to include (empty = all)
         */
        eventTypes?: Array<string>;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/audit-logs/export';
};

export type AuditLogsExportResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        data: {
            /**
             * Download URL (signed, expires in 1 hour)
             */
            downloadUrl: string;
            /**
             * Number of events exported
             */
            eventCount: number;
            /**
             * When the URL expires
             */
            expiresAt: string;
        };
        meta: ResponseMeta;
    } | ErrorResponse;
    /**
     * The request has been accepted for processing, but processing has not yet completed.
     */
    202: AsyncJobResponse;
};

export type AuditLogsExportResponse = AuditLogsExportResponses[keyof AuditLogsExportResponses];

export type AuditLogsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Event ID
         */
        eventId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/audit-logs/{eventId}';
};

export type AuditLogsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: AuditLogResponse | ErrorResponse;
};

export type AuditLogsGetResponse = AuditLogsGetResponses[keyof AuditLogsGetResponses];

export type BackupsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        page?: number;
        pageSize?: number;
        status?: BackupStatus;
    };
    url: '/v1/orgs/{orgId}/backups';
};

export type BackupsListResponses = {
    /**
     * The request has succeeded.
     */
    200: BackupListResponse | ErrorResponse;
};

export type BackupsListResponse = BackupsListResponses[keyof BackupsListResponses];

export type BackupsCreateData = {
    body: CreateBackupRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/backups';
};

export type BackupsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has been accepted for processing, but processing has not yet completed.
     */
    202: BackupResponse;
};

export type BackupsCreateResponse = BackupsCreateResponses[keyof BackupsCreateResponses];

export type BackupsDeleteData = {
    body?: never;
    path: {
        orgId: string;
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/backups/{id}';
};

export type BackupsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type BackupsDeleteResponse = BackupsDeleteResponses[keyof BackupsDeleteResponses];

export type BackupsGetData = {
    body?: never;
    path: {
        orgId: string;
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/backups/{id}';
};

export type BackupsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: BackupResponse | ErrorResponse;
};

export type BackupsGetResponse = BackupsGetResponses[keyof BackupsGetResponses];

export type BackupsDownloadData = {
    body?: never;
    path: {
        orgId: string;
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/backups/{id}/download';
};

export type BackupsDownloadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
};

export type BackupsDownloadResponse = BackupsDownloadResponses[keyof BackupsDownloadResponses];

export type BackupsRestoreData = {
    body?: never;
    path: {
        orgId: string;
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/backups/{id}/restore';
};

export type BackupsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has been accepted for processing, but processing has not yet completed.
     */
    202: BackupResponse;
};

export type BackupsRestoreResponse = BackupsRestoreResponses[keyof BackupsRestoreResponses];

export type ExamplePostsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-createdAt,title" for desc createdAt, then asc title)
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return (e.g., "id,title,status")
         */
        fields?: string;
        /**
         * Comma-separated list of relations to include (e.g., "comments")
         */
        include?: string;
        /**
         * Full-text search query
         */
        search?: string;
        /**
         * Filter by post status (exact match)
         */
        status?: ExamplePostStatus;
        /**
         * Filter by status NOT equal to value
         */
        statusNe?: string;
        /**
         * Filter by status IN list (comma-separated values)
         */
        statusIn?: string;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Filter by title contains
         */
        titleContains?: string;
        /**
         * Filter by content contains
         */
        contentContains?: string;
        /**
         * Filter posts created after this timestamp
         */
        createdAfter?: string;
        /**
         * Filter posts created before this timestamp
         */
        createdBefore?: string;
        /**
         * Filter posts published after this timestamp
         */
        publishedAfter?: string;
        /**
         * Filter posts published before this timestamp
         */
        publishedBefore?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts';
};

export type ExamplePostsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostListResponse | ErrorResponse;
};

export type ExamplePostsListResponse = ExamplePostsListResponses[keyof ExamplePostsListResponses];

export type ExamplePostsCreateData = {
    /**
     * Post creation data
     */
    body: CreateExamplePostRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts';
};

export type ExamplePostsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ExamplePostResponse;
};

export type ExamplePostsCreateResponse = ExamplePostsCreateResponses[keyof ExamplePostsCreateResponses];

export type ExamplePostsBatchUpdateData = {
    /**
     * Batch update request
     */
    body: {
        items?: Array<{
            id: string;
            updates: UpdateExamplePostRequest;
        }>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch';
};

export type ExamplePostsBatchUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type ExamplePostsBatchUpdateResponse = ExamplePostsBatchUpdateResponses[keyof ExamplePostsBatchUpdateResponses];

export type ExamplePostsBatchCreateData = {
    /**
     * Batch create request
     */
    body: {
        items: Array<CreateExamplePostRequest>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch';
};

export type ExamplePostsBatchCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * Generic batch response envelope
     *
     * Uses results array with status field for each item, matching documentation
     */
    201: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    };
};

export type ExamplePostsBatchCreateResponse = ExamplePostsBatchCreateResponses[keyof ExamplePostsBatchCreateResponses];

export type ExamplePostsBatchRestoreData = {
    /**
     * Post IDs to restore
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch/restore';
};

export type ExamplePostsBatchRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type ExamplePostsBatchRestoreResponse = ExamplePostsBatchRestoreResponses[keyof ExamplePostsBatchRestoreResponses];

export type ExamplePostsBatchSoftDeleteData = {
    /**
     * Post IDs to soft delete
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch/soft-delete';
};

export type ExamplePostsBatchSoftDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: BatchDeleteResponse | ErrorResponse;
};

export type ExamplePostsBatchSoftDeleteResponse = ExamplePostsBatchSoftDeleteResponses[keyof ExamplePostsBatchSoftDeleteResponses];

export type ExamplePostsListCursorData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Cursor for fetching next page (post ID from previous response)
         */
        cursor?: string;
        /**
         * Maximum items to return (max: 100, default: 50)
         */
        limit?: number;
        /**
         * Sort order (e.g., "-createdAt" for desc, "createdAt" for asc)
         */
        orderBy?: string;
        /**
         * Filter by post status
         */
        status?: ExamplePostStatus;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Full-text search query
         */
        search?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/cursor';
};

export type ExamplePostsListCursorResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostCursorListResponse | ErrorResponse;
};

export type ExamplePostsListCursorResponse = ExamplePostsListCursorResponses[keyof ExamplePostsListCursorResponses];

export type ExamplePostsListDeletedData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Items per page (max 100)
         */
        pageSize?: number;
    };
    url: '/v1/orgs/{orgId}/example-posts/deleted';
};

export type ExamplePostsListDeletedResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostListResponse | ErrorResponse;
};

export type ExamplePostsListDeletedResponse = ExamplePostsListDeletedResponses[keyof ExamplePostsListDeletedResponses];

export type ExamplePostsDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type ExamplePostsDeleteResponse = ExamplePostsDeleteResponses[keyof ExamplePostsDeleteResponses];

export type ExamplePostsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Comma-separated list of relations to include
         */
        include?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsGetResponse = ExamplePostsGetResponses[keyof ExamplePostsGetResponses];

export type ExamplePostsUpdateData = {
    /**
     * Post update data
     */
    body: UpdateExamplePostRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsUpdateResponse = ExamplePostsUpdateResponses[keyof ExamplePostsUpdateResponses];

export type ExamplePostsDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}/permanent';
};

export type ExamplePostsDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type ExamplePostsDeletePermanentResponse = ExamplePostsDeletePermanentResponses[keyof ExamplePostsDeletePermanentResponses];

export type ExamplePostsRestoreData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}/restore';
};

export type ExamplePostsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsRestoreResponse = ExamplePostsRestoreResponses[keyof ExamplePostsRestoreResponses];

export type ExampleCommentsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-createdAt" for newest first)
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Filter by content contains
         */
        contentContains?: string;
        /**
         * Filter comments created after this timestamp
         */
        createdAfter?: string;
        /**
         * Filter comments created before this timestamp
         */
        createdBefore?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments';
};

export type ExampleCommentsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentListResponse | ErrorResponse;
};

export type ExampleCommentsListResponse = ExampleCommentsListResponses[keyof ExampleCommentsListResponses];

export type ExampleCommentsCreateData = {
    /**
     * Comment creation data
     */
    body: CreateExampleCommentRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments';
};

export type ExampleCommentsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ExampleCommentResponse;
};

export type ExampleCommentsCreateResponse = ExampleCommentsCreateResponses[keyof ExampleCommentsCreateResponses];

export type ExampleCommentsBatchCreateData = {
    /**
     * Batch create request
     */
    body: {
        items: Array<CreateExampleCommentRequest>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch';
};

export type ExampleCommentsBatchCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * Generic batch response envelope
     *
     * Uses results array with status field for each item, matching documentation
     */
    201: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExampleComment;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    };
};

export type ExampleCommentsBatchCreateResponse = ExampleCommentsBatchCreateResponses[keyof ExampleCommentsBatchCreateResponses];

export type ExampleCommentsBatchSoftDeleteData = {
    /**
     * Comment IDs to soft delete
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch/soft-delete';
};

export type ExampleCommentsBatchSoftDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: BatchDeleteResponse | ErrorResponse;
};

export type ExampleCommentsBatchSoftDeleteResponse = ExampleCommentsBatchSoftDeleteResponses[keyof ExampleCommentsBatchSoftDeleteResponses];

export type ExampleCommentsDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type ExampleCommentsDeleteResponse = ExampleCommentsDeleteResponses[keyof ExampleCommentsDeleteResponses];

export type ExampleCommentsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsGetResponse = ExampleCommentsGetResponses[keyof ExampleCommentsGetResponses];

export type ExampleCommentsUpdateData = {
    /**
     * Comment update data
     */
    body: UpdateExampleCommentRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsUpdateResponse = ExampleCommentsUpdateResponses[keyof ExampleCommentsUpdateResponses];

export type ExampleCommentsDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/permanent';
};

export type ExampleCommentsDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type ExampleCommentsDeletePermanentResponse = ExampleCommentsDeletePermanentResponses[keyof ExampleCommentsDeletePermanentResponses];

export type ExampleCommentsRestoreData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/restore';
};

export type ExampleCommentsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsRestoreResponse = ExampleCommentsRestoreResponses[keyof ExampleCommentsRestoreResponses];

export type FilesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-uploadedAt,filename")
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Filter by MIME type
         */
        mimeType?: string;
        /**
         * Filter by file kind
         */
        kind?: FileKind;
        /**
         * Filter by virus scan status
         */
        virusScanStatus?: VirusScanStatus;
        /**
         * Filter by access level
         */
        access?: FileAccess;
        /**
         * Filter files uploaded after this timestamp
         */
        uploadedAfter?: string;
        /**
         * Filter files uploaded before this timestamp
         */
        uploadedBefore?: string;
        /**
         * Filter by uploader user ID
         */
        uploadedBy?: string;
    };
    url: '/v1/orgs/{orgId}/files';
};

export type FilesListResponses = {
    /**
     * The request has succeeded.
     */
    200: FileListResponse | ErrorResponse;
};

export type FilesListResponse = FilesListResponses[keyof FilesListResponses];

export type FilesDirectUploadData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files';
};

export type FilesDirectUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: FileResponse;
};

export type FilesDirectUploadResponse = FilesDirectUploadResponses[keyof FilesDirectUploadResponses];

export type FilesInitiateUploadData = {
    /**
     * Upload request with file metadata
     */
    body: InitiateUploadRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/uploads';
};

export type FilesInitiateUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: InitiateUploadResponse | ErrorResponse;
};

export type FilesInitiateUploadResponse = FilesInitiateUploadResponses[keyof FilesInitiateUploadResponses];

export type FilesConfirmUploadData = {
    /**
     * Confirmation data
     */
    body: ConfirmUploadRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Upload ID from initiate response
         */
        uploadId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/uploads/{uploadId}/confirm';
};

export type FilesConfirmUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: FileResponse;
};

export type FilesConfirmUploadResponse = FilesConfirmUploadResponses[keyof FilesConfirmUploadResponses];

export type FilesDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: FileDeleteResponse | ErrorResponse;
};

export type FilesDeleteResponse = FilesDeleteResponses[keyof FilesDeleteResponses];

export type FilesGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
    };
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: FileResponse | ErrorResponse;
};

export type FilesGetResponse = FilesGetResponses[keyof FilesGetResponses];

export type FilesUpdateData = {
    /**
     * Update request
     */
    body: UpdateFileRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: FileResponse | ErrorResponse;
};

export type FilesUpdateResponse = FilesUpdateResponses[keyof FilesUpdateResponses];

export type FilesDownloadData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}/download';
};

export type FilesDownloadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
};

export type FilesDownloadResponse = FilesDownloadResponses[keyof FilesDownloadResponses];

export type FilesDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}/permanent';
};

export type FilesDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type FilesDeletePermanentResponse = FilesDeletePermanentResponses[keyof FilesDeletePermanentResponses];

export type JobsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by job status
         */
        status?: JobStatus;
        /**
         * Filter by job type (e.g., "report", "import")
         */
        type?: string;
        /**
         * Filter by format (for report jobs)
         */
        format?: string;
        /**
         * Filter by template ID (for report jobs)
         */
        templateId?: string;
        /**
         * Filter jobs created after this timestamp
         */
        createdAfter?: string;
        /**
         * Filter jobs created before this timestamp
         */
        createdBefore?: string;
    };
    url: '/v1/orgs/{orgId}/jobs';
};

export type JobsListResponses = {
    /**
     * The request has succeeded.
     */
    200: JobListResponse | ErrorResponse;
};

export type JobsListResponse = JobsListResponses[keyof JobsListResponses];

export type JobsCreateData = {
    /**
     * Job creation request
     */
    body: CreateJobRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs';
};

export type JobsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type JobsCreateResponse = JobsCreateResponses[keyof JobsCreateResponses];

export type JobsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Job ID
         */
        jobId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs/{jobId}';
};

export type JobsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type JobsGetResponse = JobsGetResponses[keyof JobsGetResponses];

export type JobsCancelData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Job ID
         */
        jobId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs/{jobId}/cancel';
};

export type JobsCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type JobsCancelResponse = JobsCancelResponses[keyof JobsCancelResponses];

export type JobsDownloadData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Job ID
         */
        jobId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs/{jobId}/download';
};

export type JobsDownloadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
};

export type JobsDownloadResponse = JobsDownloadResponses[keyof JobsDownloadResponses];

export type JobsRetryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Job ID
         */
        jobId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs/{jobId}/retry';
};

export type JobsRetryResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type JobsRetryResponse = JobsRetryResponses[keyof JobsRetryResponses];

export type ReportExportsExportData = {
    /**
     * Export request
     */
    body: ExportRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/reports/export';
};

export type ReportExportsExportResponses = {
    /**
     * The request has succeeded.
     */
    200: AsyncExportResponse | ErrorResponse;
};

export type ReportExportsExportResponse = ReportExportsExportResponses[keyof ReportExportsExportResponses];

export type ReportExportsPreviewExportData = {
    /**
     * Export request with limit
     */
    body: {
        /**
         * Report template ID (optional, for template-based exports)
         */
        templateId?: string;
        /**
         * Output format (required if no templateId)
         */
        format?: ReportFormat;
        /**
         * Data to export (for client-side data)
         */
        data?: Array<unknown>;
        /**
         * Column definitions (required if no templateId)
         */
        columns?: Array<ReportColumnConfig>;
        /**
         * Format-specific options
         */
        options?: ReportOptions;
        /**
         * Filters to apply to data source
         */
        filters?: {
            [key: string]: unknown;
        };
        /**
         * Sort configuration
         */
        sort?: Array<{
            field: string;
            direction: 'asc' | 'desc';
        }>;
        /**
         * Additional parameters for template
         */
        parameters?: {
            [key: string]: unknown;
        };
        /**
         * Export only selected rows (by ID)
         */
        selectedIds?: Array<string>;
        /**
         * Use async processing (returns job ID)
         */
        async?: boolean;
        /**
         * Maximum rows to preview (default: 10, max: 100)
         */
        limit?: number;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/reports/export/preview';
};

export type ReportExportsPreviewExportResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        data: {
            /**
             * Preview rows
             */
            rows: Array<unknown>;
            /**
             * Total row count (if known)
             */
            totalCount?: number;
            /**
             * Column headers
             */
            columns: Array<string>;
        };
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type ReportExportsPreviewExportResponse = ReportExportsPreviewExportResponses[keyof ReportExportsPreviewExportResponses];

export type ReportExportsStreamExportData = {
    /**
     * Stream export request
     */
    body: StreamExportRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/reports/export/stream';
};

export type ReportExportsStreamExportResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
};

export type ReportExportsStreamExportResponse = ReportExportsStreamExportResponses[keyof ReportExportsStreamExportResponses];

export type ReportTemplatesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-createdAt,name")
         */
        orderBy?: string;
        /**
         * Filter by format
         */
        format?: ReportFormat;
        /**
         * Filter by public templates only
         */
        isPublic?: boolean;
        /**
         * Full-text search in name and description
         */
        search?: string;
        /**
         * Filter templates created by specific user
         */
        createdBy?: string;
    };
    url: '/v1/orgs/{orgId}/reports/templates';
};

export type ReportTemplatesListResponses = {
    /**
     * The request has succeeded.
     */
    200: ReportTemplateListResponse | ErrorResponse;
};

export type ReportTemplatesListResponse = ReportTemplatesListResponses[keyof ReportTemplatesListResponses];

export type ReportTemplatesCreateData = {
    /**
     * Template data
     */
    body: CreateReportTemplateRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/reports/templates';
};

export type ReportTemplatesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ReportTemplateResponse;
};

export type ReportTemplatesCreateResponse = ReportTemplatesCreateResponses[keyof ReportTemplatesCreateResponses];

export type ReportTemplatesDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Template ID
         */
        templateId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}';
};

export type ReportTemplatesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type ReportTemplatesDeleteResponse = ReportTemplatesDeleteResponses[keyof ReportTemplatesDeleteResponses];

export type ReportTemplatesGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Template ID
         */
        templateId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}';
};

export type ReportTemplatesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ReportTemplateResponse | ErrorResponse;
};

export type ReportTemplatesGetResponse = ReportTemplatesGetResponses[keyof ReportTemplatesGetResponses];

export type ReportTemplatesUpdateData = {
    /**
     * Template update data
     */
    body: UpdateReportTemplateRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Template ID
         */
        templateId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}';
};

export type ReportTemplatesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ReportTemplateResponse | ErrorResponse;
};

export type ReportTemplatesUpdateResponse = ReportTemplatesUpdateResponses[keyof ReportTemplatesUpdateResponses];

export type ReportTemplatesCloneData = {
    /**
     * New template name
     */
    body: {
        name: string;
        description?: string;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Template ID to clone
         */
        templateId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/reports/templates/{templateId}/clone';
};

export type ReportTemplatesCloneResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ReportTemplateResponse;
};

export type ReportTemplatesCloneResponse = ReportTemplatesCloneResponses[keyof ReportTemplatesCloneResponses];

export type TenantRolesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by system role status
         */
        isSystemRole?: boolean;
    };
    url: '/v1/orgs/{orgId}/roles';
};

export type TenantRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleListResponse | ErrorResponse;
};

export type TenantRolesListResponse = TenantRolesListResponses[keyof TenantRolesListResponses];

export type TenantRolesCreateData = {
    /**
     * Role data
     */
    body: CreateRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles';
};

export type TenantRolesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: RoleResponse;
};

export type TenantRolesCreateResponse = TenantRolesCreateResponses[keyof TenantRolesCreateResponses];

export type TenantRolesDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type TenantRolesDeleteResponse = TenantRolesDeleteResponses[keyof TenantRolesDeleteResponses];

export type TenantRolesGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type TenantRolesGetResponse = TenantRolesGetResponses[keyof TenantRolesGetResponses];

export type TenantRolesUpdateData = {
    /**
     * Role update data
     */
    body: UpdateRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type TenantRolesUpdateResponse = TenantRolesUpdateResponses[keyof TenantRolesUpdateResponses];

export type ScheduledJobsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Sort order
         */
        orderBy?: string;
        /**
         * Filter by job type
         */
        jobType?: string;
        /**
         * Filter by frequency
         */
        frequency?: ScheduleFrequency;
        /**
         * Filter by delivery method
         */
        deliveryMethod?: JobDeliveryMethod;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Full-text search
         */
        search?: string;
    };
    url: '/v1/orgs/{orgId}/schedules';
};

export type ScheduledJobsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ScheduledJobListResponse | ErrorResponse;
};

export type ScheduledJobsListResponse = ScheduledJobsListResponses[keyof ScheduledJobsListResponses];

export type ScheduledJobsCreateData = {
    /**
     * Schedule data
     */
    body: CreateScheduledJobRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/schedules';
};

export type ScheduledJobsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ScheduledJobResponse;
};

export type ScheduledJobsCreateResponse = ScheduledJobsCreateResponses[keyof ScheduledJobsCreateResponses];

export type ScheduledJobsDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Schedule ID
         */
        scheduleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/schedules/{scheduleId}';
};

export type ScheduledJobsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type ScheduledJobsDeleteResponse = ScheduledJobsDeleteResponses[keyof ScheduledJobsDeleteResponses];

export type ScheduledJobsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Schedule ID
         */
        scheduleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/schedules/{scheduleId}';
};

export type ScheduledJobsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ScheduledJobResponse | ErrorResponse;
};

export type ScheduledJobsGetResponse = ScheduledJobsGetResponses[keyof ScheduledJobsGetResponses];

export type ScheduledJobsUpdateData = {
    /**
     * Schedule update data
     */
    body: UpdateScheduledJobRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Schedule ID
         */
        scheduleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/schedules/{scheduleId}';
};

export type ScheduledJobsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ScheduledJobResponse | ErrorResponse;
};

export type ScheduledJobsUpdateResponse = ScheduledJobsUpdateResponses[keyof ScheduledJobsUpdateResponses];

export type ScheduledJobsGetHistoryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Schedule ID
         */
        scheduleId: string;
    };
    query?: {
        /**
         * Number of history items to return
         */
        limit?: number;
    };
    url: '/v1/orgs/{orgId}/schedules/{scheduleId}/history';
};

export type ScheduledJobsGetHistoryResponses = {
    /**
     * The request has succeeded.
     */
    200: ScheduledJobHistoryResponse | ErrorResponse;
};

export type ScheduledJobsGetHistoryResponse = ScheduledJobsGetHistoryResponses[keyof ScheduledJobsGetHistoryResponses];

export type ScheduledJobsPauseData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Schedule ID
         */
        scheduleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/schedules/{scheduleId}/pause';
};

export type ScheduledJobsPauseResponses = {
    /**
     * The request has succeeded.
     */
    200: ScheduledJobResponse | ErrorResponse;
};

export type ScheduledJobsPauseResponse = ScheduledJobsPauseResponses[keyof ScheduledJobsPauseResponses];

export type ScheduledJobsResumeData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Schedule ID
         */
        scheduleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/schedules/{scheduleId}/resume';
};

export type ScheduledJobsResumeResponses = {
    /**
     * The request has succeeded.
     */
    200: ScheduledJobResponse | ErrorResponse;
};

export type ScheduledJobsResumeResponse = ScheduledJobsResumeResponses[keyof ScheduledJobsResumeResponses];

export type ScheduledJobsRunNowData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Schedule ID
         */
        scheduleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/schedules/{scheduleId}/run';
};

export type ScheduledJobsRunNowResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type ScheduledJobsRunNowResponse = ScheduledJobsRunNowResponses[keyof ScheduledJobsRunNowResponses];

export type SubscriptionsCreateData = {
    /**
     * Subscription details
     */
    body: CreateSubscriptionRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/subscriptions';
};

export type SubscriptionsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: CreateSubscriptionResponse;
};

export type SubscriptionsCreateResponse = SubscriptionsCreateResponses[keyof SubscriptionsCreateResponses];

export type SubscriptionsGetCurrentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query: {
        /**
         * Application ID
         */
        applicationId: string;
    };
    url: '/v1/orgs/{orgId}/subscriptions/current';
};

export type SubscriptionsGetCurrentResponses = {
    /**
     * The request has succeeded.
     */
    200: SubscriptionResponse | ErrorResponse;
};

export type SubscriptionsGetCurrentResponse = SubscriptionsGetCurrentResponses[keyof SubscriptionsGetCurrentResponses];

export type SubscriptionsValidateCouponData = {
    /**
     * Coupon validation details
     */
    body: ValidateCouponRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/subscriptions/validate-coupon';
};

export type SubscriptionsValidateCouponResponses = {
    /**
     * The request has succeeded.
     */
    200: ValidateCouponResponse | ErrorResponse;
};

export type SubscriptionsValidateCouponResponse = SubscriptionsValidateCouponResponses[keyof SubscriptionsValidateCouponResponses];

export type SubscriptionsUpdateData = {
    /**
     * Update details
     */
    body: UpdateSubscriptionRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Subscription ID
         */
        subscriptionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/subscriptions/{subscriptionId}';
};

export type SubscriptionsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: SubscriptionResponse | ErrorResponse;
};

export type SubscriptionsUpdateResponse = SubscriptionsUpdateResponses[keyof SubscriptionsUpdateResponses];

export type SubscriptionsCancelData = {
    /**
     * Cancellation options
     */
    body?: CancelSubscriptionRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Subscription ID
         */
        subscriptionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/subscriptions/{subscriptionId}/cancel';
};

export type SubscriptionsCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: SubscriptionResponse | ErrorResponse;
};

export type SubscriptionsCancelResponse = SubscriptionsCancelResponses[keyof SubscriptionsCancelResponses];

export type SubscriptionsApplyCouponData = {
    /**
     * Coupon details
     */
    body: ApplyCouponRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Subscription ID
         */
        subscriptionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/subscriptions/{subscriptionId}/coupon';
};

export type SubscriptionsApplyCouponResponses = {
    /**
     * The request has succeeded.
     */
    200: SubscriptionResponse | ErrorResponse;
};

export type SubscriptionsApplyCouponResponse = SubscriptionsApplyCouponResponses[keyof SubscriptionsApplyCouponResponses];

export type SubscriptionsResumeData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Subscription ID
         */
        subscriptionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/subscriptions/{subscriptionId}/resume';
};

export type SubscriptionsResumeResponses = {
    /**
     * The request has succeeded.
     */
    200: SubscriptionResponse | ErrorResponse;
};

export type SubscriptionsResumeResponse = SubscriptionsResumeResponses[keyof SubscriptionsResumeResponses];

export type UserPermissionsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/permissions';
};

export type UserPermissionsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: UserEffectivePermissionsResponse | ErrorResponse;
};

export type UserPermissionsGetResponse = UserPermissionsGetResponses[keyof UserPermissionsGetResponses];

export type UserTenantRolesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles';
};

export type UserTenantRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserRoleAssignmentListResponse | ErrorResponse;
};

export type UserTenantRolesListResponse = UserTenantRolesListResponses[keyof UserTenantRolesListResponses];

export type UserTenantRolesAssignData = {
    /**
     * Role assignment
     */
    body: AssignRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles';
};

export type UserTenantRolesAssignResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: UserRoleAssignmentResponse;
};

export type UserTenantRolesAssignResponse = UserTenantRolesAssignResponses[keyof UserTenantRolesAssignResponses];

export type UserTenantRolesRemoveData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
        /**
         * Role ID to remove
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles/{roleId}';
};

export type UserTenantRolesRemoveResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type UserTenantRolesRemoveResponse = UserTenantRolesRemoveResponses[keyof UserTenantRolesRemoveResponses];

export type WebhooksListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by active status
         */
        isActive?: boolean;
    };
    url: '/v1/orgs/{orgId}/webhooks';
};

export type WebhooksListResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookListResponse | ErrorResponse;
};

export type WebhooksListResponse = WebhooksListResponses[keyof WebhooksListResponses];

export type WebhooksCreateData = {
    /**
     * Webhook configuration
     */
    body: CreateWebhookRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks';
};

export type WebhooksCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: WebhookCreatedResponse;
};

export type WebhooksCreateResponse = WebhooksCreateResponses[keyof WebhooksCreateResponses];

export type WebhooksListEventTypesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/event-types';
};

export type WebhooksListEventTypesResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookEventTypesResponse | ErrorResponse;
};

export type WebhooksListEventTypesResponse = WebhooksListEventTypesResponses[keyof WebhooksListEventTypesResponses];

export type WebhooksDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type WebhooksDeleteResponse = WebhooksDeleteResponses[keyof WebhooksDeleteResponses];

export type WebhooksGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksGetResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookResponse | ErrorResponse;
};

export type WebhooksGetResponse = WebhooksGetResponses[keyof WebhooksGetResponses];

export type WebhooksUpdateData = {
    /**
     * Update data
     */
    body: UpdateWebhookRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookResponse | ErrorResponse;
};

export type WebhooksUpdateResponse = WebhooksUpdateResponses[keyof WebhooksUpdateResponses];

export type WebhooksListDeliveriesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Items per page
         */
        pageSize?: number;
        /**
         * Filter by status
         */
        status?: WebhookDeliveryStatus;
        /**
         * Filter by event type
         */
        eventType?: string;
        /**
         * Filter deliveries after this timestamp
         */
        createdAfter?: string;
    };
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries';
};

export type WebhooksListDeliveriesResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryListResponse | ErrorResponse;
};

export type WebhooksListDeliveriesResponse = WebhooksListDeliveriesResponses[keyof WebhooksListDeliveriesResponses];

export type WebhooksGetDeliveryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
        /**
         * Delivery ID
         */
        deliveryId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}';
};

export type WebhooksGetDeliveryResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryResponse | ErrorResponse;
};

export type WebhooksGetDeliveryResponse = WebhooksGetDeliveryResponses[keyof WebhooksGetDeliveryResponses];

export type WebhooksRetryDeliveryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
        /**
         * Delivery ID
         */
        deliveryId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}/retry';
};

export type WebhooksRetryDeliveryResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryResponse | ErrorResponse;
};

export type WebhooksRetryDeliveryResponse = WebhooksRetryDeliveryResponses[keyof WebhooksRetryDeliveryResponses];

export type WebhooksRotateSecretData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/rotate-secret';
};

export type WebhooksRotateSecretResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookCreatedResponse | ErrorResponse;
};

export type WebhooksRotateSecretResponse = WebhooksRotateSecretResponses[keyof WebhooksRotateSecretResponses];

export type WebhooksTestData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/test';
};

export type WebhooksTestResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        data: {
            /**
             * Whether the test was successful
             */
            success: boolean;
            /**
             * HTTP status code from the webhook endpoint
             */
            httpStatus?: number;
            /**
             * Response time in milliseconds
             */
            durationMs?: number;
            /**
             * Error message if failed
             */
            error?: string;
        };
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type WebhooksTestResponse = WebhooksTestResponses[keyof WebhooksTestResponses];

export type NotificationPreferencesRoutesGetPreferencesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/preferences';
};

export type NotificationPreferencesRoutesGetPreferencesResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationPreferencesResponse | ErrorResponse;
};

export type NotificationPreferencesRoutesGetPreferencesResponse = NotificationPreferencesRoutesGetPreferencesResponses[keyof NotificationPreferencesRoutesGetPreferencesResponses];

export type NotificationPreferencesRoutesUpdatePreferencesData = {
    body: UpdatePreferencesRequest;
    path?: never;
    query?: never;
    url: '/v1/preferences';
};

export type NotificationPreferencesRoutesUpdatePreferencesResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationPreferencesResponse | ErrorResponse;
};

export type NotificationPreferencesRoutesUpdatePreferencesResponse = NotificationPreferencesRoutesUpdatePreferencesResponses[keyof NotificationPreferencesRoutesUpdatePreferencesResponses];

export type PublicPricingListPublicPlansData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by application ID
         */
        applicationId?: string;
        /**
         * Filter by billing period
         */
        billingPeriod?: PlanBillingPeriod;
        /**
         * Include popular badge
         */
        includePopular?: boolean;
    };
    url: '/v1/pricing/plans';
};

export type PublicPricingListPublicPlansResponses = {
    /**
     * The request has succeeded.
     */
    200: PlanListResponse | ErrorResponse;
};

export type PublicPricingListPublicPlansResponse = PublicPricingListPublicPlansResponses[keyof PublicPricingListPublicPlansResponses];

export type GlobalRolesListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by system role status
         */
        isSystemRole?: boolean;
    };
    url: '/v1/roles';
};

export type GlobalRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleListResponse | ErrorResponse;
};

export type GlobalRolesListResponse = GlobalRolesListResponses[keyof GlobalRolesListResponses];

export type GlobalRolesCreateData = {
    /**
     * Role data
     */
    body: CreateRoleRequest;
    path?: never;
    query?: never;
    url: '/v1/roles';
};

export type GlobalRolesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: RoleResponse;
};

export type GlobalRolesCreateResponse = GlobalRolesCreateResponses[keyof GlobalRolesCreateResponses];

export type GlobalRolesDeleteData = {
    body?: never;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type GlobalRolesDeleteResponse = GlobalRolesDeleteResponses[keyof GlobalRolesDeleteResponses];

export type GlobalRolesGetData = {
    body?: never;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type GlobalRolesGetResponse = GlobalRolesGetResponses[keyof GlobalRolesGetResponses];

export type GlobalRolesUpdateData = {
    /**
     * Role update data
     */
    body: UpdateRoleRequest;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type GlobalRolesUpdateResponse = GlobalRolesUpdateResponses[keyof GlobalRolesUpdateResponses];

export type SystemOrganizationsListData = {
    body?: never;
    path?: never;
    query?: {
        page?: number;
        pageSize?: number;
        search?: string;
    };
    url: '/v1/system-organizations';
};

export type SystemOrganizationsListErrors = {
    /**
     * Access is unauthorized.
     */
    401: unknown;
    /**
     * Access is forbidden.
     */
    403: unknown;
};

export type SystemOrganizationsListResponses = {
    /**
     * The request has succeeded.
     */
    200: SystemOrganizationListResponse;
};

export type SystemOrganizationsListResponse = SystemOrganizationsListResponses[keyof SystemOrganizationsListResponses];

export type SystemOrganizationsDeleteData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/system-organizations/{id}';
};

export type SystemOrganizationsDeleteErrors = {
    /**
     * Access is unauthorized.
     */
    401: unknown;
    /**
     * Access is forbidden.
     */
    403: unknown;
    /**
     * The server cannot find the requested resource.
     */
    404: unknown;
};

export type SystemOrganizationsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse;
};

export type SystemOrganizationsDeleteResponse = SystemOrganizationsDeleteResponses[keyof SystemOrganizationsDeleteResponses];

export type SystemOrganizationsUpdateData = {
    body: UpdateSystemOrganizationRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/system-organizations/{id}';
};

export type SystemOrganizationsUpdateErrors = {
    /**
     * Access is unauthorized.
     */
    401: unknown;
    /**
     * Access is forbidden.
     */
    403: unknown;
    /**
     * The server cannot find the requested resource.
     */
    404: unknown;
};

export type SystemOrganizationsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: SystemOrganizationResponse;
};

export type SystemOrganizationsUpdateResponse = SystemOrganizationsUpdateResponses[keyof SystemOrganizationsUpdateResponses];

export type AvailableContextsListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/me/available-contexts';
};

export type AvailableContextsListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserContextListResponse | ErrorResponse;
};

export type AvailableContextsListResponse = AvailableContextsListResponses[keyof AvailableContextsListResponses];

export type CurrentUserContextGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/me/context';
};

export type CurrentUserContextGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ActiveContextResponse | ErrorResponse;
};

export type CurrentUserContextGetResponse = CurrentUserContextGetResponses[keyof CurrentUserContextGetResponses];

export type ContextSwitchSwitchData = {
    /**
     * Target context
     */
    body: SwitchContextRequest;
    path?: never;
    query?: never;
    url: '/v1/users/me/switch-context';
};

export type ContextSwitchSwitchResponses = {
    /**
     * The request has succeeded.
     */
    200: SwitchContextResponse | ErrorResponse;
};

export type ContextSwitchSwitchResponse = ContextSwitchSwitchResponses[keyof ContextSwitchSwitchResponses];

export type AllUserRolesListData = {
    body?: never;
    path: {
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/users/{userId}/roles';
};

export type AllUserRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserRoleAssignmentListResponse | ErrorResponse;
};

export type AllUserRolesListResponse = AllUserRolesListResponses[keyof AllUserRolesListResponses];

export type PaymentWebhooksHandleMidtransData = {
    /**
     * Webhook payload
     */
    body: {
        [key: string]: unknown;
    };
    path?: never;
    query?: never;
    url: '/v1/webhooks/payments/midtrans';
};

export type PaymentWebhooksHandleMidtransResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookAcknowledgment | ErrorResponse;
};

export type PaymentWebhooksHandleMidtransResponse = PaymentWebhooksHandleMidtransResponses[keyof PaymentWebhooksHandleMidtransResponses];

export type PaymentWebhooksHandleXenditData = {
    /**
     * Webhook payload
     */
    body: {
        [key: string]: unknown;
    };
    headers: {
        /**
         * Xendit callback token (signature)
         */
        'x-callback-token': string;
    };
    path?: never;
    query?: never;
    url: '/v1/webhooks/payments/xendit';
};

export type PaymentWebhooksHandleXenditResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookAcknowledgment | ErrorResponse;
};

export type PaymentWebhooksHandleXenditResponse = PaymentWebhooksHandleXenditResponses[keyof PaymentWebhooksHandleXenditResponses];
