// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.example.com' | 'http://localhost:3001' | (string & {});
};

/**
 * User's active context (current app/tenant selection)
 */
export type ActiveContext = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Currently active application ID
     */
    activeApplicationId: string;
    /**
     * Currently active tenant ID (null if no tenant selected)
     */
    activeTenantId?: string;
    /**
     * When the context was last updated
     */
    updatedAt: string;
};

/**
 * Active context response
 */
export type ActiveContextResponse = {
    data: ActiveContext;
    meta: ResponseMeta;
};

/**
 * Request to assign a role to a user
 */
export type AssignRoleRequest = {
    /**
     * Role ID to assign
     */
    roleId: string;
};

/**
 * Response for async operations that return 202 Accepted
 */
export type AsyncJobResponse = {
    /**
     * Unique job identifier
     */
    jobId: string;
    /**
     * Current job status
     */
    status: 'pending' | 'processing' | 'completed' | 'failed';
    /**
     * URL to check job status
     */
    statusUrl: string;
    /**
     * Estimated completion time
     */
    estimatedCompletion?: string;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Actor who performed the action
 */
export type AuditActor = {
    /**
     * Type of actor
     */
    type: AuditActorType;
    /**
     * Actor ID (user ID, service account ID, or "system")
     */
    id: string;
    /**
     * Actor email (for users)
     */
    email?: string;
    /**
     * IP address of the actor
     */
    ipAddress?: string;
    /**
     * User agent string
     */
    userAgent?: string;
};

/**
 * Actor type - who performed the action
 */
export type AuditActorType = 'user' | 'service' | 'system';

/**
 * Change record for a single field
 */
export type AuditChange = {
    /**
     * Value before the change
     */
    old: unknown;
    /**
     * Value after the change
     */
    new: unknown;
};

/**
 * Audit log entry
 *
 * Immutable record of an action in the system.
 */
export type AuditLog = {
    /**
     * Unique event identifier (format: evt_abc123)
     */
    eventId: string;
    /**
     * Event type (format: resource.action)
     */
    eventType: string;
    /**
     * When the event occurred
     */
    timestamp: string;
    /**
     * Tenant where the event occurred
     */
    tenantId: string;
    /**
     * Who performed the action
     */
    actor: AuditActor;
    /**
     * What resource was affected
     */
    resource: AuditResource;
    /**
     * Changes made (for update operations)
     */
    changes?: {
        [key: string]: AuditChange;
    };
    /**
     * Full resource state before the action (for deletes, sensitive ops)
     */
    resourceBefore?: {
        [key: string]: unknown;
    };
    /**
     * Full resource state after the action (for creates, sensitive ops)
     */
    resourceAfter?: {
        [key: string]: unknown;
    };
    /**
     * Additional context
     */
    metadata?: AuditMetadata;
};

/**
 * Audit log list response
 */
export type AuditLogListResponse = {
    data: Array<AuditLog>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single audit log response
 */
export type AuditLogResponse = {
    data: AuditLog;
    meta: ResponseMeta;
};

/**
 * Additional metadata for the audit event
 */
export type AuditMetadata = {
    /**
     * Request ID for correlation
     */
    requestId?: string;
    /**
     * Session ID
     */
    sessionId?: string;
    /**
     * Reason for the action (if provided)
     */
    reason?: string;
    /**
     * Additional context-specific data
     */
    extra?: {
        [key: string]: unknown;
    };
};

/**
 * Resource affected by the action
 */
export type AuditResource = {
    /**
     * Resource type
     */
    type: string;
    /**
     * Resource ID
     */
    id: string;
    /**
     * API endpoint that was called
     */
    endpoint?: string;
    /**
     * HTTP method used
     */
    method?: string;
};

/**
 * Batch delete response envelope
 */
export type BatchDeleteResponse = {
    /**
     * Results for each item in the batch
     */
    results: Array<BatchDeleteResult>;
    /**
     * Summary of operation results
     */
    summary: BatchSummary;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Batch delete result (soft delete)
 */
export type BatchDeleteResult = {
    /**
     * Index of the item in the original request array
     */
    index: number;
    /**
     * Status of the operation for this item
     */
    status: 'success' | 'error' | 'skipped';
    /**
     * Deleted item info (present if status is success)
     */
    data?: {
        /**
         * ID of the deleted item
         */
        id: string;
        /**
         * Timestamp when the item was deleted
         */
        deletedAt: string;
    };
    /**
     * Error details (present if status is error)
     */
    error?: {
        /**
         * Error code
         */
        code: string;
        /**
         * Error message
         */
        message: string;
    };
};

/**
 * Options for batch operations
 */
export type BatchOptions = {
    /**
     * If true, all items succeed or all fail (transactional)
     */
    atomic?: boolean;
    /**
     * If true, return created/updated records in response
     */
    returnRecords?: boolean;
    /**
     * If true, skip items that already exist (duplicates)
     */
    skipDuplicates?: boolean;
    /**
     * If true, validate without actually creating/updating
     */
    validateOnly?: boolean;
};

/**
 * Summary of batch operation results
 */
export type BatchSummary = {
    /**
     * Total number of items in the request
     */
    total: number;
    /**
     * Number of successfully processed items
     */
    successful: number;
    /**
     * Number of failed items
     */
    failed: number;
    /**
     * Number of skipped items (e.g., duplicates)
     */
    skipped: number;
};

/**
 * Request to confirm an upload completed successfully
 */
export type ConfirmUploadRequest = {
    /**
     * Optional: ETag from S3 response for verification
     */
    etag?: string;
};

/**
 * Request body for creating a new comment
 */
export type CreateExampleCommentRequest = {
    /**
     * Comment content
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
};

/**
 * Request body for creating a new post
 */
export type CreateExamplePostRequest = {
    /**
     * Post title
     */
    title: string;
    /**
     * Post content (supports markdown)
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Post status (default: draft)
     */
    status?: ExamplePostStatus;
};

/**
 * Request to create a custom role
 */
export type CreateRoleRequest = {
    /**
     * Role name
     */
    name: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions to grant
     */
    permissions: Array<PermissionInput>;
};

/**
 * Request to create a webhook
 */
export type CreateWebhookRequest = {
    /**
     * URL to receive webhook payloads (must be HTTPS)
     */
    url: string;
    /**
     * Human-readable name
     */
    name?: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Event types to subscribe to
     */
    events: Array<string>;
    /**
     * Whether the webhook is active (default: true)
     */
    isActive?: boolean;
};

/**
 * Cursor-based pagination for large datasets or real-time data
 */
export type CursorPagination = {
    /**
     * Maximum items returned per page
     */
    limit: number;
    /**
     * Whether there is a next page
     */
    hasNext: boolean;
    /**
     * Cursor for fetching the next page (null if no more pages)
     */
    nextCursor: string | null;
    /**
     * Cursor for fetching the previous page (null if on first page)
     */
    previousCursor: string | null;
};

/**
 * Standard error object
 */
export type Error = {
    /**
     * Machine-readable error code
     */
    code: string;
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Array of detailed error information (e.g., validation errors)
     */
    details?: Array<ErrorDetail>;
    /**
     * Request ID for tracking and debugging
     */
    requestId: string;
    /**
     * URL to documentation about this error (optional)
     */
    documentationUrl?: string;
};

/**
 * Detailed error information for a specific field or validation
 */
export type ErrorDetail = {
    /**
     * The field that caused the error (for validation errors)
     */
    field: string;
    /**
     * Specific error code for this detail
     */
    code: string;
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Additional metadata about the error
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Standard error response envelope
 */
export type ErrorResponse = {
    /**
     * The error object
     */
    error: Error;
};

/**
 * ExampleComment resource model (nested under ExamplePost)
 *
 * Demonstrates:
 * - Nested sub-resource pattern (belongs to a post)
 * - Multi-tenant scoping (orgId)
 * - Soft delete with restore capability
 */
export type ExampleComment = {
    /**
     * Unique comment identifier (format: cmt_{randomString})
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    orgId: string;
    /**
     * Parent post ID
     */
    postId: string;
    /**
     * Comment content
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Whether the comment is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the comment was soft deleted
     */
    deletedAt?: string;
    /**
     * User ID who deleted this comment
     */
    deletedBy?: string;
    /**
     * Timestamp when the comment was created
     */
    createdAt: string;
    /**
     * Timestamp when the comment was last updated
     */
    updatedAt: string;
};

/**
 * Comment collection response
 */
export type ExampleCommentListResponse = {
    data: Array<ExampleComment>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single comment response
 */
export type ExampleCommentResponse = {
    data: ExampleComment;
    meta: ResponseMeta;
};

/**
 * ExamplePost resource model
 *
 * Demonstrates a typical content resource with:
 * - Multi-tenant scoping (orgId)
 * - Status workflow (draft → published → archived)
 * - Soft delete with restore capability
 */
export type ExamplePost = {
    /**
     * Unique post identifier (format: post_{randomString})
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    orgId: string;
    /**
     * Post title
     */
    title: string;
    /**
     * Post content (supports markdown)
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Post status
     */
    status: ExamplePostStatus;
    /**
     * Timestamp when the post was published (null if not published)
     */
    publishedAt?: string;
    /**
     * Whether the post is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the post was soft deleted (null if not deleted)
     */
    deletedAt?: string;
    /**
     * User ID who deleted this post (null if not deleted)
     */
    deletedBy?: string;
    /**
     * Timestamp when the post was created
     */
    createdAt: string;
    /**
     * Timestamp when the post was last updated
     */
    updatedAt: string;
};

/**
 * Post collection response (cursor-based)
 *
 * Used for streaming/real-time scenarios or large datasets
 */
export type ExamplePostCursorListResponse = {
    data: Array<ExamplePost>;
    pagination: CursorPagination;
    meta: ResponseMeta;
};

/**
 * Post collection response (page-based)
 */
export type ExamplePostListResponse = {
    data: Array<ExamplePost>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single post response
 */
export type ExamplePostResponse = {
    data: ExamplePost;
    meta: ResponseMeta;
};

/**
 * Post status enum
 */
export type ExamplePostStatus = 'draft' | 'published' | 'archived';

/**
 * File resource model
 *
 * Represents an uploaded file with metadata, security status, and access info.
 */
export type File = {
    /**
     * Unique file identifier (format: file_abc123)
     */
    id: string;
    /**
     * Original filename (sanitized)
     */
    filename: string;
    /**
     * File size in bytes
     */
    size: number;
    /**
     * MIME type (verified via magic bytes, not client-provided)
     */
    mimeType: string;
    /**
     * Storage path (internal, not exposed to clients in production)
     */
    storagePath: string;
    /**
     * Signed URL for file access (time-limited)
     */
    url?: string;
    /**
     * File metadata (user-provided)
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     * User ID who uploaded the file
     */
    uploadedBy: string;
    /**
     * Timestamp when the file was uploaded
     */
    uploadedAt: string;
    /**
     * Virus scan status
     */
    virusScanStatus: VirusScanStatus;
    /**
     * Timestamp when virus scan completed
     */
    virusScanCompletedAt?: string;
    /**
     * Access level
     */
    access: FileAccess;
    /**
     * Whether the file is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the file was deleted
     */
    deletedAt?: string;
    /**
     * User ID who deleted this file
     */
    deletedBy?: string;
};

/**
 * File access level
 */
export type FileAccess = 'private' | 'public';

/**
 * File deletion response
 */
export type FileDeleteResponse = {
    data: {
        /**
         * ID of the deleted file
         */
        id: string;
        /**
         * When the file was deleted
         */
        deletedAt: string;
        /**
         * Who deleted the file
         */
        deletedBy: string;
    };
    meta: ResponseMeta;
};

/**
 * File list response with pagination
 */
export type FileListResponse = {
    data: Array<File>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single file response
 */
export type FileResponse = {
    data: File;
    meta: ResponseMeta;
};

/**
 * Request to initiate a presigned URL upload
 */
export type InitiateUploadRequest = {
    /**
     * Original filename
     */
    filename: string;
    /**
     * MIME type of the file
     */
    contentType: string;
    /**
     * File size in bytes
     */
    size: number;
    /**
     * Optional metadata
     */
    metadata?: {
        [key: string]: string;
    };
};

/**
 * Response with presigned URL for direct upload to storage
 */
export type InitiateUploadResponse = {
    data: {
        /**
         * Upload ID for confirmation step
         */
        uploadId: string;
        /**
         * Presigned URL to upload to
         */
        presignedUrl: string;
        /**
         * HTTP method to use
         */
        method: 'PUT';
        /**
         * Required headers for the upload
         */
        headers: {
            [key: string]: string;
        };
        /**
         * When the presigned URL expires
         */
        expiresAt: string;
        /**
         * Maximum allowed file size
         */
        maxSize: number;
    };
    meta: ResponseMeta;
};

/**
 * Async job resource
 *
 * Represents a long-running operation that can be polled for status.
 */
export type Job = {
    /**
     * Unique job identifier (format: job_abc123)
     */
    jobId: string;
    /**
     * Tenant this job belongs to
     */
    tenantId: string;
    /**
     * Type of operation (e.g., "bulkImport", "reportGeneration")
     */
    type: string;
    /**
     * Current job status
     */
    status: JobStatus;
    /**
     * Progress percentage (0-100, if available)
     */
    progress?: number;
    /**
     * Human-readable status message
     */
    message?: string;
    /**
     * Result data (when completed)
     */
    result?: {
        [key: string]: unknown;
    };
    /**
     * Error details (when failed)
     */
    error?: {
        /**
         * Error code
         */
        code: string;
        /**
         * Error message
         */
        message: string;
        /**
         * Additional error details
         */
        details?: {
            [key: string]: unknown;
        };
    };
    /**
     * Who initiated the job
     */
    createdBy: string;
    /**
     * When the job was created
     */
    createdAt: string;
    /**
     * When the job started processing
     */
    startedAt?: string;
    /**
     * When the job completed (success or failure)
     */
    completedAt?: string;
    /**
     * Estimated completion time (if available)
     */
    estimatedCompletion?: string;
};

/**
 * Job list response
 */
export type JobListResponse = {
    data: Array<Job>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Job status response
 */
export type JobResponse = {
    data: Job;
    meta: ResponseMeta;
};

/**
 * Job status
 */
export type JobStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';

/**
 * Mark all as read response
 */
export type MarkAllReadResponse = {
    data: {
        /**
         * Number of notifications marked as read
         */
        markedCount: number;
    };
    meta: ResponseMeta;
};

/**
 * Version lifecycle status
 */
export type MigrationStatus = 'current' | 'deprecated' | 'sunset';

/**
 * Migration status for an API version
 */
export type MigrationStatusResponse = {
    /**
     * API version (e.g., "v1")
     */
    version: string;
    /**
     * Version lifecycle status
     */
    status: MigrationStatus;
    /**
     * ISO 8601 date when this version will be removed (if deprecated)
     */
    sunsetDate?: string;
    /**
     * Days remaining until sunset (if deprecated)
     */
    daysUntilSunset?: number;
    /**
     * Version to migrate to (if deprecated)
     */
    replacementVersion?: string;
    /**
     * URL to the migration guide
     */
    migrationGuideUrl?: string;
    /**
     * List of breaking changes in the replacement version
     */
    breakingChanges?: Array<string>;
    /**
     * Steps to complete the migration
     */
    migrationChecklist?: Array<string>;
};

/**
 * Notification resource model
 */
export type Notification = {
    /**
     * Unique notification identifier
     */
    id: string;
    /**
     * User ID who should receive this notification
     */
    userId?: string;
    /**
     * Notification channel
     */
    channel: NotificationChannel;
    /**
     * Notification category
     */
    category: NotificationCategory;
    /**
     * Notification priority
     */
    priority: NotificationPriority;
    /**
     * Current notification status
     */
    status: NotificationStatus;
    /**
     * Email address this was sent to
     */
    recipientEmail?: string;
    /**
     * Phone number this was sent to
     */
    recipientPhone?: string;
    /**
     * Telegram ID this was sent to
     */
    recipientTelegramId?: string;
    /**
     * Template ID used (if any)
     */
    templateId?: string;
    /**
     * Subject line (for email)
     */
    subject?: string;
    /**
     * Plain text body
     */
    body?: string;
    /**
     * HTML body (for email)
     */
    bodyHtml?: string;
    /**
     * Template data used for rendering
     */
    templateData?: {
        [key: string]: unknown;
    };
    /**
     * Campaign ID for bulk sends
     */
    campaignId?: string;
    /**
     * Provider used to send (e.g., "nodemailer", "twilio")
     */
    provider?: string;
    /**
     * Provider's message ID
     */
    providerMessageId?: string;
    /**
     * Timestamp when notification was sent
     */
    sentAt?: string;
    /**
     * Timestamp when notification was delivered
     */
    deliveredAt?: string;
    /**
     * Timestamp when notification failed
     */
    failedAt?: string;
    /**
     * Timestamp when notification was read by user
     */
    readAt?: string;
    /**
     * Timestamp when notification was soft deleted
     */
    deletedAt?: string;
    /**
     * Number of retry attempts
     */
    retryCount: number;
    /**
     * Maximum retry attempts allowed
     */
    maxRetries: number;
    /**
     * Next retry timestamp
     */
    nextRetryAt?: string;
    /**
     * Status message (error details if failed)
     */
    statusMessage?: string;
    /**
     * Metadata for custom data
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Timestamp when notification was created
     */
    createdAt: string;
    /**
     * Timestamp when notification was last updated
     */
    updatedAt: string;
};

/**
 * Notification category enum
 */
export type NotificationCategory = 'transactional' | 'marketing' | 'security' | 'system';

/**
 * Notification channel enum
 */
export type NotificationChannel = 'email' | 'sms' | 'whatsapp' | 'telegram' | 'push';

/**
 * Notification collection response
 */
export type NotificationListResponse = {
    data: Array<Notification>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Notification preferences model
 */
export type NotificationPreferences = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Email notifications enabled
     */
    emailEnabled: boolean;
    /**
     * SMS notifications enabled
     */
    smsEnabled: boolean;
    /**
     * WhatsApp notifications enabled
     */
    whatsappEnabled: boolean;
    /**
     * Telegram notifications enabled
     */
    telegramEnabled: boolean;
    /**
     * Push notifications enabled
     */
    pushEnabled: boolean;
    /**
     * Marketing notifications enabled
     */
    marketingEnabled: boolean;
    /**
     * Transactional notifications enabled
     */
    transactionalEnabled: boolean;
    /**
     * Security notifications enabled
     */
    securityEnabled: boolean;
    /**
     * System notifications enabled
     */
    systemEnabled: boolean;
    /**
     * Preferred email address
     */
    preferredEmail?: string;
    /**
     * Preferred phone number
     */
    preferredPhone?: string;
    /**
     * Preferred Telegram ID
     */
    preferredTelegramId?: string;
    /**
     * Quiet hours enabled
     */
    quietHoursEnabled: boolean;
    /**
     * Quiet hours start time (HH:mm format)
     */
    quietHoursStart?: string;
    /**
     * Quiet hours end time (HH:mm format)
     */
    quietHoursEnd?: string;
    /**
     * Quiet hours timezone (IANA format)
     */
    quietHoursTimezone?: string;
    /**
     * Timestamp when created
     */
    createdAt: string;
    /**
     * Timestamp when last updated
     */
    updatedAt: string;
};

/**
 * Notification preferences response
 */
export type NotificationPreferencesResponse = {
    data: NotificationPreferences;
    meta: ResponseMeta;
};

/**
 * Notification priority enum
 */
export type NotificationPriority = 'urgent' | 'high' | 'normal' | 'low';

/**
 * Notification recipient information
 */
export type NotificationRecipient = {
    /**
     * Email address (required for email channel)
     */
    email?: string;
    /**
     * Phone number in E.164 format (required for SMS/WhatsApp)
     */
    phone?: string;
    /**
     * Telegram chat ID (required for Telegram channel)
     */
    telegramId?: string;
};

/**
 * Single notification response
 */
export type NotificationResponse = {
    data: Notification;
    meta: ResponseMeta;
};

/**
 * Notification status enum
 */
export type NotificationStatus = 'pending' | 'queued' | 'processing' | 'sent' | 'delivered' | 'failed' | 'bounced';

/**
 * Page-based pagination metadata for collection responses
 */
export type Pagination = {
    /**
     * Current page number (1-indexed)
     */
    page: number;
    /**
     * Number of items per page
     */
    pageSize: number;
    /**
     * Total number of pages
     */
    totalPages: number;
    /**
     * Total number of items across all pages
     */
    totalCount: number;
    /**
     * Whether there is a next page
     */
    hasNext: boolean;
    /**
     * Whether there is a previous page
     */
    hasPrevious: boolean;
    /**
     * Navigation links for pagination
     */
    links?: PaginationLinks;
    /**
     * Original requested page size (included if pageSize was capped)
     */
    requestedPageSize?: number;
};

/**
 * Pagination links for navigating through paginated results
 */
export type PaginationLinks = {
    /**
     * URL for the first page
     */
    first: string | null;
    /**
     * URL for the previous page (null if on first page)
     */
    previous: string | null;
    /**
     * URL for the next page (null if on last page)
     */
    next: string | null;
    /**
     * URL for the last page
     */
    last: string | null;
};

/**
 * Permission definition
 *
 * Permissions define what actions can be performed on resources.
 * They support allow/deny effects and optional conditions.
 */
export type Permission = {
    /**
     * Resource identifier (e.g., "users", "invoices", "settings")
     */
    resource: string;
    /**
     * Action to perform on the resource
     */
    action: PermissionAction | string;
    /**
     * Whether to allow or deny this action
     */
    effect: PermissionEffect;
    /**
     * Optional condition for when this permission applies
     */
    condition?: PermissionCondition;
};

/**
 * Permission actions
 */
export type PermissionAction = 'read' | 'create' | 'update' | 'delete' | 'manage' | '*';

/**
 * Permission condition - when the permission applies
 *
 * Conditions enable dynamic, context-aware access control.
 */
export type PermissionCondition = '' | 'owner' | 'shared';

/**
 * Permission effect - whether to allow or deny access
 *
 * When a user has multiple roles, permissions are combined:
 * - If ANY role denies an action, it is denied (deny wins)
 * - If no role denies and ANY role allows, it is allowed
 * - If no rules match, access is denied (default deny)
 */
export type PermissionEffect = 'allow' | 'deny';

/**
 * Permission input for creating/updating roles
 */
export type PermissionInput = {
    /**
     * Resource identifier
     */
    resource: string;
    /**
     * Action to perform
     */
    action: string;
    /**
     * Effect (defaults to "allow" if not specified)
     */
    effect?: PermissionEffect;
    /**
     * Optional condition
     */
    condition?: PermissionCondition;
};

/**
 * Response metadata included in all API responses
 */
export type ResponseMeta = {
    /**
     * Unique request identifier for tracking and debugging
     */
    requestId: string;
    /**
     * Timestamp when the response was generated
     */
    timestamp: string;
    /**
     * API version used for this request
     */
    apiVersion?: string;
    /**
     * Tenant/organization ID for multi-tenant requests
     */
    tenantId?: string;
    /**
     * Tenant/organization name for multi-tenant requests
     */
    tenantName?: string;
    /**
     * Processing time in milliseconds
     */
    durationMs?: number;
};

/**
 * Role resource model
 *
 * Roles can be:
 * - **Global roles**: App-scoped (tenantId is null), apply across all tenants
 * - **Tenant roles**: Scoped to a specific organization
 *
 * Users can have multiple roles, and permissions are combined with
 * deny-override semantics.
 */
export type Role = {
    /**
     * Unique role identifier (format: role_abc123)
     */
    id: string;
    /**
     * Application this role belongs to
     */
    applicationId: string;
    /**
     * Tenant this role belongs to (null for global roles)
     */
    tenantId?: string;
    /**
     * Role name
     */
    name: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions granted by this role
     */
    permissions: Array<Permission>;
    /**
     * Whether this is a system-defined role (cannot be deleted or renamed)
     */
    isSystemRole: boolean;
    /**
     * Whether this is a global role (tenantId is null)
     */
    isGlobalRole: boolean;
    /**
     * Timestamp when the role was created
     */
    createdAt: string;
    /**
     * Timestamp when the role was last updated
     */
    updatedAt: string;
    /**
     * User who created this role
     */
    createdBy?: string;
};

/**
 * Role list response
 */
export type RoleListResponse = {
    data: Array<Role>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single role response
 */
export type RoleResponse = {
    data: Role;
    meta: ResponseMeta;
};

/**
 * Request body for sending a notification
 */
export type SendNotificationRequest = {
    /**
     * Notification channel
     */
    channel: NotificationChannel;
    /**
     * Notification category
     */
    category: NotificationCategory;
    /**
     * Notification priority (default: normal)
     */
    priority?: NotificationPriority;
    /**
     * Recipient information
     */
    recipient: NotificationRecipient;
    /**
     * Template ID to use for rendering
     */
    templateId?: string;
    /**
     * Data for template rendering
     */
    templateData?: {
        [key: string]: unknown;
    };
    /**
     * Subject line (for email, required if not using template)
     */
    subject?: string;
    /**
     * Plain text body (required if not using template)
     */
    body?: string;
    /**
     * HTML body (for email)
     */
    bodyHtml?: string;
    /**
     * Custom metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Send notification success response
 */
export type SendNotificationResponse = {
    data: {
        /**
         * Message ID assigned to the notification
         */
        messageId: string;
        /**
         * Provider used to send
         */
        provider: string;
    };
    meta: ResponseMeta;
};

/**
 * Response for soft delete operations
 *
 * Includes resource ID, deletion metadata, and restore information
 */
export type SoftDeleteResponse = {
    data: {
        /**
         * ID of the deleted resource
         */
        id: string;
        /**
         * Timestamp when the resource was soft deleted
         */
        deletedAt: string;
        /**
         * User ID who performed the deletion
         */
        deletedBy: string;
        /**
         * Reason for deletion (optional, from request)
         */
        deletionReason?: string;
        /**
         * Whether the resource can be restored
         */
        canRestore: boolean;
        /**
         * Deadline for restoration (after which hard delete may occur)
         */
        restoreUntil?: string;
    };
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Request to switch active context (application and/or tenant)
 */
export type SwitchContextRequest = {
    /**
     * Target application ID (optional, defaults to current)
     */
    applicationId?: string;
    /**
     * Target tenant ID (optional, null to clear tenant context)
     */
    tenantId?: string;
};

/**
 * Context switch response
 */
export type SwitchContextResponse = {
    data: {
        /**
         * New active application ID
         */
        applicationId: string;
        /**
         * New active tenant ID (null if no tenant)
         */
        tenantId?: string;
        /**
         * Tenant name (if tenant selected)
         */
        tenantName?: string;
        /**
         * Roles in the new context
         */
        roles: Array<string>;
        /**
         * Effective permissions in the new context
         */
        permissions: Array<Permission>;
    };
    meta: ResponseMeta;
};

/**
 * Unread count response
 */
export type UnreadCountResponse = {
    data: {
        /**
         * Number of unread notifications
         */
        unreadCount: number;
    };
    meta: ResponseMeta;
};

/**
 * Request body for updating a comment
 */
export type UpdateExampleCommentRequest = {
    /**
     * Comment content (optional)
     */
    content?: string;
};

/**
 * Request body for updating a post
 */
export type UpdateExamplePostRequest = {
    /**
     * Post title (optional)
     */
    title?: string;
    /**
     * Post content (optional)
     */
    content?: string;
    /**
     * Post status (optional)
     */
    status?: ExamplePostStatus;
};

/**
 * Request to update file properties
 */
export type UpdateFileRequest = {
    /**
     * New access level
     */
    access?: FileAccess;
};

/**
 * Request body for updating notification preferences
 */
export type UpdatePreferencesRequest = {
    /**
     * Email notifications enabled
     */
    emailEnabled?: boolean;
    /**
     * SMS notifications enabled
     */
    smsEnabled?: boolean;
    /**
     * WhatsApp notifications enabled
     */
    whatsappEnabled?: boolean;
    /**
     * Telegram notifications enabled
     */
    telegramEnabled?: boolean;
    /**
     * Push notifications enabled
     */
    pushEnabled?: boolean;
    /**
     * Marketing notifications enabled
     */
    marketingEnabled?: boolean;
    /**
     * Transactional notifications enabled
     */
    transactionalEnabled?: boolean;
    /**
     * Security notifications enabled
     */
    securityEnabled?: boolean;
    /**
     * System notifications enabled
     */
    systemEnabled?: boolean;
    /**
     * Preferred email address
     */
    preferredEmail?: string;
    /**
     * Preferred phone number
     */
    preferredPhone?: string;
    /**
     * Preferred Telegram ID
     */
    preferredTelegramId?: string;
    /**
     * Quiet hours enabled
     */
    quietHoursEnabled?: boolean;
    /**
     * Quiet hours start time (HH:mm format)
     */
    quietHoursStart?: string;
    /**
     * Quiet hours end time (HH:mm format)
     */
    quietHoursEnd?: string;
    /**
     * Quiet hours timezone (IANA format)
     */
    quietHoursTimezone?: string;
};

/**
 * Request to update a role
 */
export type UpdateRoleRequest = {
    /**
     * Role name
     */
    name?: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions to grant (replaces existing permissions)
     */
    permissions?: Array<PermissionInput>;
};

/**
 * Request to update a webhook
 */
export type UpdateWebhookRequest = {
    /**
     * URL to receive webhook payloads
     */
    url?: string;
    /**
     * Human-readable name
     */
    name?: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Event types to subscribe to
     */
    events?: Array<string>;
    /**
     * Whether the webhook is active
     */
    isActive?: boolean;
};

/**
 * User's context across applications and tenants
 */
export type UserContext = {
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Application name
     */
    applicationName: string;
    /**
     * Tenant ID
     */
    tenantId: string;
    /**
     * Tenant name
     */
    tenantName: string;
    /**
     * Role names in this context
     */
    roles: Array<string>;
};

/**
 * User available contexts response (all apps/tenants user belongs to)
 */
export type UserContextListResponse = {
    data: Array<UserContext>;
    meta: ResponseMeta;
};

/**
 * User's effective permissions
 *
 * Represents the combined permissions from all roles assigned to a user
 * within a specific application and tenant context.
 */
export type UserEffectivePermissions = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Tenant ID (context for permission calculation)
     */
    tenantId?: string;
    /**
     * Global roles (app-scoped, no tenant)
     */
    globalRoles: Array<{
        /**
         * Role ID
         */
        id: string;
        /**
         * Role name
         */
        name: string;
        /**
         * Permissions from this role
         */
        permissions: Array<Permission>;
    }>;
    /**
     * Tenant-specific roles
     */
    tenantRoles: Array<{
        /**
         * Role ID
         */
        id: string;
        /**
         * Role name
         */
        name: string;
        /**
         * Permissions from this role
         */
        permissions: Array<Permission>;
    }>;
    /**
     * Combined effective permissions (after deny-override resolution)
     */
    effectivePermissions: Array<Permission>;
    /**
     * Simple list of allowed actions (for quick checks)
     */
    allowedActions: Array<string>;
};

/**
 * User effective permissions response
 */
export type UserEffectivePermissionsResponse = {
    data: UserEffectivePermissions;
    meta: ResponseMeta;
};

/**
 * User's role assignment
 *
 * Represents a single role assigned to a user within a specific
 * application and optional tenant context.
 */
export type UserRoleAssignment = {
    /**
     * Assignment ID
     */
    id: string;
    /**
     * User ID
     */
    userId: string;
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Tenant ID (null for global role assignments)
     */
    tenantId?: string;
    /**
     * Role ID
     */
    roleId: string;
    /**
     * Role name (denormalized for convenience)
     */
    roleName: string;
    /**
     * Whether this is a global role assignment
     */
    isGlobalRole: boolean;
    /**
     * When the role was assigned
     */
    assignedAt: string;
    /**
     * Who assigned the role
     */
    assignedBy?: string;
};

/**
 * User role assignments list response
 */
export type UserRoleAssignmentListResponse = {
    data: Array<UserRoleAssignment>;
    meta: ResponseMeta;
};

/**
 * User role assignment response
 */
export type UserRoleAssignmentResponse = {
    data: UserRoleAssignment;
    meta: ResponseMeta;
};

/**
 * Virus scan status for uploaded files
 */
export type VirusScanStatus = 'pending' | 'scanning' | 'clean' | 'infected' | 'failed';

/**
 * Webhook configuration
 *
 * Defines an endpoint to receive event notifications.
 */
export type Webhook = {
    /**
     * Unique webhook identifier (format: wh_abc123)
     */
    id: string;
    /**
     * Tenant this webhook belongs to
     */
    tenantId: string;
    /**
     * URL to receive webhook payloads
     */
    url: string;
    /**
     * Human-readable name for this webhook
     */
    name?: string;
    /**
     * Description of what this webhook is used for
     */
    description?: string;
    /**
     * Event types to subscribe to (e.g., "user.created", "invoice.paid")
     */
    events: Array<string>;
    /**
     * Secret for HMAC-SHA256 signature verification (masked after creation)
     */
    secret: string;
    /**
     * Whether the webhook is currently active
     */
    isActive: boolean;
    /**
     * Number of consecutive failures (resets on success)
     */
    consecutiveFailures: number;
    /**
     * When the webhook was last triggered
     */
    lastTriggeredAt?: string;
    /**
     * When the webhook last succeeded
     */
    lastSuccessAt?: string;
    /**
     * When the webhook last failed
     */
    lastFailureAt?: string;
    /**
     * User who created this webhook
     */
    createdBy: string;
    /**
     * When the webhook was created
     */
    createdAt: string;
    /**
     * When the webhook was last updated
     */
    updatedAt: string;
};

/**
 * Webhook creation response (includes secret once)
 */
export type WebhookCreatedResponse = {
    data: WebhookWithSecret;
    meta: ResponseMeta;
};

/**
 * Webhook delivery attempt record
 *
 * Tracks each attempt to deliver a webhook payload.
 */
export type WebhookDelivery = {
    /**
     * Unique delivery identifier (format: whd_abc123)
     */
    id: string;
    /**
     * Webhook ID this delivery belongs to
     */
    webhookId: string;
    /**
     * Event ID that triggered this delivery
     */
    eventId: string;
    /**
     * Event type
     */
    eventType: string;
    /**
     * Delivery status
     */
    status: WebhookDeliveryStatus;
    /**
     * Number of delivery attempts made
     */
    attemptCount: number;
    /**
     * HTTP status code from last attempt (null if not yet attempted)
     */
    httpStatus?: number;
    /**
     * Response body from last attempt (truncated)
     */
    responseBody?: string;
    /**
     * Error message if failed
     */
    errorMessage?: string;
    /**
     * Duration of last request in milliseconds
     */
    durationMs?: number;
    /**
     * When the next retry will be attempted
     */
    nextRetryAt?: string;
    /**
     * When this delivery was created
     */
    createdAt: string;
    /**
     * When the delivery was last attempted
     */
    lastAttemptAt?: string;
    /**
     * When the delivery completed (success or exhausted)
     */
    completedAt?: string;
};

/**
 * Webhook delivery list response
 */
export type WebhookDeliveryListResponse = {
    data: Array<WebhookDelivery>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Webhook delivery response
 */
export type WebhookDeliveryResponse = {
    data: WebhookDelivery;
    meta: ResponseMeta;
};

/**
 * Webhook delivery status
 */
export type WebhookDeliveryStatus = 'pending' | 'delivered' | 'failed' | 'exhausted';

/**
 * Available webhook event types
 */
export type WebhookEventTypesResponse = {
    data: {
        /**
         * Available event types grouped by resource
         */
        eventTypes: {
            [key: string]: Array<string>;
        };
    };
    meta: ResponseMeta;
};

/**
 * Webhook list response
 */
export type WebhookListResponse = {
    data: Array<Webhook>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Webhook response (secret masked)
 */
export type WebhookResponse = {
    data: Webhook;
    meta: ResponseMeta;
};

/**
 * Webhook with unmasked secret (only returned on creation)
 */
export type WebhookWithSecret = {
    /**
     * Unique webhook identifier
     */
    id: string;
    /**
     * Tenant this webhook belongs to
     */
    tenantId: string;
    /**
     * URL to receive webhook payloads
     */
    url: string;
    /**
     * Webhook name
     */
    name?: string;
    /**
     * Event types subscribed to
     */
    events: Array<string>;
    /**
     * The webhook secret - ONLY RETURNED ONCE
     * Use this for signature verification
     */
    secret: string;
    /**
     * Whether the webhook is active
     */
    isActive: boolean;
    /**
     * When the webhook was created
     */
    createdAt: string;
};

export type HealthCheckData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type HealthCheckResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Service status
         */
        status: 'ok' | 'degraded' | 'down';
        /**
         * Current timestamp
         */
        timestamp: string;
        /**
         * API version
         */
        version?: string;
        /**
         * Additional service information
         */
        services?: {
            database?: 'ok' | 'degraded' | 'down';
            cache?: 'ok' | 'degraded' | 'down';
            storage?: 'ok' | 'degraded' | 'down';
        };
    };
};

export type HealthCheckResponse = HealthCheckResponses[keyof HealthCheckResponses];

export type MigrationGetStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/migration/status';
};

export type MigrationGetStatusResponses = {
    /**
     * The request has succeeded.
     */
    200: MigrationStatusResponse;
};

export type MigrationGetStatusResponse = MigrationGetStatusResponses[keyof MigrationGetStatusResponses];

export type NotificationsListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number (1-indexed, default: 1)
         */
        page?: number;
        /**
         * Number of items per page (max: 100, default: 20)
         */
        pageSize?: number;
        /**
         * Filter by notification channel
         */
        channel?: NotificationChannel;
        /**
         * Filter by notification category
         */
        category?: NotificationCategory;
        /**
         * Filter by notification status
         */
        status?: NotificationStatus;
        /**
         * Filter by read status ("read" or "unread")
         */
        readStatus?: 'read' | 'unread';
    };
    url: '/v1/notifications';
};

export type NotificationsListResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationListResponse | ErrorResponse;
};

export type NotificationsListResponse = NotificationsListResponses[keyof NotificationsListResponses];

export type NotificationsMarkAllReadData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/notifications/mark-all-read';
};

export type NotificationsMarkAllReadResponses = {
    /**
     * The request has succeeded.
     */
    200: MarkAllReadResponse | ErrorResponse;
};

export type NotificationsMarkAllReadResponse = NotificationsMarkAllReadResponses[keyof NotificationsMarkAllReadResponses];

export type NotificationsSendData = {
    body: SendNotificationRequest;
    path?: never;
    query?: never;
    url: '/v1/notifications/send';
};

export type NotificationsSendResponses = {
    /**
     * The request has succeeded.
     */
    200: SendNotificationResponse | ErrorResponse;
};

export type NotificationsSendResponse = NotificationsSendResponses[keyof NotificationsSendResponses];

export type NotificationsGetUnreadCountData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/notifications/unread/count';
};

export type NotificationsGetUnreadCountResponses = {
    /**
     * The request has succeeded.
     */
    200: UnreadCountResponse | ErrorResponse;
};

export type NotificationsGetUnreadCountResponse = NotificationsGetUnreadCountResponses[keyof NotificationsGetUnreadCountResponses];

export type NotificationsDeleteData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}';
};

export type NotificationsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsDeleteResponse = NotificationsDeleteResponses[keyof NotificationsDeleteResponses];

export type NotificationsGetData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}';
};

export type NotificationsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationResponse | ErrorResponse;
};

export type NotificationsGetResponse = NotificationsGetResponses[keyof NotificationsGetResponses];

export type NotificationsMarkReadData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/read';
};

export type NotificationsMarkReadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsMarkReadResponse = NotificationsMarkReadResponses[keyof NotificationsMarkReadResponses];

export type NotificationsRestoreData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/restore';
};

export type NotificationsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsRestoreResponse = NotificationsRestoreResponses[keyof NotificationsRestoreResponses];

export type NotificationsMarkUnreadData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/unread';
};

export type NotificationsMarkUnreadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsMarkUnreadResponse = NotificationsMarkUnreadResponses[keyof NotificationsMarkUnreadResponses];

export type AuditLogsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Filter by event type (e.g., "user.created", "user.*")
         */
        eventType?: string;
        /**
         * Filter by actor ID
         */
        actorId?: string;
        /**
         * Filter by actor type
         */
        actorType?: AuditActorType;
        /**
         * Filter by resource type (e.g., "user", "invoice")
         */
        resourceType?: string;
        /**
         * Filter by resource ID
         */
        resourceId?: string;
        /**
         * Filter events after this timestamp
         */
        timestampAfter?: string;
        /**
         * Filter events before this timestamp
         */
        timestampBefore?: string;
        /**
         * Filter by IP address
         */
        ipAddress?: string;
        /**
         * Filter by request ID
         */
        requestId?: string;
    };
    url: '/v1/orgs/{orgId}/audit-logs';
};

export type AuditLogsListResponses = {
    /**
     * The request has succeeded.
     */
    200: AuditLogListResponse | ErrorResponse;
};

export type AuditLogsListResponse = AuditLogsListResponses[keyof AuditLogsListResponses];

export type AuditLogsExportData = {
    /**
     * Export configuration
     */
    body: {
        /**
         * Export format
         */
        format: 'csv' | 'json';
        /**
         * Filter events after this timestamp
         */
        timestampAfter?: string;
        /**
         * Filter events before this timestamp
         */
        timestampBefore?: string;
        /**
         * Event types to include (empty = all)
         */
        eventTypes?: Array<string>;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/audit-logs/export';
};

export type AuditLogsExportResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        data: {
            /**
             * Download URL (signed, expires in 1 hour)
             */
            downloadUrl: string;
            /**
             * Number of events exported
             */
            eventCount: number;
            /**
             * When the URL expires
             */
            expiresAt: string;
        };
        meta: ResponseMeta;
    } | ErrorResponse;
    /**
     * The request has been accepted for processing, but processing has not yet completed.
     */
    202: AsyncJobResponse;
};

export type AuditLogsExportResponse = AuditLogsExportResponses[keyof AuditLogsExportResponses];

export type AuditLogsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Event ID
         */
        eventId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/audit-logs/{eventId}';
};

export type AuditLogsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: AuditLogResponse | ErrorResponse;
};

export type AuditLogsGetResponse = AuditLogsGetResponses[keyof AuditLogsGetResponses];

export type ExamplePostsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-createdAt,title" for desc createdAt, then asc title)
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return (e.g., "id,title,status")
         */
        fields?: string;
        /**
         * Comma-separated list of relations to include (e.g., "comments")
         */
        include?: string;
        /**
         * Full-text search query
         */
        search?: string;
        /**
         * Filter by post status (exact match)
         */
        status?: ExamplePostStatus;
        /**
         * Filter by status NOT equal to value
         */
        statusNe?: string;
        /**
         * Filter by status IN list (comma-separated values)
         */
        statusIn?: string;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Filter by title contains
         */
        titleContains?: string;
        /**
         * Filter by content contains
         */
        contentContains?: string;
        /**
         * Filter posts created after this timestamp
         */
        createdAfter?: string;
        /**
         * Filter posts created before this timestamp
         */
        createdBefore?: string;
        /**
         * Filter posts published after this timestamp
         */
        publishedAfter?: string;
        /**
         * Filter posts published before this timestamp
         */
        publishedBefore?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts';
};

export type ExamplePostsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostListResponse | ErrorResponse;
};

export type ExamplePostsListResponse = ExamplePostsListResponses[keyof ExamplePostsListResponses];

export type ExamplePostsCreateData = {
    /**
     * Post creation data
     */
    body: CreateExamplePostRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts';
};

export type ExamplePostsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ExamplePostResponse;
};

export type ExamplePostsCreateResponse = ExamplePostsCreateResponses[keyof ExamplePostsCreateResponses];

export type ExamplePostsBatchUpdateData = {
    /**
     * Batch update request
     */
    body: {
        items?: Array<{
            id: string;
            updates: UpdateExamplePostRequest;
        }>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch';
};

export type ExamplePostsBatchUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type ExamplePostsBatchUpdateResponse = ExamplePostsBatchUpdateResponses[keyof ExamplePostsBatchUpdateResponses];

export type ExamplePostsBatchCreateData = {
    /**
     * Batch create request
     */
    body: {
        items: Array<CreateExamplePostRequest>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch';
};

export type ExamplePostsBatchCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * Generic batch response envelope
     *
     * Uses results array with status field for each item, matching documentation
     */
    201: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    };
};

export type ExamplePostsBatchCreateResponse = ExamplePostsBatchCreateResponses[keyof ExamplePostsBatchCreateResponses];

export type ExamplePostsBatchRestoreData = {
    /**
     * Post IDs to restore
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch/restore';
};

export type ExamplePostsBatchRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type ExamplePostsBatchRestoreResponse = ExamplePostsBatchRestoreResponses[keyof ExamplePostsBatchRestoreResponses];

export type ExamplePostsBatchSoftDeleteData = {
    /**
     * Post IDs to soft delete
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch/soft-delete';
};

export type ExamplePostsBatchSoftDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: BatchDeleteResponse | ErrorResponse;
};

export type ExamplePostsBatchSoftDeleteResponse = ExamplePostsBatchSoftDeleteResponses[keyof ExamplePostsBatchSoftDeleteResponses];

export type ExamplePostsListCursorData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Cursor for fetching next page (post ID from previous response)
         */
        cursor?: string;
        /**
         * Maximum items to return (max: 100, default: 50)
         */
        limit?: number;
        /**
         * Sort order (e.g., "-createdAt" for desc, "createdAt" for asc)
         */
        orderBy?: string;
        /**
         * Filter by post status
         */
        status?: ExamplePostStatus;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Full-text search query
         */
        search?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/cursor';
};

export type ExamplePostsListCursorResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostCursorListResponse | ErrorResponse;
};

export type ExamplePostsListCursorResponse = ExamplePostsListCursorResponses[keyof ExamplePostsListCursorResponses];

export type ExamplePostsListDeletedData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Items per page (max 100)
         */
        pageSize?: number;
    };
    url: '/v1/orgs/{orgId}/example-posts/deleted';
};

export type ExamplePostsListDeletedResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostListResponse | ErrorResponse;
};

export type ExamplePostsListDeletedResponse = ExamplePostsListDeletedResponses[keyof ExamplePostsListDeletedResponses];

export type ExamplePostsDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type ExamplePostsDeleteResponse = ExamplePostsDeleteResponses[keyof ExamplePostsDeleteResponses];

export type ExamplePostsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Comma-separated list of relations to include
         */
        include?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsGetResponse = ExamplePostsGetResponses[keyof ExamplePostsGetResponses];

export type ExamplePostsUpdateData = {
    /**
     * Post update data
     */
    body: UpdateExamplePostRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsUpdateResponse = ExamplePostsUpdateResponses[keyof ExamplePostsUpdateResponses];

export type ExamplePostsDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}/permanent';
};

export type ExamplePostsDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type ExamplePostsDeletePermanentResponse = ExamplePostsDeletePermanentResponses[keyof ExamplePostsDeletePermanentResponses];

export type ExamplePostsRestoreData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}/restore';
};

export type ExamplePostsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsRestoreResponse = ExamplePostsRestoreResponses[keyof ExamplePostsRestoreResponses];

export type ExampleCommentsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-createdAt" for newest first)
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Filter by content contains
         */
        contentContains?: string;
        /**
         * Filter comments created after this timestamp
         */
        createdAfter?: string;
        /**
         * Filter comments created before this timestamp
         */
        createdBefore?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments';
};

export type ExampleCommentsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentListResponse | ErrorResponse;
};

export type ExampleCommentsListResponse = ExampleCommentsListResponses[keyof ExampleCommentsListResponses];

export type ExampleCommentsCreateData = {
    /**
     * Comment creation data
     */
    body: CreateExampleCommentRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments';
};

export type ExampleCommentsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ExampleCommentResponse;
};

export type ExampleCommentsCreateResponse = ExampleCommentsCreateResponses[keyof ExampleCommentsCreateResponses];

export type ExampleCommentsBatchCreateData = {
    /**
     * Batch create request
     */
    body: {
        items: Array<CreateExampleCommentRequest>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch';
};

export type ExampleCommentsBatchCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * Generic batch response envelope
     *
     * Uses results array with status field for each item, matching documentation
     */
    201: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExampleComment;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    };
};

export type ExampleCommentsBatchCreateResponse = ExampleCommentsBatchCreateResponses[keyof ExampleCommentsBatchCreateResponses];

export type ExampleCommentsBatchSoftDeleteData = {
    /**
     * Comment IDs to soft delete
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch/soft-delete';
};

export type ExampleCommentsBatchSoftDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: BatchDeleteResponse | ErrorResponse;
};

export type ExampleCommentsBatchSoftDeleteResponse = ExampleCommentsBatchSoftDeleteResponses[keyof ExampleCommentsBatchSoftDeleteResponses];

export type ExampleCommentsDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type ExampleCommentsDeleteResponse = ExampleCommentsDeleteResponses[keyof ExampleCommentsDeleteResponses];

export type ExampleCommentsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsGetResponse = ExampleCommentsGetResponses[keyof ExampleCommentsGetResponses];

export type ExampleCommentsUpdateData = {
    /**
     * Comment update data
     */
    body: UpdateExampleCommentRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsUpdateResponse = ExampleCommentsUpdateResponses[keyof ExampleCommentsUpdateResponses];

export type ExampleCommentsDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/permanent';
};

export type ExampleCommentsDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type ExampleCommentsDeletePermanentResponse = ExampleCommentsDeletePermanentResponses[keyof ExampleCommentsDeletePermanentResponses];

export type ExampleCommentsRestoreData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/restore';
};

export type ExampleCommentsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsRestoreResponse = ExampleCommentsRestoreResponses[keyof ExampleCommentsRestoreResponses];

export type FilesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-uploadedAt,filename")
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Filter by MIME type
         */
        mimeType?: string;
        /**
         * Filter by virus scan status
         */
        virusScanStatus?: VirusScanStatus;
        /**
         * Filter by access level
         */
        access?: FileAccess;
        /**
         * Filter files uploaded after this timestamp
         */
        uploadedAfter?: string;
        /**
         * Filter files uploaded before this timestamp
         */
        uploadedBefore?: string;
        /**
         * Filter by uploader user ID
         */
        uploadedBy?: string;
    };
    url: '/v1/orgs/{orgId}/files';
};

export type FilesListResponses = {
    /**
     * The request has succeeded.
     */
    200: FileListResponse | ErrorResponse;
};

export type FilesListResponse = FilesListResponses[keyof FilesListResponses];

export type FilesDirectUploadData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files';
};

export type FilesDirectUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: FileResponse;
};

export type FilesDirectUploadResponse = FilesDirectUploadResponses[keyof FilesDirectUploadResponses];

export type FilesInitiateUploadData = {
    /**
     * Upload request with file metadata
     */
    body: InitiateUploadRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/uploads';
};

export type FilesInitiateUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: InitiateUploadResponse | ErrorResponse;
};

export type FilesInitiateUploadResponse = FilesInitiateUploadResponses[keyof FilesInitiateUploadResponses];

export type FilesConfirmUploadData = {
    /**
     * Confirmation data
     */
    body: ConfirmUploadRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Upload ID from initiate response
         */
        uploadId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/uploads/{uploadId}/confirm';
};

export type FilesConfirmUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: FileResponse;
};

export type FilesConfirmUploadResponse = FilesConfirmUploadResponses[keyof FilesConfirmUploadResponses];

export type FilesDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: FileDeleteResponse | ErrorResponse;
};

export type FilesDeleteResponse = FilesDeleteResponses[keyof FilesDeleteResponses];

export type FilesGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
    };
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: FileResponse | ErrorResponse;
};

export type FilesGetResponse = FilesGetResponses[keyof FilesGetResponses];

export type FilesUpdateData = {
    /**
     * Update request
     */
    body: UpdateFileRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: FileResponse | ErrorResponse;
};

export type FilesUpdateResponse = FilesUpdateResponses[keyof FilesUpdateResponses];

export type FilesDownloadData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}/download';
};

export type FilesDownloadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
};

export type FilesDownloadResponse = FilesDownloadResponses[keyof FilesDownloadResponses];

export type FilesDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}/permanent';
};

export type FilesDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type FilesDeletePermanentResponse = FilesDeletePermanentResponses[keyof FilesDeletePermanentResponses];

export type JobsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by job status
         */
        status?: JobStatus;
        /**
         * Filter by job type
         */
        type?: string;
        /**
         * Filter jobs created after this timestamp
         */
        createdAfter?: string;
    };
    url: '/v1/orgs/{orgId}/jobs';
};

export type JobsListResponses = {
    /**
     * The request has succeeded.
     */
    200: JobListResponse | ErrorResponse;
};

export type JobsListResponse = JobsListResponses[keyof JobsListResponses];

export type JobsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Job ID
         */
        jobId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs/{jobId}';
};

export type JobsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type JobsGetResponse = JobsGetResponses[keyof JobsGetResponses];

export type JobsCancelData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Job ID
         */
        jobId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs/{jobId}/cancel';
};

export type JobsCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type JobsCancelResponse = JobsCancelResponses[keyof JobsCancelResponses];

export type TenantRolesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by system role status
         */
        isSystemRole?: boolean;
    };
    url: '/v1/orgs/{orgId}/roles';
};

export type TenantRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleListResponse | ErrorResponse;
};

export type TenantRolesListResponse = TenantRolesListResponses[keyof TenantRolesListResponses];

export type TenantRolesCreateData = {
    /**
     * Role data
     */
    body: CreateRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles';
};

export type TenantRolesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: RoleResponse;
};

export type TenantRolesCreateResponse = TenantRolesCreateResponses[keyof TenantRolesCreateResponses];

export type TenantRolesDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type TenantRolesDeleteResponse = TenantRolesDeleteResponses[keyof TenantRolesDeleteResponses];

export type TenantRolesGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type TenantRolesGetResponse = TenantRolesGetResponses[keyof TenantRolesGetResponses];

export type TenantRolesUpdateData = {
    /**
     * Role update data
     */
    body: UpdateRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type TenantRolesUpdateResponse = TenantRolesUpdateResponses[keyof TenantRolesUpdateResponses];

export type UserPermissionsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/permissions';
};

export type UserPermissionsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: UserEffectivePermissionsResponse | ErrorResponse;
};

export type UserPermissionsGetResponse = UserPermissionsGetResponses[keyof UserPermissionsGetResponses];

export type UserTenantRolesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles';
};

export type UserTenantRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserRoleAssignmentListResponse | ErrorResponse;
};

export type UserTenantRolesListResponse = UserTenantRolesListResponses[keyof UserTenantRolesListResponses];

export type UserTenantRolesAssignData = {
    /**
     * Role assignment
     */
    body: AssignRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles';
};

export type UserTenantRolesAssignResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: UserRoleAssignmentResponse;
};

export type UserTenantRolesAssignResponse = UserTenantRolesAssignResponses[keyof UserTenantRolesAssignResponses];

export type UserTenantRolesRemoveData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
        /**
         * Role ID to remove
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles/{roleId}';
};

export type UserTenantRolesRemoveResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type UserTenantRolesRemoveResponse = UserTenantRolesRemoveResponses[keyof UserTenantRolesRemoveResponses];

export type WebhooksListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by active status
         */
        isActive?: boolean;
    };
    url: '/v1/orgs/{orgId}/webhooks';
};

export type WebhooksListResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookListResponse | ErrorResponse;
};

export type WebhooksListResponse = WebhooksListResponses[keyof WebhooksListResponses];

export type WebhooksCreateData = {
    /**
     * Webhook configuration
     */
    body: CreateWebhookRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks';
};

export type WebhooksCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: WebhookCreatedResponse;
};

export type WebhooksCreateResponse = WebhooksCreateResponses[keyof WebhooksCreateResponses];

export type WebhooksListEventTypesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/event-types';
};

export type WebhooksListEventTypesResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookEventTypesResponse | ErrorResponse;
};

export type WebhooksListEventTypesResponse = WebhooksListEventTypesResponses[keyof WebhooksListEventTypesResponses];

export type WebhooksDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type WebhooksDeleteResponse = WebhooksDeleteResponses[keyof WebhooksDeleteResponses];

export type WebhooksGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksGetResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookResponse | ErrorResponse;
};

export type WebhooksGetResponse = WebhooksGetResponses[keyof WebhooksGetResponses];

export type WebhooksUpdateData = {
    /**
     * Update data
     */
    body: UpdateWebhookRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookResponse | ErrorResponse;
};

export type WebhooksUpdateResponse = WebhooksUpdateResponses[keyof WebhooksUpdateResponses];

export type WebhooksListDeliveriesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Items per page
         */
        pageSize?: number;
        /**
         * Filter by status
         */
        status?: WebhookDeliveryStatus;
        /**
         * Filter by event type
         */
        eventType?: string;
        /**
         * Filter deliveries after this timestamp
         */
        createdAfter?: string;
    };
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries';
};

export type WebhooksListDeliveriesResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryListResponse | ErrorResponse;
};

export type WebhooksListDeliveriesResponse = WebhooksListDeliveriesResponses[keyof WebhooksListDeliveriesResponses];

export type WebhooksGetDeliveryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
        /**
         * Delivery ID
         */
        deliveryId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}';
};

export type WebhooksGetDeliveryResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryResponse | ErrorResponse;
};

export type WebhooksGetDeliveryResponse = WebhooksGetDeliveryResponses[keyof WebhooksGetDeliveryResponses];

export type WebhooksRetryDeliveryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
        /**
         * Delivery ID
         */
        deliveryId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}/retry';
};

export type WebhooksRetryDeliveryResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryResponse | ErrorResponse;
};

export type WebhooksRetryDeliveryResponse = WebhooksRetryDeliveryResponses[keyof WebhooksRetryDeliveryResponses];

export type WebhooksRotateSecretData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/rotate-secret';
};

export type WebhooksRotateSecretResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookCreatedResponse | ErrorResponse;
};

export type WebhooksRotateSecretResponse = WebhooksRotateSecretResponses[keyof WebhooksRotateSecretResponses];

export type WebhooksTestData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/test';
};

export type WebhooksTestResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        data: {
            /**
             * Whether the test was successful
             */
            success: boolean;
            /**
             * HTTP status code from the webhook endpoint
             */
            httpStatus?: number;
            /**
             * Response time in milliseconds
             */
            durationMs?: number;
            /**
             * Error message if failed
             */
            error?: string;
        };
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type WebhooksTestResponse = WebhooksTestResponses[keyof WebhooksTestResponses];

export type NotificationPreferencesRoutesGetPreferencesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/preferences';
};

export type NotificationPreferencesRoutesGetPreferencesResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationPreferencesResponse | ErrorResponse;
};

export type NotificationPreferencesRoutesGetPreferencesResponse = NotificationPreferencesRoutesGetPreferencesResponses[keyof NotificationPreferencesRoutesGetPreferencesResponses];

export type NotificationPreferencesRoutesUpdatePreferencesData = {
    body: UpdatePreferencesRequest;
    path?: never;
    query?: never;
    url: '/v1/preferences';
};

export type NotificationPreferencesRoutesUpdatePreferencesResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationPreferencesResponse | ErrorResponse;
};

export type NotificationPreferencesRoutesUpdatePreferencesResponse = NotificationPreferencesRoutesUpdatePreferencesResponses[keyof NotificationPreferencesRoutesUpdatePreferencesResponses];

export type GlobalRolesListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by system role status
         */
        isSystemRole?: boolean;
    };
    url: '/v1/roles';
};

export type GlobalRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleListResponse | ErrorResponse;
};

export type GlobalRolesListResponse = GlobalRolesListResponses[keyof GlobalRolesListResponses];

export type GlobalRolesCreateData = {
    /**
     * Role data
     */
    body: CreateRoleRequest;
    path?: never;
    query?: never;
    url: '/v1/roles';
};

export type GlobalRolesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: RoleResponse;
};

export type GlobalRolesCreateResponse = GlobalRolesCreateResponses[keyof GlobalRolesCreateResponses];

export type GlobalRolesDeleteData = {
    body?: never;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type GlobalRolesDeleteResponse = GlobalRolesDeleteResponses[keyof GlobalRolesDeleteResponses];

export type GlobalRolesGetData = {
    body?: never;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type GlobalRolesGetResponse = GlobalRolesGetResponses[keyof GlobalRolesGetResponses];

export type GlobalRolesUpdateData = {
    /**
     * Role update data
     */
    body: UpdateRoleRequest;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type GlobalRolesUpdateResponse = GlobalRolesUpdateResponses[keyof GlobalRolesUpdateResponses];

export type AvailableContextsListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/me/available-contexts';
};

export type AvailableContextsListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserContextListResponse | ErrorResponse;
};

export type AvailableContextsListResponse = AvailableContextsListResponses[keyof AvailableContextsListResponses];

export type CurrentUserContextGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/me/context';
};

export type CurrentUserContextGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ActiveContextResponse | ErrorResponse;
};

export type CurrentUserContextGetResponse = CurrentUserContextGetResponses[keyof CurrentUserContextGetResponses];

export type ContextSwitchSwitchData = {
    /**
     * Target context
     */
    body: SwitchContextRequest;
    path?: never;
    query?: never;
    url: '/v1/users/me/switch-context';
};

export type ContextSwitchSwitchResponses = {
    /**
     * The request has succeeded.
     */
    200: SwitchContextResponse | ErrorResponse;
};

export type ContextSwitchSwitchResponse = ContextSwitchSwitchResponses[keyof ContextSwitchSwitchResponses];

export type AllUserRolesListData = {
    body?: never;
    path: {
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/users/{userId}/roles';
};

export type AllUserRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserRoleAssignmentListResponse | ErrorResponse;
};

export type AllUserRolesListResponse = AllUserRolesListResponses[keyof AllUserRolesListResponses];
