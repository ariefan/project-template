// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * User's active context (current app/tenant selection)
 */
export const zActiveContext = z.object({
    userId: z.string(),
    activeApplicationId: z.string(),
    activeTenantId: z.optional(z.string()),
    updatedAt: z.iso.datetime()
});

/**
 * Request to assign a role to a user
 */
export const zAssignRoleRequest = z.object({
    roleId: z.string()
});

/**
 * Actor type - who performed the action
 */
export const zAuditActorType = z.enum([
    'user',
    'service',
    'system'
]);

/**
 * Actor who performed the action
 */
export const zAuditActor = z.object({
    type: zAuditActorType,
    id: z.string(),
    email: z.optional(z.string()),
    ipAddress: z.optional(z.string()),
    userAgent: z.optional(z.string())
});

/**
 * Change record for a single field
 */
export const zAuditChange = z.object({
    old: z.unknown(),
    new: z.unknown()
});

/**
 * Additional metadata for the audit event
 */
export const zAuditMetadata = z.object({
    requestId: z.optional(z.string()),
    sessionId: z.optional(z.string()),
    reason: z.optional(z.string()),
    extra: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Resource affected by the action
 */
export const zAuditResource = z.object({
    type: z.string(),
    id: z.string(),
    endpoint: z.optional(z.string()),
    method: z.optional(z.string())
});

/**
 * Audit log entry
 *
 * Immutable record of an action in the system.
 */
export const zAuditLog = z.object({
    eventId: z.string(),
    eventType: z.string(),
    timestamp: z.iso.datetime(),
    tenantId: z.string(),
    actor: zAuditActor,
    resource: zAuditResource,
    changes: z.optional(z.record(z.string(), zAuditChange)),
    resourceBefore: z.optional(z.record(z.string(), z.unknown())),
    resourceAfter: z.optional(z.record(z.string(), z.unknown())),
    metadata: z.optional(zAuditMetadata)
});

/**
 * Batch delete result (soft delete)
 */
export const zBatchDeleteResult = z.object({
    index: z.int(),
    status: z.enum([
        'success',
        'error',
        'skipped'
    ]),
    data: z.optional(z.object({
        id: z.string(),
        deletedAt: z.iso.datetime()
    })),
    error: z.optional(z.object({
        code: z.string(),
        message: z.string()
    }))
});

/**
 * Options for batch operations
 */
export const zBatchOptions = z.object({
    atomic: z.optional(z.boolean()),
    returnRecords: z.optional(z.boolean()),
    skipDuplicates: z.optional(z.boolean()),
    validateOnly: z.optional(z.boolean())
});

/**
 * Summary of batch operation results
 */
export const zBatchSummary = z.object({
    total: z.int(),
    successful: z.int(),
    failed: z.int(),
    skipped: z.int()
});

/**
 * Column alignment
 */
export const zColumnAlignment = z.enum([
    'left',
    'center',
    'right'
]);

/**
 * Column data format
 */
export const zColumnFormat = z.enum([
    'text',
    'number',
    'currency',
    'date',
    'datetime',
    'boolean',
    'percentage'
]);

/**
 * Request to confirm an upload completed successfully
 */
export const zConfirmUploadRequest = z.object({
    etag: z.optional(z.string())
});

/**
 * Request body for creating a new comment
 */
export const zCreateExampleCommentRequest = z.object({
    content: z.string(),
    authorId: z.string()
});

/**
 * Request to create a webhook
 */
export const zCreateWebhookRequest = z.object({
    url: z.url(),
    name: z.optional(z.string().max(100)),
    description: z.optional(z.string().max(500)),
    events: z.array(z.string()).min(1),
    isActive: z.optional(z.boolean())
});

/**
 * Cursor-based pagination for large datasets or real-time data
 */
export const zCursorPagination = z.object({
    limit: z.int(),
    hasNext: z.boolean(),
    nextCursor: z.union([
        z.string(),
        z.null()
    ]),
    previousCursor: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Data source configuration for report templates
 */
export const zDataSourceConfig = z.object({
    type: z.enum([
        'query',
        'api',
        'custom'
    ]),
    source: z.optional(z.string()),
    defaultParams: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Data source configuration for report templates
 */
export const zDataSourceConfigUpdate = z.object({
    type: z.optional(z.enum([
        'query',
        'api',
        'custom'
    ])),
    source: z.optional(z.string()),
    defaultParams: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Day of week for weekly schedules
 */
export const zDayOfWeek = z.enum([
    'monday',
    'tuesday',
    'wednesday',
    'thursday',
    'friday',
    'saturday',
    'sunday'
]);

/**
 * Report delivery method
 */
export const zDeliveryMethod = z.enum([
    'email',
    'download',
    'webhook',
    'storage'
]);

/**
 * Email delivery configuration
 */
export const zEmailDeliveryConfig = z.object({
    recipients: z.array(z.string()),
    subject: z.optional(z.string()),
    body: z.optional(z.string()),
    cc: z.optional(z.array(z.string())),
    bcc: z.optional(z.array(z.string()))
});

/**
 * Email delivery configuration
 */
export const zEmailDeliveryConfigUpdate = z.object({
    recipients: z.optional(z.array(z.string())),
    subject: z.optional(z.string()),
    body: z.optional(z.string()),
    cc: z.optional(z.array(z.string())),
    bcc: z.optional(z.array(z.string()))
});

/**
 * Detailed error information for a specific field or validation
 */
export const zErrorDetail = z.object({
    field: z.string(),
    code: z.string(),
    message: z.string(),
    metadata: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Standard error object
 */
export const zError = z.object({
    code: z.string(),
    message: z.string(),
    details: z.optional(z.array(zErrorDetail)),
    requestId: z.string(),
    documentationUrl: z.optional(z.string())
});

/**
 * Standard error response envelope
 */
export const zErrorResponse = z.object({
    error: zError
});

/**
 * ExampleComment resource model (nested under ExamplePost)
 *
 * Demonstrates:
 * - Nested sub-resource pattern (belongs to a post)
 * - Multi-tenant scoping (orgId)
 * - Soft delete with restore capability
 */
export const zExampleComment = z.object({
    id: z.string(),
    orgId: z.string(),
    postId: z.string(),
    content: z.string(),
    authorId: z.string(),
    isDeleted: z.boolean(),
    deletedAt: z.optional(z.iso.datetime()),
    deletedBy: z.optional(z.string()),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * Post status enum
 */
export const zExamplePostStatus = z.enum([
    'draft',
    'published',
    'archived'
]);

/**
 * Request body for creating a new post
 */
export const zCreateExamplePostRequest = z.object({
    title: z.string(),
    content: z.string(),
    authorId: z.string(),
    status: z.optional(zExamplePostStatus)
});

/**
 * ExamplePost resource model
 *
 * Demonstrates a typical content resource with:
 * - Multi-tenant scoping (orgId)
 * - Status workflow (draft → published → archived)
 * - Soft delete with restore capability
 */
export const zExamplePost = z.object({
    id: z.string(),
    orgId: z.string(),
    title: z.string(),
    content: z.string(),
    authorId: z.string(),
    status: zExamplePostStatus,
    publishedAt: z.optional(z.iso.datetime()),
    isDeleted: z.boolean(),
    deletedAt: z.optional(z.iso.datetime()),
    deletedBy: z.optional(z.string()),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * File access level
 */
export const zFileAccess = z.enum(['private', 'public']);

/**
 * Request to initiate a presigned URL upload
 */
export const zInitiateUploadRequest = z.object({
    filename: z.string().min(1).max(255),
    contentType: z.string(),
    size: z.coerce.bigint().gte(BigInt(1)),
    metadata: z.optional(z.record(z.string(), z.string()))
});

/**
 * Job status
 */
export const zJobStatus = z.enum([
    'pending',
    'processing',
    'completed',
    'failed',
    'cancelled'
]);

/**
 * Async job resource
 *
 * Represents a long-running operation that can be polled for status.
 */
export const zJob = z.object({
    jobId: z.string(),
    tenantId: z.string(),
    type: z.string(),
    status: zJobStatus,
    progress: z.optional(z.int().gte(0).lte(100)),
    message: z.optional(z.string()),
    result: z.optional(z.record(z.string(), z.unknown())),
    error: z.optional(z.object({
        code: z.string(),
        message: z.string(),
        details: z.optional(z.record(z.string(), z.unknown()))
    })),
    createdBy: z.string(),
    createdAt: z.iso.datetime(),
    startedAt: z.optional(z.iso.datetime()),
    completedAt: z.optional(z.iso.datetime()),
    estimatedCompletion: z.optional(z.iso.datetime())
});

/**
 * Version lifecycle status
 */
export const zMigrationStatus = z.enum([
    'current',
    'deprecated',
    'sunset'
]);

/**
 * Migration status for an API version
 */
export const zMigrationStatusResponse = z.object({
    version: z.string(),
    status: zMigrationStatus,
    sunsetDate: z.optional(z.iso.datetime()),
    daysUntilSunset: z.optional(z.int()),
    replacementVersion: z.optional(z.string()),
    migrationGuideUrl: z.optional(z.string()),
    breakingChanges: z.optional(z.array(z.string())),
    migrationChecklist: z.optional(z.array(z.string()))
});

/**
 * Notification category enum
 */
export const zNotificationCategory = z.enum([
    'transactional',
    'marketing',
    'security',
    'system'
]);

/**
 * Notification channel enum
 */
export const zNotificationChannel = z.enum([
    'email',
    'sms',
    'whatsapp',
    'telegram',
    'push',
    'none'
]);

/**
 * Notification preferences model
 */
export const zNotificationPreferences = z.object({
    userId: z.string(),
    emailEnabled: z.boolean(),
    smsEnabled: z.boolean(),
    whatsappEnabled: z.boolean(),
    telegramEnabled: z.boolean(),
    pushEnabled: z.boolean(),
    marketingEnabled: z.boolean(),
    transactionalEnabled: z.boolean(),
    securityEnabled: z.boolean(),
    systemEnabled: z.boolean(),
    preferredEmail: z.optional(z.string()),
    preferredPhone: z.optional(z.string()),
    preferredTelegramId: z.optional(z.string()),
    quietHoursEnabled: z.boolean(),
    quietHoursStart: z.optional(z.string()),
    quietHoursEnd: z.optional(z.string()),
    quietHoursTimezone: z.optional(z.string()),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * Notification priority enum
 */
export const zNotificationPriority = z.enum([
    'urgent',
    'high',
    'normal',
    'low'
]);

/**
 * Notification recipient information
 */
export const zNotificationRecipient = z.object({
    email: z.optional(z.string()),
    phone: z.optional(z.string()),
    telegramId: z.optional(z.string())
});

/**
 * Notification status enum
 */
export const zNotificationStatus = z.enum([
    'pending',
    'queued',
    'processing',
    'sent',
    'delivered',
    'failed',
    'bounced'
]);

/**
 * Notification resource model
 */
export const zNotification = z.object({
    id: z.string(),
    userId: z.optional(z.string()),
    channel: zNotificationChannel,
    category: zNotificationCategory,
    priority: zNotificationPriority,
    status: zNotificationStatus,
    recipientEmail: z.optional(z.string()),
    recipientPhone: z.optional(z.string()),
    recipientTelegramId: z.optional(z.string()),
    templateId: z.optional(z.string()),
    subject: z.optional(z.string()),
    body: z.optional(z.string()),
    bodyHtml: z.optional(z.string()),
    templateData: z.optional(z.record(z.string(), z.unknown())),
    campaignId: z.optional(z.string()),
    provider: z.optional(z.string()),
    providerMessageId: z.optional(z.string()),
    sentAt: z.optional(z.iso.datetime()),
    deliveredAt: z.optional(z.iso.datetime()),
    failedAt: z.optional(z.iso.datetime()),
    readAt: z.optional(z.iso.datetime()),
    deletedAt: z.optional(z.iso.datetime()),
    retryCount: z.int(),
    maxRetries: z.int(),
    nextRetryAt: z.optional(z.iso.datetime()),
    statusMessage: z.optional(z.string()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * Pagination links for navigating through paginated results
 */
export const zPaginationLinks = z.object({
    first: z.union([
        z.string(),
        z.null()
    ]),
    previous: z.union([
        z.string(),
        z.null()
    ]),
    next: z.union([
        z.string(),
        z.null()
    ]),
    last: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Page-based pagination metadata for collection responses
 */
export const zPagination = z.object({
    page: z.int(),
    pageSize: z.int(),
    totalPages: z.int(),
    totalCount: z.int(),
    hasNext: z.boolean(),
    hasPrevious: z.boolean(),
    links: z.optional(zPaginationLinks),
    requestedPageSize: z.optional(z.int())
});

/**
 * Permission actions
 */
export const zPermissionAction = z.enum([
    'read',
    'create',
    'update',
    'delete',
    'manage',
    '*'
]);

/**
 * Permission condition - when the permission applies
 *
 * Conditions enable dynamic, context-aware access control.
 */
export const zPermissionCondition = z.enum([
    '',
    'owner',
    'shared'
]);

/**
 * Permission effect - whether to allow or deny access
 *
 * When a user has multiple roles, permissions are combined:
 * - If ANY role denies an action, it is denied (deny wins)
 * - If no role denies and ANY role allows, it is allowed
 * - If no rules match, access is denied (default deny)
 */
export const zPermissionEffect = z.enum(['allow', 'deny']);

/**
 * Permission definition
 *
 * Permissions define what actions can be performed on resources.
 * They support allow/deny effects and optional conditions.
 */
export const zPermission = z.object({
    resource: z.string(),
    action: z.union([
        zPermissionAction,
        z.string()
    ]),
    effect: zPermissionEffect,
    condition: z.optional(zPermissionCondition)
});

/**
 * Permission input for creating/updating roles
 */
export const zPermissionInput = z.object({
    resource: z.string(),
    action: z.string(),
    effect: z.optional(zPermissionEffect),
    condition: z.optional(zPermissionCondition)
});

/**
 * Request to create a custom role
 */
export const zCreateRoleRequest = z.object({
    name: z.string().min(1).max(100),
    description: z.optional(z.string().max(500)),
    permissions: z.array(zPermissionInput).min(1)
});

/**
 * Request body for previewing an email template
 */
export const zPreviewEmailRequest = z.object({
    templateId: z.string(),
    templateData: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Column configuration for reports
 */
export const zReportColumnConfig = z.object({
    id: z.string(),
    header: z.string(),
    accessorKey: z.optional(z.string()),
    accessorFn: z.optional(z.string()),
    width: z.optional(z.int()),
    align: z.optional(zColumnAlignment),
    format: z.optional(zColumnFormat),
    formatPattern: z.optional(z.string()),
    hidden: z.optional(z.boolean())
});

/**
 * Report output format
 */
export const zReportFormat = z.enum([
    'csv',
    'excel',
    'pdf',
    'thermal',
    'dotmatrix'
]);

/**
 * Job error data (when failed)
 */
export const zReportJobError = z.object({
    code: z.string(),
    message: z.string(),
    stack: z.optional(z.string()),
    retryable: z.boolean()
});

/**
 * Job result data (when completed successfully)
 */
export const zReportJobResult = z.object({
    filePath: z.optional(z.string()),
    fileSize: z.optional(z.coerce.bigint()),
    rowCount: z.optional(z.int()),
    downloadUrl: z.optional(z.string()),
    downloadExpiresAt: z.optional(z.iso.datetime()),
    mimeType: z.optional(z.string()),
    deliveryStatus: z.optional(z.enum([
        'pending',
        'sent',
        'failed'
    ])),
    deliveryError: z.optional(z.string())
});

/**
 * Report job status
 */
export const zReportJobStatus = z.enum([
    'pending',
    'processing',
    'completed',
    'failed',
    'cancelled'
]);

/**
 * Report job type
 */
export const zReportJobType = z.enum(['manual', 'scheduled']);

/**
 * Report Job resource model
 *
 * Tracks individual report generation jobs with:
 * - Progress tracking
 * - Result/error information
 * - Queue integration (pg-boss)
 * - Both manual and scheduled jobs
 */
export const zReportJob = z.object({
    id: z.string(),
    orgId: z.string(),
    templateId: z.optional(z.string()),
    scheduledReportId: z.optional(z.string()),
    type: zReportJobType,
    status: zReportJobStatus,
    format: zReportFormat,
    progress: z.optional(z.int()),
    totalRows: z.optional(z.int()),
    processedRows: z.optional(z.int()),
    parameters: z.optional(z.record(z.string(), z.unknown())),
    result: z.optional(zReportJobResult),
    error: z.optional(zReportJobError),
    queueJobId: z.optional(z.string()),
    createdBy: z.string(),
    createdAt: z.iso.datetime(),
    startedAt: z.optional(z.iso.datetime()),
    completedAt: z.optional(z.iso.datetime()),
    estimatedCompletion: z.optional(z.iso.datetime())
});

/**
 * Page orientation for PDF reports
 */
export const zReportOrientation = z.enum(['portrait', 'landscape']);

/**
 * Page size for PDF reports
 */
export const zReportPageSize = z.enum([
    'a4',
    'letter',
    'legal',
    'a3'
]);

/**
 * Report format-specific options
 */
export const zReportOptions = z.object({
    delimiter: z.optional(z.string()),
    includeHeaders: z.optional(z.boolean()),
    sheetName: z.optional(z.string()),
    autoFilter: z.optional(z.boolean()),
    freezeHeader: z.optional(z.boolean()),
    orientation: z.optional(zReportOrientation),
    pageSize: z.optional(zReportPageSize),
    marginTop: z.optional(z.int()),
    marginRight: z.optional(z.int()),
    marginBottom: z.optional(z.int()),
    marginLeft: z.optional(z.int()),
    title: z.optional(z.string()),
    subtitle: z.optional(z.string()),
    watermark: z.optional(z.string()),
    includePageNumbers: z.optional(z.boolean()),
    includeTimestamp: z.optional(z.boolean()),
    printerWidth: z.optional(z.int()),
    encoding: z.optional(z.string()),
    autoCut: z.optional(z.boolean())
});

/**
 * Request body for creating a new report template
 */
export const zCreateReportTemplateRequest = z.object({
    name: z.string(),
    description: z.optional(z.string()),
    format: zReportFormat,
    templateContent: z.string(),
    options: z.optional(zReportOptions),
    dataSource: z.optional(zDataSourceConfig),
    columns: z.array(zReportColumnConfig),
    isPublic: z.optional(z.boolean())
});

/**
 * Request body for triggering an export
 */
export const zExportRequest = z.object({
    templateId: z.optional(z.string()),
    format: z.optional(zReportFormat),
    data: z.optional(z.array(z.unknown())),
    columns: z.optional(z.array(zReportColumnConfig)),
    options: z.optional(zReportOptions),
    filters: z.optional(z.record(z.string(), z.unknown())),
    sort: z.optional(z.array(z.object({
        field: z.string(),
        direction: z.enum(['asc', 'desc'])
    }))),
    parameters: z.optional(z.record(z.string(), z.unknown())),
    selectedIds: z.optional(z.array(z.string())),
    async: z.optional(z.boolean())
});

/**
 * Report Template resource model
 *
 * Defines reusable report configurations with:
 * - Multiple output formats (CSV, Excel, PDF, Thermal, Dot-Matrix)
 * - Eta template engine for custom layouts
 * - Column definitions with formatting
 * - Data source configuration
 * - Multi-tenant scoping
 */
export const zReportTemplate = z.object({
    id: z.string(),
    orgId: z.string(),
    name: z.string(),
    description: z.optional(z.string()),
    format: zReportFormat,
    templateEngine: z.string(),
    templateContent: z.string(),
    options: z.optional(zReportOptions),
    dataSource: z.optional(zDataSourceConfig),
    columns: z.array(zReportColumnConfig),
    isPublic: z.boolean(),
    createdBy: z.string(),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime(),
    deletedAt: z.optional(z.iso.datetime())
});

/**
 * Response metadata included in all API responses
 */
export const zResponseMeta = z.object({
    requestId: z.string(),
    timestamp: z.iso.datetime(),
    apiVersion: z.optional(z.string()),
    tenantId: z.optional(z.string()),
    tenantName: z.optional(z.string()),
    durationMs: z.optional(z.int())
});

/**
 * Active context response
 */
export const zActiveContextResponse = z.object({
    data: zActiveContext,
    meta: zResponseMeta
});

/**
 * Async export response (returns job info)
 */
export const zAsyncExportResponse = z.object({
    jobId: z.string(),
    status: zReportJobStatus,
    statusUrl: z.string(),
    estimatedCompletion: z.optional(z.iso.datetime()),
    meta: zResponseMeta
});

/**
 * Response for async operations that return 202 Accepted
 */
export const zAsyncJobResponse = z.object({
    jobId: z.string(),
    status: z.enum([
        'pending',
        'processing',
        'completed',
        'failed'
    ]),
    statusUrl: z.string(),
    estimatedCompletion: z.optional(z.iso.datetime()),
    meta: zResponseMeta
});

/**
 * Audit log list response
 */
export const zAuditLogListResponse = z.object({
    data: z.array(zAuditLog),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single audit log response
 */
export const zAuditLogResponse = z.object({
    data: zAuditLog,
    meta: zResponseMeta
});

/**
 * Batch delete response envelope
 */
export const zBatchDeleteResponse = z.object({
    results: z.array(zBatchDeleteResult),
    summary: zBatchSummary,
    meta: zResponseMeta
});

/**
 * Comment collection response
 */
export const zExampleCommentListResponse = z.object({
    data: z.array(zExampleComment),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single comment response
 */
export const zExampleCommentResponse = z.object({
    data: zExampleComment,
    meta: zResponseMeta
});

/**
 * Post collection response (cursor-based)
 *
 * Used for streaming/real-time scenarios or large datasets
 */
export const zExamplePostCursorListResponse = z.object({
    data: z.array(zExamplePost),
    pagination: zCursorPagination,
    meta: zResponseMeta
});

/**
 * Post collection response (page-based)
 */
export const zExamplePostListResponse = z.object({
    data: z.array(zExamplePost),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single post response
 */
export const zExamplePostResponse = z.object({
    data: zExamplePost,
    meta: zResponseMeta
});

/**
 * File deletion response
 */
export const zFileDeleteResponse = z.object({
    data: z.object({
        id: z.string(),
        deletedAt: z.iso.datetime(),
        deletedBy: z.string()
    }),
    meta: zResponseMeta
});

/**
 * Response with presigned URL for direct upload to storage
 */
export const zInitiateUploadResponse = z.object({
    data: z.object({
        uploadId: z.string(),
        presignedUrl: z.string(),
        method: z.enum(['PUT']),
        headers: z.record(z.string(), z.string()),
        expiresAt: z.iso.datetime(),
        maxSize: z.coerce.bigint()
    }),
    meta: zResponseMeta
});

/**
 * Job list response
 */
export const zJobListResponse = z.object({
    data: z.array(zJob),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Job status response
 */
export const zJobResponse = z.object({
    data: zJob,
    meta: zResponseMeta
});

/**
 * Mark all as read response
 */
export const zMarkAllReadResponse = z.object({
    data: z.object({
        markedCount: z.int()
    }),
    meta: zResponseMeta
});

/**
 * Notification collection response
 */
export const zNotificationListResponse = z.object({
    data: z.array(zNotification),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Notification preferences response
 */
export const zNotificationPreferencesResponse = z.object({
    data: zNotificationPreferences,
    meta: zResponseMeta
});

/**
 * Single notification response
 */
export const zNotificationResponse = z.object({
    data: zNotification,
    meta: zResponseMeta
});

/**
 * Email preview response
 */
export const zPreviewEmailResponse = z.object({
    data: z.object({
        html: z.string(),
        text: z.string(),
        subject: z.string()
    }),
    meta: zResponseMeta
});

/**
 * Report job collection response (page-based)
 */
export const zReportJobListResponse = z.object({
    data: z.array(zReportJob),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single report job response
 */
export const zReportJobResponse = z.object({
    data: zReportJob,
    meta: zResponseMeta
});

/**
 * Report template collection response (page-based)
 */
export const zReportTemplateListResponse = z.object({
    data: z.array(zReportTemplate),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single report template response
 */
export const zReportTemplateResponse = z.object({
    data: zReportTemplate,
    meta: zResponseMeta
});

/**
 * Role resource model
 *
 * Roles can be:
 * - **Global roles**: App-scoped (tenantId is null), apply across all tenants
 * - **Tenant roles**: Scoped to a specific organization
 *
 * Users can have multiple roles, and permissions are combined with
 * deny-override semantics.
 */
export const zRole = z.object({
    id: z.string(),
    applicationId: z.string(),
    tenantId: z.optional(z.string()),
    name: z.string(),
    description: z.optional(z.string()),
    permissions: z.array(zPermission),
    isSystemRole: z.boolean(),
    isGlobalRole: z.boolean(),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime(),
    createdBy: z.optional(z.string())
});

/**
 * Role list response
 */
export const zRoleListResponse = z.object({
    data: z.array(zRole),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single role response
 */
export const zRoleResponse = z.object({
    data: zRole,
    meta: zResponseMeta
});

/**
 * Schedule frequency
 */
export const zScheduleFrequency = z.enum([
    'once',
    'daily',
    'weekly',
    'monthly',
    'custom'
]);

/**
 * Request body for sending a notification
 */
export const zSendNotificationRequest = z.object({
    channel: zNotificationChannel,
    category: zNotificationCategory,
    priority: z.optional(zNotificationPriority),
    recipient: zNotificationRecipient,
    templateId: z.optional(z.string()),
    templateData: z.optional(z.record(z.string(), z.unknown())),
    subject: z.optional(z.string()),
    body: z.optional(z.string()),
    bodyHtml: z.optional(z.string()),
    metadata: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Send notification success response
 */
export const zSendNotificationResponse = z.object({
    data: z.object({
        messageId: z.string(),
        provider: z.string()
    }),
    meta: zResponseMeta
});

/**
 * Response for soft delete operations
 *
 * Includes resource ID, deletion metadata, and restore information
 */
export const zSoftDeleteResponse = z.object({
    data: z.object({
        id: z.string(),
        deletedAt: z.iso.datetime(),
        deletedBy: z.string(),
        deletionReason: z.optional(z.string()),
        canRestore: z.boolean(),
        restoreUntil: z.optional(z.iso.datetime())
    }),
    meta: zResponseMeta
});

/**
 * Storage delivery configuration
 */
export const zStorageDeliveryConfig = z.object({
    pathTemplate: z.string(),
    provider: z.optional(z.string()),
    bucket: z.optional(z.string())
});

/**
 * Storage delivery configuration
 */
export const zStorageDeliveryConfigUpdate = z.object({
    pathTemplate: z.optional(z.string()),
    provider: z.optional(z.string()),
    bucket: z.optional(z.string())
});

/**
 * Request body for streaming export
 */
export const zStreamExportRequest = z.object({
    templateId: z.optional(z.string()),
    format: z.enum(['csv', 'excel']),
    filters: z.optional(z.record(z.string(), z.unknown())),
    sort: z.optional(z.array(z.object({
        field: z.string(),
        direction: z.enum(['asc', 'desc'])
    }))),
    batchSize: z.optional(z.int())
});

/**
 * Request to switch active context (application and/or tenant)
 */
export const zSwitchContextRequest = z.object({
    applicationId: z.optional(z.string()),
    tenantId: z.optional(z.string())
});

/**
 * Context switch response
 */
export const zSwitchContextResponse = z.object({
    data: z.object({
        applicationId: z.string(),
        tenantId: z.optional(z.string()),
        tenantName: z.optional(z.string()),
        roles: z.array(z.string()),
        permissions: z.array(zPermission)
    }),
    meta: zResponseMeta
});

/**
 * Unread count response
 */
export const zUnreadCountResponse = z.object({
    data: z.object({
        unreadCount: z.int()
    }),
    meta: zResponseMeta
});

/**
 * Request body for updating a comment
 */
export const zUpdateExampleCommentRequest = z.object({
    content: z.optional(z.string())
});

/**
 * Request body for updating a post
 */
export const zUpdateExamplePostRequest = z.object({
    title: z.optional(z.string()),
    content: z.optional(z.string()),
    status: z.optional(zExamplePostStatus)
});

/**
 * Request to update file properties
 */
export const zUpdateFileRequest = z.object({
    access: z.optional(zFileAccess)
});

/**
 * Request body for updating notification preferences
 */
export const zUpdatePreferencesRequest = z.object({
    emailEnabled: z.optional(z.boolean()),
    smsEnabled: z.optional(z.boolean()),
    whatsappEnabled: z.optional(z.boolean()),
    telegramEnabled: z.optional(z.boolean()),
    pushEnabled: z.optional(z.boolean()),
    marketingEnabled: z.optional(z.boolean()),
    transactionalEnabled: z.optional(z.boolean()),
    securityEnabled: z.optional(z.boolean()),
    systemEnabled: z.optional(z.boolean()),
    preferredEmail: z.optional(z.string()),
    preferredPhone: z.optional(z.string()),
    preferredTelegramId: z.optional(z.string()),
    quietHoursEnabled: z.optional(z.boolean()),
    quietHoursStart: z.optional(z.string()),
    quietHoursEnd: z.optional(z.string()),
    quietHoursTimezone: z.optional(z.string())
});

/**
 * Request body for updating a report template
 */
export const zUpdateReportTemplateRequest = z.object({
    name: z.optional(z.string()),
    description: z.optional(z.string()),
    format: z.optional(zReportFormat),
    templateContent: z.optional(z.string()),
    options: z.optional(zReportOptions),
    dataSource: z.optional(zDataSourceConfigUpdate),
    columns: z.optional(z.array(zReportColumnConfig)),
    isPublic: z.optional(z.boolean())
});

/**
 * Request to update a role
 */
export const zUpdateRoleRequest = z.object({
    name: z.optional(z.string().min(1).max(100)),
    description: z.optional(z.string().max(500)),
    permissions: z.optional(z.array(zPermissionInput))
});

/**
 * Request to update a webhook
 */
export const zUpdateWebhookRequest = z.object({
    url: z.optional(z.url()),
    name: z.optional(z.string().max(100)),
    description: z.optional(z.string().max(500)),
    events: z.optional(z.array(z.string())),
    isActive: z.optional(z.boolean())
});

/**
 * User's context across applications and tenants
 */
export const zUserContext = z.object({
    applicationId: z.string(),
    applicationName: z.string(),
    tenantId: z.string(),
    tenantName: z.string(),
    roles: z.array(z.string())
});

/**
 * User available contexts response (all apps/tenants user belongs to)
 */
export const zUserContextListResponse = z.object({
    data: z.array(zUserContext),
    meta: zResponseMeta
});

/**
 * User's effective permissions
 *
 * Represents the combined permissions from all roles assigned to a user
 * within a specific application and tenant context.
 */
export const zUserEffectivePermissions = z.object({
    userId: z.string(),
    applicationId: z.string(),
    tenantId: z.optional(z.string()),
    globalRoles: z.array(z.object({
        id: z.string(),
        name: z.string(),
        permissions: z.array(zPermission)
    })),
    tenantRoles: z.array(z.object({
        id: z.string(),
        name: z.string(),
        permissions: z.array(zPermission)
    })),
    effectivePermissions: z.array(zPermission),
    allowedActions: z.array(z.string())
});

/**
 * User effective permissions response
 */
export const zUserEffectivePermissionsResponse = z.object({
    data: zUserEffectivePermissions,
    meta: zResponseMeta
});

/**
 * User's role assignment
 *
 * Represents a single role assigned to a user within a specific
 * application and optional tenant context.
 */
export const zUserRoleAssignment = z.object({
    id: z.string(),
    userId: z.string(),
    applicationId: z.string(),
    tenantId: z.optional(z.string()),
    roleId: z.string(),
    roleName: z.string(),
    isGlobalRole: z.boolean(),
    assignedAt: z.iso.datetime(),
    assignedBy: z.optional(z.string())
});

/**
 * User role assignments list response
 */
export const zUserRoleAssignmentListResponse = z.object({
    data: z.array(zUserRoleAssignment),
    meta: zResponseMeta
});

/**
 * User role assignment response
 */
export const zUserRoleAssignmentResponse = z.object({
    data: zUserRoleAssignment,
    meta: zResponseMeta
});

/**
 * Virus scan status for uploaded files
 */
export const zVirusScanStatus = z.enum([
    'pending',
    'scanning',
    'clean',
    'infected',
    'failed'
]);

/**
 * File resource model
 *
 * Represents an uploaded file with metadata, security status, and access info.
 */
export const zFile = z.object({
    id: z.string(),
    filename: z.string(),
    size: z.coerce.bigint(),
    mimeType: z.string(),
    storagePath: z.string(),
    url: z.optional(z.string()),
    metadata: z.optional(z.record(z.string(), z.string())),
    uploadedBy: z.string(),
    uploadedAt: z.iso.datetime(),
    virusScanStatus: zVirusScanStatus,
    virusScanCompletedAt: z.optional(z.iso.datetime()),
    access: zFileAccess,
    isDeleted: z.boolean(),
    deletedAt: z.optional(z.iso.datetime()),
    deletedBy: z.optional(z.string())
});

/**
 * File list response with pagination
 */
export const zFileListResponse = z.object({
    data: z.array(zFile),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single file response
 */
export const zFileResponse = z.object({
    data: zFile,
    meta: zResponseMeta
});

/**
 * Webhook configuration
 *
 * Defines an endpoint to receive event notifications.
 */
export const zWebhook = z.object({
    id: z.string(),
    tenantId: z.string(),
    url: z.string(),
    name: z.optional(z.string()),
    description: z.optional(z.string()),
    events: z.array(z.string()),
    secret: z.string(),
    isActive: z.boolean(),
    consecutiveFailures: z.int(),
    lastTriggeredAt: z.optional(z.iso.datetime()),
    lastSuccessAt: z.optional(z.iso.datetime()),
    lastFailureAt: z.optional(z.iso.datetime()),
    createdBy: z.string(),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * Webhook delivery configuration
 */
export const zWebhookDeliveryConfig = z.object({
    url: z.string(),
    headers: z.optional(z.record(z.string(), z.string())),
    attachmentMode: z.optional(z.enum(['attachment', 'base64']))
});

/**
 * Combined delivery configuration
 */
export const zDeliveryConfig = z.object({
    email: z.optional(zEmailDeliveryConfig),
    webhook: z.optional(zWebhookDeliveryConfig),
    storage: z.optional(zStorageDeliveryConfig)
});

/**
 * Request body for creating a scheduled report
 */
export const zCreateScheduledReportRequest = z.object({
    templateId: z.string(),
    name: z.string(),
    description: z.optional(z.string()),
    frequency: zScheduleFrequency,
    cronExpression: z.optional(z.string()),
    dayOfWeek: z.optional(zDayOfWeek),
    dayOfMonth: z.optional(z.int()),
    hour: z.optional(z.int()),
    minute: z.optional(z.int()),
    timezone: z.optional(z.string()),
    startDate: z.optional(z.iso.datetime()),
    endDate: z.optional(z.iso.datetime()),
    deliveryMethod: zDeliveryMethod,
    deliveryConfig: z.optional(zDeliveryConfig),
    parameters: z.optional(z.record(z.string(), z.unknown())),
    isActive: z.optional(z.boolean())
});

/**
 * Scheduled Report resource model
 *
 * Defines automated report generation with:
 * - Flexible scheduling (daily, weekly, monthly, custom cron)
 * - Multiple delivery methods (email, webhook, storage)
 * - Template-based generation
 * - Multi-tenant scoping
 */
export const zScheduledReport = z.object({
    id: z.string(),
    orgId: z.string(),
    templateId: z.string(),
    name: z.string(),
    description: z.optional(z.string()),
    frequency: zScheduleFrequency,
    cronExpression: z.optional(z.string()),
    dayOfWeek: z.optional(zDayOfWeek),
    dayOfMonth: z.optional(z.int()),
    hour: z.optional(z.int()),
    minute: z.optional(z.int()),
    timezone: z.string(),
    startDate: z.iso.datetime(),
    endDate: z.optional(z.iso.datetime()),
    deliveryMethod: zDeliveryMethod,
    deliveryConfig: z.optional(zDeliveryConfig),
    parameters: z.optional(z.record(z.string(), z.unknown())),
    isActive: z.boolean(),
    lastRunAt: z.optional(z.iso.datetime()),
    nextRunAt: z.optional(z.iso.datetime()),
    failureCount: z.int(),
    createdBy: z.string(),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime(),
    deletedAt: z.optional(z.iso.datetime())
});

/**
 * Scheduled report collection response (page-based)
 */
export const zScheduledReportListResponse = z.object({
    data: z.array(zScheduledReport),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single scheduled report response
 */
export const zScheduledReportResponse = z.object({
    data: zScheduledReport,
    meta: zResponseMeta
});

/**
 * Webhook delivery configuration
 */
export const zWebhookDeliveryConfigUpdate = z.object({
    url: z.optional(z.string()),
    headers: z.optional(z.record(z.string(), z.string())),
    attachmentMode: z.optional(z.enum(['attachment', 'base64']))
});

/**
 * Combined delivery configuration
 */
export const zDeliveryConfigUpdate = z.object({
    email: z.optional(zEmailDeliveryConfigUpdate),
    webhook: z.optional(zWebhookDeliveryConfigUpdate),
    storage: z.optional(zStorageDeliveryConfigUpdate)
});

/**
 * Request body for updating a scheduled report
 */
export const zUpdateScheduledReportRequest = z.object({
    templateId: z.optional(z.string()),
    name: z.optional(z.string()),
    description: z.optional(z.string()),
    frequency: z.optional(zScheduleFrequency),
    cronExpression: z.optional(z.string()),
    dayOfWeek: z.optional(zDayOfWeek),
    dayOfMonth: z.optional(z.int()),
    hour: z.optional(z.int()),
    minute: z.optional(z.int()),
    timezone: z.optional(z.string()),
    startDate: z.optional(z.iso.datetime()),
    endDate: z.optional(z.iso.datetime()),
    deliveryMethod: z.optional(zDeliveryMethod),
    deliveryConfig: z.optional(zDeliveryConfigUpdate),
    parameters: z.optional(z.record(z.string(), z.unknown())),
    isActive: z.optional(z.boolean())
});

/**
 * Webhook delivery status
 */
export const zWebhookDeliveryStatus = z.enum([
    'pending',
    'delivered',
    'failed',
    'exhausted'
]);

/**
 * Webhook delivery attempt record
 *
 * Tracks each attempt to deliver a webhook payload.
 */
export const zWebhookDelivery = z.object({
    id: z.string(),
    webhookId: z.string(),
    eventId: z.string(),
    eventType: z.string(),
    status: zWebhookDeliveryStatus,
    attemptCount: z.int(),
    httpStatus: z.optional(z.int()),
    responseBody: z.optional(z.string()),
    errorMessage: z.optional(z.string()),
    durationMs: z.optional(z.int()),
    nextRetryAt: z.optional(z.iso.datetime()),
    createdAt: z.iso.datetime(),
    lastAttemptAt: z.optional(z.iso.datetime()),
    completedAt: z.optional(z.iso.datetime())
});

/**
 * Webhook delivery list response
 */
export const zWebhookDeliveryListResponse = z.object({
    data: z.array(zWebhookDelivery),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Webhook delivery response
 */
export const zWebhookDeliveryResponse = z.object({
    data: zWebhookDelivery,
    meta: zResponseMeta
});

/**
 * Available webhook event types
 */
export const zWebhookEventTypesResponse = z.object({
    data: z.object({
        eventTypes: z.record(z.string(), z.array(z.string()))
    }),
    meta: zResponseMeta
});

/**
 * Webhook list response
 */
export const zWebhookListResponse = z.object({
    data: z.array(zWebhook),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Webhook response (secret masked)
 */
export const zWebhookResponse = z.object({
    data: zWebhook,
    meta: zResponseMeta
});

/**
 * Webhook with unmasked secret (only returned on creation)
 */
export const zWebhookWithSecret = z.object({
    id: z.string(),
    tenantId: z.string(),
    url: z.string(),
    name: z.optional(z.string()),
    events: z.array(z.string()),
    secret: z.string(),
    isActive: z.boolean(),
    createdAt: z.iso.datetime()
});

/**
 * Webhook creation response (includes secret once)
 */
export const zWebhookCreatedResponse = z.object({
    data: zWebhookWithSecret,
    meta: zResponseMeta
});

export const zHealthCheckData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zHealthCheckResponse = z.object({
    status: z.enum([
        'ok',
        'degraded',
        'down'
    ]),
    timestamp: z.iso.datetime(),
    version: z.optional(z.string()),
    services: z.optional(z.object({
        database: z.optional(z.enum([
            'ok',
            'degraded',
            'down'
        ])),
        cache: z.optional(z.enum([
            'ok',
            'degraded',
            'down'
        ])),
        storage: z.optional(z.enum([
            'ok',
            'degraded',
            'down'
        ]))
    }))
});

export const zMigrationGetStatusData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zMigrationGetStatusResponse = zMigrationStatusResponse;

export const zNotificationsListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(20),
        channel: z.optional(zNotificationChannel),
        category: z.optional(zNotificationCategory),
        status: z.optional(zNotificationStatus),
        readStatus: z.optional(z.enum(['read', 'unread'])),
        orderBy: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zNotificationsListResponse = z.union([
    zNotificationListResponse,
    zErrorResponse
]);

export const zNotificationsMarkAllReadData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsMarkAllReadResponse = z.union([
    zMarkAllReadResponse,
    zErrorResponse
]);

export const zNotificationsPreviewEmailData = z.object({
    body: zPreviewEmailRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsPreviewEmailResponse = z.union([
    zPreviewEmailResponse,
    zErrorResponse
]);

export const zNotificationsSendData = z.object({
    body: zSendNotificationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsSendResponse = z.union([
    zSendNotificationResponse,
    zErrorResponse
]);

export const zNotificationsGetUnreadCountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsGetUnreadCountResponse = z.union([
    zUnreadCountResponse,
    zErrorResponse
]);

export const zNotificationsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zNotificationsDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zNotificationsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsGetResponse = z.union([
    zNotificationResponse,
    zErrorResponse
]);

export const zNotificationsMarkReadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zNotificationsMarkReadResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zNotificationsRestoreData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zNotificationsRestoreResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zNotificationsMarkUnreadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zNotificationsMarkUnreadResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zAuditLogsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        eventType: z.optional(z.string()),
        actorId: z.optional(z.string()),
        actorType: z.optional(zAuditActorType),
        resourceType: z.optional(z.string()),
        resourceId: z.optional(z.string()),
        timestampAfter: z.optional(z.iso.datetime()),
        timestampBefore: z.optional(z.iso.datetime()),
        ipAddress: z.optional(z.string()),
        requestId: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zAuditLogsListResponse = z.union([
    zAuditLogListResponse,
    zErrorResponse
]);

export const zAuditLogsExportData = z.object({
    body: z.object({
        format: z.enum(['csv', 'json']),
        timestampAfter: z.optional(z.iso.datetime()),
        timestampBefore: z.optional(z.iso.datetime()),
        eventTypes: z.optional(z.array(z.string()))
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zAuditLogsExportResponse = z.union([
    z.union([
        z.object({
            data: z.object({
                downloadUrl: z.string(),
                eventCount: z.int(),
                expiresAt: z.iso.datetime()
            }),
            meta: zResponseMeta
        }),
        zErrorResponse
    ]),
    zAsyncJobResponse
]);

export const zAuditLogsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        eventId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zAuditLogsGetResponse = z.union([
    zAuditLogResponse,
    zErrorResponse
]);

export const zExamplePostsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        fields: z.optional(z.string()),
        include: z.optional(z.string()),
        search: z.optional(z.string()),
        status: z.optional(zExamplePostStatus),
        statusNe: z.optional(z.string()),
        statusIn: z.optional(z.string()),
        authorId: z.optional(z.string()),
        titleContains: z.optional(z.string()),
        contentContains: z.optional(z.string()),
        createdAfter: z.optional(z.iso.datetime()),
        createdBefore: z.optional(z.iso.datetime()),
        publishedAfter: z.optional(z.iso.datetime()),
        publishedBefore: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListResponse = z.union([
    zExamplePostListResponse,
    zErrorResponse
]);

export const zExamplePostsCreateData = z.object({
    body: zCreateExamplePostRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zExamplePostsCreateResponse = z.union([
    zErrorResponse,
    zExamplePostResponse
]);

export const zExamplePostsBatchUpdateData = z.object({
    body: z.object({
        items: z.optional(z.array(z.object({
            id: z.string(),
            updates: zUpdateExamplePostRequest
        }))),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchUpdateResponse = z.union([
    z.object({
        results: z.array(z.object({
            index: z.int(),
            status: z.enum([
                'success',
                'error',
                'skipped'
            ]),
            data: z.optional(zExamplePost),
            error: z.optional(z.object({
                code: z.string(),
                message: z.string()
            })),
            input: z.optional(z.record(z.string(), z.unknown()))
        })),
        summary: zBatchSummary,
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zExamplePostsBatchCreateData = z.object({
    body: z.object({
        items: z.array(zCreateExamplePostRequest),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zExamplePostsBatchCreateResponse = z.union([
    zErrorResponse,
    z.object({
        results: z.array(z.object({
            index: z.int(),
            status: z.enum([
                'success',
                'error',
                'skipped'
            ]),
            data: z.optional(zExamplePost),
            error: z.optional(z.object({
                code: z.string(),
                message: z.string()
            })),
            input: z.optional(z.record(z.string(), z.unknown()))
        })),
        summary: zBatchSummary,
        meta: zResponseMeta
    })
]);

export const zExamplePostsBatchRestoreData = z.object({
    body: z.object({
        ids: z.array(z.string()),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchRestoreResponse = z.union([
    z.object({
        results: z.array(z.object({
            index: z.int(),
            status: z.enum([
                'success',
                'error',
                'skipped'
            ]),
            data: z.optional(zExamplePost),
            error: z.optional(z.object({
                code: z.string(),
                message: z.string()
            })),
            input: z.optional(z.record(z.string(), z.unknown()))
        })),
        summary: zBatchSummary,
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zExamplePostsBatchSoftDeleteData = z.object({
    body: z.object({
        ids: z.array(z.string()),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchSoftDeleteResponse = z.union([
    zBatchDeleteResponse,
    zErrorResponse
]);

export const zExamplePostsListCursorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        cursor: z.optional(z.string()),
        limit: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        status: z.optional(zExamplePostStatus),
        authorId: z.optional(z.string()),
        search: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListCursorResponse = z.union([
    zExamplePostCursorListResponse,
    zErrorResponse
]);

export const zExamplePostsListDeletedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50)
    }))
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListDeletedResponse = z.union([
    zExamplePostListResponse,
    zErrorResponse
]);

export const zExamplePostsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsDeleteResponse = z.union([
    zSoftDeleteResponse,
    zErrorResponse
]);

export const zExamplePostsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.object({
        fields: z.optional(z.string()),
        include: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zExamplePostsGetResponse = z.union([
    zExamplePostResponse,
    zErrorResponse
]);

export const zExamplePostsUpdateData = z.object({
    body: zUpdateExamplePostRequest,
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsUpdateResponse = z.union([
    zExamplePostResponse,
    zErrorResponse
]);

export const zExamplePostsDeletePermanentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zExamplePostsDeletePermanentResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zExamplePostsRestoreData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsRestoreResponse = z.union([
    zExamplePostResponse,
    zErrorResponse
]);

export const zExampleCommentsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        fields: z.optional(z.string()),
        authorId: z.optional(z.string()),
        contentContains: z.optional(z.string()),
        createdAfter: z.optional(z.iso.datetime()),
        createdBefore: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsListResponse = z.union([
    zExampleCommentListResponse,
    zErrorResponse
]);

export const zExampleCommentsCreateData = z.object({
    body: zCreateExampleCommentRequest,
    path: z.object({
        orgId: z.string(),
        postId: z.string()
    }),
    query: z.optional(z.never())
});

export const zExampleCommentsCreateResponse = z.union([
    zErrorResponse,
    zExampleCommentResponse
]);

export const zExampleCommentsBatchCreateData = z.object({
    body: z.object({
        items: z.array(zCreateExampleCommentRequest),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string(),
        postId: z.string()
    }),
    query: z.optional(z.never())
});

export const zExampleCommentsBatchCreateResponse = z.union([
    zErrorResponse,
    z.object({
        results: z.array(z.object({
            index: z.int(),
            status: z.enum([
                'success',
                'error',
                'skipped'
            ]),
            data: z.optional(zExampleComment),
            error: z.optional(z.object({
                code: z.string(),
                message: z.string()
            })),
            input: z.optional(z.record(z.string(), z.unknown()))
        })),
        summary: zBatchSummary,
        meta: zResponseMeta
    })
]);

export const zExampleCommentsBatchSoftDeleteData = z.object({
    body: z.object({
        ids: z.array(z.string()),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string(),
        postId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsBatchSoftDeleteResponse = z.union([
    zBatchDeleteResponse,
    zErrorResponse
]);

export const zExampleCommentsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsDeleteResponse = z.union([
    zSoftDeleteResponse,
    zErrorResponse
]);

export const zExampleCommentsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.object({
        fields: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsGetResponse = z.union([
    zExampleCommentResponse,
    zErrorResponse
]);

export const zExampleCommentsUpdateData = z.object({
    body: zUpdateExampleCommentRequest,
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsUpdateResponse = z.union([
    zExampleCommentResponse,
    zErrorResponse
]);

export const zExampleCommentsDeletePermanentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zExampleCommentsDeletePermanentResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zExampleCommentsRestoreData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsRestoreResponse = z.union([
    zExampleCommentResponse,
    zErrorResponse
]);

export const zFilesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        fields: z.optional(z.string()),
        mimeType: z.optional(z.string()),
        virusScanStatus: z.optional(zVirusScanStatus),
        access: z.optional(zFileAccess),
        uploadedAfter: z.optional(z.iso.datetime()),
        uploadedBefore: z.optional(z.iso.datetime()),
        uploadedBy: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zFilesListResponse = z.union([
    zFileListResponse,
    zErrorResponse
]);

export const zFilesDirectUploadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zFilesDirectUploadResponse = z.union([
    zErrorResponse,
    zFileResponse
]);

export const zFilesInitiateUploadData = z.object({
    body: zInitiateUploadRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zFilesInitiateUploadResponse = z.union([
    zInitiateUploadResponse,
    zErrorResponse
]);

export const zFilesConfirmUploadData = z.object({
    body: zConfirmUploadRequest,
    path: z.object({
        orgId: z.string(),
        uploadId: z.string()
    }),
    query: z.optional(z.never())
});

export const zFilesConfirmUploadResponse = z.union([
    zErrorResponse,
    zFileResponse
]);

export const zFilesDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zFilesDeleteResponse = z.union([
    zFileDeleteResponse,
    zErrorResponse
]);

export const zFilesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.object({
        fields: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zFilesGetResponse = z.union([
    zFileResponse,
    zErrorResponse
]);

export const zFilesUpdateData = z.object({
    body: zUpdateFileRequest,
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zFilesUpdateResponse = z.union([
    zFileResponse,
    zErrorResponse
]);

export const zFilesDownloadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zFilesDownloadResponse = zErrorResponse;

export const zFilesDeletePermanentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.never())
});

export const zFilesDeletePermanentResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zJobsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        status: z.optional(zJobStatus),
        type: z.optional(z.string()),
        createdAfter: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zJobsListResponse = z.union([
    zJobListResponse,
    zErrorResponse
]);

export const zJobsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zJobsGetResponse = z.union([
    zJobResponse,
    zErrorResponse
]);

export const zJobsCancelData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zJobsCancelResponse = z.union([
    zJobResponse,
    zErrorResponse
]);

export const zReportExportsExportData = z.object({
    body: zExportRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportExportsExportResponse = z.union([
    zAsyncExportResponse,
    zErrorResponse
]);

export const zReportExportsPreviewExportData = z.object({
    body: z.object({
        templateId: z.optional(z.string()),
        format: z.optional(zReportFormat),
        data: z.optional(z.array(z.unknown())),
        columns: z.optional(z.array(zReportColumnConfig)),
        options: z.optional(zReportOptions),
        filters: z.optional(z.record(z.string(), z.unknown())),
        sort: z.optional(z.array(z.object({
            field: z.string(),
            direction: z.enum(['asc', 'desc'])
        }))),
        parameters: z.optional(z.record(z.string(), z.unknown())),
        selectedIds: z.optional(z.array(z.string())),
        async: z.optional(z.boolean()),
        limit: z.optional(z.int())
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportExportsPreviewExportResponse = z.union([
    z.object({
        data: z.object({
            rows: z.array(z.unknown()),
            totalCount: z.optional(z.int()),
            columns: z.array(z.string())
        }),
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zReportExportsStreamExportData = z.object({
    body: zStreamExportRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportExportsStreamExportResponse = zErrorResponse;

export const zReportJobsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        templateId: z.optional(z.string()),
        scheduledReportId: z.optional(z.string()),
        type: z.optional(zReportJobType),
        status: z.optional(zReportJobStatus),
        format: z.optional(zReportFormat),
        createdAfter: z.optional(z.iso.datetime()),
        createdBefore: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zReportJobsListResponse = z.union([
    zReportJobListResponse,
    zErrorResponse
]);

export const zReportJobsCancelData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.optional(z.never())
});

export const zReportJobsCancelResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zReportJobsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportJobsGetResponse = z.union([
    zReportJobResponse,
    zErrorResponse
]);

export const zReportJobsDownloadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportJobsDownloadResponse = zErrorResponse;

export const zReportJobsRetryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportJobsRetryResponse = z.union([
    zReportJobResponse,
    zErrorResponse
]);

export const zScheduledReportsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        templateId: z.optional(z.string()),
        frequency: z.optional(zScheduleFrequency),
        deliveryMethod: z.optional(zDeliveryMethod),
        isActive: z.optional(z.boolean()),
        search: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsListResponse = z.union([
    zScheduledReportListResponse,
    zErrorResponse
]);

export const zScheduledReportsCreateData = z.object({
    body: zCreateScheduledReportRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zScheduledReportsCreateResponse = z.union([
    zErrorResponse,
    zScheduledReportResponse
]);

export const zScheduledReportsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        scheduleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsDeleteResponse = z.union([
    zSoftDeleteResponse,
    zErrorResponse
]);

export const zScheduledReportsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        scheduleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsGetResponse = z.union([
    zScheduledReportResponse,
    zErrorResponse
]);

export const zScheduledReportsUpdateData = z.object({
    body: zUpdateScheduledReportRequest,
    path: z.object({
        orgId: z.string(),
        scheduleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsUpdateResponse = z.union([
    zScheduledReportResponse,
    zErrorResponse
]);

export const zScheduledReportsGetHistoryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        scheduleId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(20),
        status: z.optional(zReportJobStatus)
    }))
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsGetHistoryResponse = z.union([
    zReportJobListResponse,
    zErrorResponse
]);

export const zScheduledReportsPauseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        scheduleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsPauseResponse = z.union([
    zScheduledReportResponse,
    zErrorResponse
]);

export const zScheduledReportsResumeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        scheduleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsResumeResponse = z.union([
    zScheduledReportResponse,
    zErrorResponse
]);

export const zScheduledReportsRunNowData = z.object({
    body: z.optional(z.object({
        parameters: z.optional(z.record(z.string(), z.unknown()))
    })),
    path: z.object({
        orgId: z.string(),
        scheduleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsRunNowResponse = z.union([
    zReportJobResponse,
    zErrorResponse
]);

export const zReportTemplatesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        format: z.optional(zReportFormat),
        isPublic: z.optional(z.boolean()),
        search: z.optional(z.string()),
        createdBy: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesListResponse = z.union([
    zReportTemplateListResponse,
    zErrorResponse
]);

export const zReportTemplatesCreateData = z.object({
    body: zCreateReportTemplateRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zReportTemplatesCreateResponse = z.union([
    zErrorResponse,
    zReportTemplateResponse
]);

export const zReportTemplatesDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        templateId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesDeleteResponse = z.union([
    zSoftDeleteResponse,
    zErrorResponse
]);

export const zReportTemplatesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        templateId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesGetResponse = z.union([
    zReportTemplateResponse,
    zErrorResponse
]);

export const zReportTemplatesUpdateData = z.object({
    body: zUpdateReportTemplateRequest,
    path: z.object({
        orgId: z.string(),
        templateId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesUpdateResponse = z.union([
    zReportTemplateResponse,
    zErrorResponse
]);

export const zReportTemplatesCloneData = z.object({
    body: z.object({
        name: z.string(),
        description: z.optional(z.string())
    }),
    path: z.object({
        orgId: z.string(),
        templateId: z.string()
    }),
    query: z.optional(z.never())
});

export const zReportTemplatesCloneResponse = z.union([
    zErrorResponse,
    zReportTemplateResponse
]);

export const zReportTemplatesTestData = z.object({
    body: z.object({
        sampleData: z.optional(z.array(z.unknown())),
        sampleRows: z.optional(z.int()),
        parameters: z.optional(z.record(z.string(), z.unknown()))
    }),
    path: z.object({
        orgId: z.string(),
        templateId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesTestResponse = z.union([
    zAsyncExportResponse,
    zErrorResponse
]);

export const zTenantRolesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        isSystemRole: z.optional(z.boolean())
    }))
});

/**
 * The request has succeeded.
 */
export const zTenantRolesListResponse = z.union([
    zRoleListResponse,
    zErrorResponse
]);

export const zTenantRolesCreateData = z.object({
    body: zCreateRoleRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zTenantRolesCreateResponse = z.union([
    zErrorResponse,
    zRoleResponse
]);

export const zTenantRolesDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

export const zTenantRolesDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zTenantRolesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zTenantRolesGetResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zTenantRolesUpdateData = z.object({
    body: zUpdateRoleRequest,
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zTenantRolesUpdateResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zUserPermissionsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zUserPermissionsGetResponse = z.union([
    zUserEffectivePermissionsResponse,
    zErrorResponse
]);

export const zUserTenantRolesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zUserTenantRolesListResponse = z.union([
    zUserRoleAssignmentListResponse,
    zErrorResponse
]);

export const zUserTenantRolesAssignData = z.object({
    body: zAssignRoleRequest,
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.optional(z.never())
});

export const zUserTenantRolesAssignResponse = z.union([
    zErrorResponse,
    zUserRoleAssignmentResponse
]);

export const zUserTenantRolesRemoveData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        userId: z.string(),
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

export const zUserTenantRolesRemoveResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zWebhooksListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        isActive: z.optional(z.boolean())
    }))
});

/**
 * The request has succeeded.
 */
export const zWebhooksListResponse = z.union([
    zWebhookListResponse,
    zErrorResponse
]);

export const zWebhooksCreateData = z.object({
    body: zCreateWebhookRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zWebhooksCreateResponse = z.union([
    zErrorResponse,
    zWebhookCreatedResponse
]);

export const zWebhooksListEventTypesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksListEventTypesResponse = z.union([
    zWebhookEventTypesResponse,
    zErrorResponse
]);

export const zWebhooksDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

export const zWebhooksDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zWebhooksGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksGetResponse = z.union([
    zWebhookResponse,
    zErrorResponse
]);

export const zWebhooksUpdateData = z.object({
    body: zUpdateWebhookRequest,
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksUpdateResponse = z.union([
    zWebhookResponse,
    zErrorResponse
]);

export const zWebhooksListDeliveriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        status: z.optional(zWebhookDeliveryStatus),
        eventType: z.optional(z.string()),
        createdAfter: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zWebhooksListDeliveriesResponse = z.union([
    zWebhookDeliveryListResponse,
    zErrorResponse
]);

export const zWebhooksGetDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string(),
        deliveryId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksGetDeliveryResponse = z.union([
    zWebhookDeliveryResponse,
    zErrorResponse
]);

export const zWebhooksRetryDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string(),
        deliveryId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksRetryDeliveryResponse = z.union([
    zWebhookDeliveryResponse,
    zErrorResponse
]);

export const zWebhooksRotateSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksRotateSecretResponse = z.union([
    zWebhookCreatedResponse,
    zErrorResponse
]);

export const zWebhooksTestData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksTestResponse = z.union([
    z.object({
        data: z.object({
            success: z.boolean(),
            httpStatus: z.optional(z.int()),
            durationMs: z.optional(z.int()),
            error: z.optional(z.string())
        }),
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zNotificationPreferencesRoutesGetPreferencesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationPreferencesRoutesGetPreferencesResponse = z.union([
    zNotificationPreferencesResponse,
    zErrorResponse
]);

export const zNotificationPreferencesRoutesUpdatePreferencesData = z.object({
    body: zUpdatePreferencesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationPreferencesRoutesUpdatePreferencesResponse = z.union([
    zNotificationPreferencesResponse,
    zErrorResponse
]);

export const zGlobalRolesListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        isSystemRole: z.optional(z.boolean())
    }))
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesListResponse = z.union([
    zRoleListResponse,
    zErrorResponse
]);

export const zGlobalRolesCreateData = z.object({
    body: zCreateRoleRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGlobalRolesCreateResponse = z.union([
    zErrorResponse,
    zRoleResponse
]);

export const zGlobalRolesDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

export const zGlobalRolesDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zGlobalRolesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesGetResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zGlobalRolesUpdateData = z.object({
    body: zUpdateRoleRequest,
    path: z.object({
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesUpdateResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zAvailableContextsListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zAvailableContextsListResponse = z.union([
    zUserContextListResponse,
    zErrorResponse
]);

export const zCurrentUserContextGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zCurrentUserContextGetResponse = z.union([
    zActiveContextResponse,
    zErrorResponse
]);

export const zContextSwitchSwitchData = z.object({
    body: zSwitchContextRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zContextSwitchSwitchResponse = z.union([
    zSwitchContextResponse,
    zErrorResponse
]);

export const zAllUserRolesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zAllUserRolesListResponse = z.union([
    zUserRoleAssignmentListResponse,
    zErrorResponse
]);
