// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

/**
 * User's active context (current app/tenant selection)
 */
export const zActiveContext = z.object({
  userId: z.string(),
  activeApplicationId: z.string(),
  activeTenantId: z.optional(z.string()),
  updatedAt: z.iso.datetime(),
});

/**
 * Announcement interaction tracking
 */
export const zAnnouncementInteraction = z.object({
  id: z.string(),
  announcementId: z.string(),
  userId: z.string(),
  viewedAt: z.optional(z.iso.datetime()),
  readAt: z.optional(z.iso.datetime()),
  dismissedAt: z.optional(z.iso.datetime()),
  acknowledgedAt: z.optional(z.iso.datetime()),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

/**
 * Announcement priority level
 */
export const zAnnouncementPriority = z.enum(["info", "warning", "critical"]);

/**
 * Announcement scope
 */
export const zAnnouncementScope = z.enum(["system", "organization"]);

/**
 * User role for targeting
 */
export const zAnnouncementTargetRole = z.enum(["all", "admin", "member"]);

/**
 * Announcement resource model
 */
export const zAnnouncement = z.object({
  id: z.string(),
  orgId: z.optional(z.string()),
  title: z.string(),
  content: z.string(),
  linkUrl: z.optional(z.string()),
  linkText: z.optional(z.string()),
  priority: zAnnouncementPriority,
  scope: zAnnouncementScope,
  targetRoles: z.array(zAnnouncementTargetRole),
  isDismissible: z.boolean(),
  publishAt: z.iso.datetime(),
  expiresAt: z.optional(z.iso.datetime()),
  isActive: z.boolean(),
  createdBy: z.string(),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
  deletedAt: z.optional(z.iso.datetime()),
  viewCount: z.optional(z.int()),
  readCount: z.optional(z.int()),
  acknowledgeCount: z.optional(z.int()),
  dismissCount: z.optional(z.int()),
});

/**
 * Announcement with user interaction data
 */
export const zAnnouncementWithInteraction = z.object({
  id: z.string(),
  orgId: z.optional(z.string()),
  title: z.string(),
  content: z.string(),
  linkUrl: z.optional(z.string()),
  linkText: z.optional(z.string()),
  priority: zAnnouncementPriority,
  scope: zAnnouncementScope,
  targetRoles: z.array(zAnnouncementTargetRole),
  isDismissible: z.boolean(),
  publishAt: z.iso.datetime(),
  expiresAt: z.optional(z.iso.datetime()),
  isActive: z.boolean(),
  createdBy: z.string(),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
  deletedAt: z.optional(z.iso.datetime()),
  viewCount: z.optional(z.int()),
  readCount: z.optional(z.int()),
  acknowledgeCount: z.optional(z.int()),
  dismissCount: z.optional(z.int()),
  interaction: z.optional(zAnnouncementInteraction),
  hasViewed: z.optional(z.boolean()),
  hasRead: z.optional(z.boolean()),
  hasDismissed: z.optional(z.boolean()),
  hasAcknowledged: z.optional(z.boolean()),
});

/**
 * Apply coupon request
 */
export const zApplyCouponRequest = z.object({
  couponCode: z.string().min(1).max(50),
});

/**
 * Request to assign a role to a user
 */
export const zAssignRoleRequest = z.object({
  roleId: z.string(),
});

/**
 * Actor type - who performed the action
 */
export const zAuditActorType = z.enum(["user", "service", "system"]);

/**
 * Actor who performed the action
 */
export const zAuditActor = z.object({
  type: zAuditActorType,
  id: z.string(),
  email: z.optional(z.string()),
  ipAddress: z.optional(z.string()),
  userAgent: z.optional(z.string()),
});

/**
 * Change record for a single field
 */
export const zAuditChange = z.object({
  old: z.unknown(),
  new: z.unknown(),
});

/**
 * Additional metadata for the audit event
 */
export const zAuditMetadata = z.object({
  requestId: z.optional(z.string()),
  sessionId: z.optional(z.string()),
  reason: z.optional(z.string()),
  extra: z.optional(z.record(z.string(), z.unknown())),
});

/**
 * Resource affected by the action
 */
export const zAuditResource = z.object({
  type: z.string(),
  id: z.string(),
  endpoint: z.optional(z.string()),
  method: z.optional(z.string()),
});

/**
 * Audit log entry
 *
 * Immutable record of an action in the system.
 */
export const zAuditLog = z.object({
  eventId: z.string(),
  eventType: z.string(),
  timestamp: z.iso.datetime(),
  tenantId: z.string(),
  actor: zAuditActor,
  resource: zAuditResource,
  changes: z.optional(z.record(z.string(), zAuditChange)),
  resourceBefore: z.optional(z.record(z.string(), z.unknown())),
  resourceAfter: z.optional(z.record(z.string(), z.unknown())),
  metadata: z.optional(zAuditMetadata),
});

/**
 * Batch delete result (soft delete)
 */
export const zBatchDeleteResult = z.object({
  index: z.int(),
  status: z.enum(["success", "error", "skipped"]),
  data: z.optional(
    z.object({
      id: z.string(),
      deletedAt: z.iso.datetime(),
    }),
  ),
  error: z.optional(
    z.object({
      code: z.string(),
      message: z.string(),
    }),
  ),
});

/**
 * Options for batch operations
 */
export const zBatchOptions = z.object({
  atomic: z.optional(z.boolean()),
  returnRecords: z.optional(z.boolean()),
  skipDuplicates: z.optional(z.boolean()),
  validateOnly: z.optional(z.boolean()),
});

/**
 * Summary of batch operation results
 */
export const zBatchSummary = z.object({
  total: z.int(),
  successful: z.int(),
  failed: z.int(),
  skipped: z.int(),
});

/**
 * Cancel subscription request
 */
export const zCancelSubscriptionRequest = z.object({
  immediate: z.optional(z.boolean()),
  reason: z.optional(z.string().max(500)),
});

/**
 * Column alignment
 */
export const zColumnAlignment = z.enum(["left", "center", "right"]);

/**
 * Column data format
 */
export const zColumnFormat = z.enum([
  "text",
  "number",
  "currency",
  "date",
  "datetime",
  "boolean",
  "percentage",
]);

/**
 * Request to confirm an upload completed successfully
 */
export const zConfirmUploadRequest = z.object({
  etag: z.optional(z.string()),
});

/**
 * Coupon discount type
 */
export const zCouponType = z.enum(["percent", "fixed", "trial_extension"]);

/**
 * Discount coupon
 *
 * Represents a promotional discount code.
 */
export const zCoupon = z.object({
  id: z.string(),
  code: z.string().min(1).max(50),
  name: z.optional(z.string().max(200)),
  type: zCouponType,
  percentOff: z.optional(z.int().gte(1).lte(100)),
  amountOffCents: z.optional(z.int().gte(1)),
  trialExtensionDays: z.optional(z.int().gte(1)),
  isActive: z.boolean(),
  startsAt: z.optional(z.iso.datetime()),
  expiresAt: z.optional(z.iso.datetime()),
  maxRedemptions: z.optional(z.int().gte(1)),
  currentRedemptions: z.int().gte(0),
  firstTimeOnly: z.boolean(),
  planIds: z.optional(z.string()),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

/**
 * Request body for creating an announcement
 */
export const zCreateAnnouncementRequest = z.object({
  orgId: z.optional(z.string()),
  title: z.string().min(1).max(200),
  content: z.string().min(1).max(5000),
  linkUrl: z.optional(z.string()),
  linkText: z.optional(z.string()),
  priority: z.optional(zAnnouncementPriority),
  scope: z.optional(zAnnouncementScope),
  targetRoles: z.optional(z.array(zAnnouncementTargetRole)),
  isDismissible: z.optional(z.boolean()),
  publishAt: z.optional(z.iso.datetime()),
  expiresAt: z.optional(z.iso.datetime()),
  isActive: z.optional(z.boolean()),
});

/**
 * Create coupon request
 */
export const zCreateCouponRequest = z.object({
  code: z.string().min(1).max(50),
  name: z.optional(z.string().max(200)),
  type: zCouponType,
  percentOff: z.optional(z.int().gte(1).lte(100)),
  amountOffCents: z.optional(z.int().gte(1)),
  trialExtensionDays: z.optional(z.int().gte(1)),
  isActive: z.optional(z.boolean()),
  startsAt: z.optional(z.iso.datetime()),
  expiresAt: z.optional(z.iso.datetime()),
  maxRedemptions: z.optional(z.int().gte(1)),
  firstTimeOnly: z.optional(z.boolean()),
  planIds: z.optional(z.string()),
});

/**
 * Request body for creating a new comment
 */
export const zCreateExampleCommentRequest = z.object({
  content: z.string(),
  authorId: z.string(),
});

/**
 * Create subscription request
 */
export const zCreateSubscriptionRequest = z.object({
  planId: z.string(),
  couponCode: z.optional(z.string().max(50)),
  paymentMethodId: z.optional(z.string()),
  returnUrl: z.optional(z.string()),
});

/**
 * Request to create a webhook
 */
export const zCreateWebhookRequest = z.object({
  url: z.url(),
  name: z.optional(z.string().max(100)),
  description: z.optional(z.string().max(500)),
  events: z.array(z.string()).min(1),
  isActive: z.optional(z.boolean()),
});

/**
 * Cursor-based pagination for large datasets or real-time data
 */
export const zCursorPagination = z.object({
  limit: z.int(),
  hasNext: z.boolean(),
  nextCursor: z.union([z.string(), z.null()]),
  previousCursor: z.union([z.string(), z.null()]),
});

/**
 * Data source configuration for report templates
 */
export const zDataSourceConfig = z.object({
  type: z.enum(["query", "api", "custom"]),
  source: z.optional(z.string()),
  defaultParams: z.optional(z.record(z.string(), z.unknown())),
});

/**
 * Data source configuration for report templates
 */
export const zDataSourceConfigUpdate = z.object({
  type: z.optional(z.enum(["query", "api", "custom"])),
  source: z.optional(z.string()),
  defaultParams: z.optional(z.record(z.string(), z.unknown())),
});

/**
 * Day of week for weekly schedules
 */
export const zDayOfWeek = z.enum([
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday",
  "saturday",
  "sunday",
]);

/**
 * Report delivery method
 */
export const zDeliveryMethod = z.enum([
  "email",
  "download",
  "webhook",
  "storage",
]);

/**
 * Email delivery configuration
 */
export const zEmailDeliveryConfig = z.object({
  recipients: z.array(z.string()),
  subject: z.optional(z.string()),
  body: z.optional(z.string()),
  cc: z.optional(z.array(z.string())),
  bcc: z.optional(z.array(z.string())),
});

/**
 * Email delivery configuration
 */
export const zEmailDeliveryConfigUpdate = z.object({
  recipients: z.optional(z.array(z.string())),
  subject: z.optional(z.string()),
  body: z.optional(z.string()),
  cc: z.optional(z.array(z.string())),
  bcc: z.optional(z.array(z.string())),
});

/**
 * Detailed error information for a specific field or validation
 */
export const zErrorDetail = z.object({
  field: z.string(),
  code: z.string(),
  message: z.string(),
  metadata: z.optional(z.record(z.string(), z.unknown())),
});

/**
 * Standard error object
 */
export const zError = z.object({
  code: z.string(),
  message: z.string(),
  details: z.optional(z.array(zErrorDetail)),
  requestId: z.string(),
  documentationUrl: z.optional(z.string()),
});

/**
 * Standard error response envelope
 */
export const zErrorResponse = z.object({
  error: zError,
});

/**
 * ExampleComment resource model (nested under ExamplePost)
 *
 * Demonstrates:
 * - Nested sub-resource pattern (belongs to a post)
 * - Multi-tenant scoping (orgId)
 * - Soft delete with restore capability
 */
export const zExampleComment = z.object({
  id: z.string(),
  orgId: z.string(),
  postId: z.string(),
  content: z.string(),
  authorId: z.string(),
  isDeleted: z.boolean(),
  deletedAt: z.optional(z.iso.datetime()),
  deletedBy: z.optional(z.string()),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

/**
 * Post status enum
 */
export const zExamplePostStatus = z.enum(["draft", "published", "archived"]);

/**
 * Request body for creating a new post
 */
export const zCreateExamplePostRequest = z.object({
  title: z.string(),
  content: z.string(),
  authorId: z.string(),
  status: z.optional(zExamplePostStatus),
});

/**
 * ExamplePost resource model
 *
 * Demonstrates a typical content resource with:
 * - Multi-tenant scoping (orgId)
 * - Status workflow (draft → published → archived)
 * - Soft delete with restore capability
 */
export const zExamplePost = z.object({
  id: z.string(),
  orgId: z.string(),
  title: z.string(),
  content: z.string(),
  authorId: z.string(),
  status: zExamplePostStatus,
  publishedAt: z.optional(z.iso.datetime()),
  isDeleted: z.boolean(),
  deletedAt: z.optional(z.iso.datetime()),
  deletedBy: z.optional(z.string()),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

/**
 * File access level
 */
export const zFileAccess = z.enum(["private", "public"]);

/**
 * Request to initiate a presigned URL upload
 */
export const zInitiateUploadRequest = z.object({
  filename: z.string().min(1).max(255),
  contentType: z.string(),
  size: z.coerce.bigint().gte(BigInt(1)),
  metadata: z.optional(z.record(z.string(), z.string())),
});

/**
 * Job error details
 */
export const zJobError = z.object({
  code: z.string(),
  message: z.string(),
  retryable: z.optional(z.boolean()),
});

/**
 * Job metadata for type-specific references
 */
export const zJobMetadata = z.object({
  templateId: z.optional(z.string()),
  scheduledReportId: z.optional(z.string()),
  format: z.optional(z.string()),
  parentJobId: z.optional(z.string()),
  retryCount: z.optional(z.int()),
});

/**
 * Job status
 */
export const zJobStatus = z.enum([
  "pending",
  "processing",
  "completed",
  "failed",
  "cancelled",
]);

/**
 * Async job resource
 *
 * Represents a long-running operation that can be polled for status.
 * Unified job system with pg-boss queue integration.
 */
export const zJob = z.object({
  jobId: z.string(),
  tenantId: z.string(),
  type: z.string(),
  status: zJobStatus,
  progress: z.optional(z.int().gte(0).lte(100)),
  message: z.optional(z.string()),
  totalItems: z.optional(z.int()),
  processedItems: z.optional(z.int()),
  input: z.optional(z.record(z.string(), z.unknown())),
  output: z.optional(z.record(z.string(), z.unknown())),
  metadata: z.optional(zJobMetadata),
  error: z.optional(zJobError),
  createdBy: z.string(),
  createdAt: z.iso.datetime(),
  startedAt: z.optional(z.iso.datetime()),
  completedAt: z.optional(z.iso.datetime()),
  estimatedCompletion: z.optional(z.iso.datetime()),
});

/**
 * Version lifecycle status
 */
export const zMigrationStatus = z.enum(["current", "deprecated", "sunset"]);

/**
 * Migration status for an API version
 */
export const zMigrationStatusResponse = z.object({
  version: z.string(),
  status: zMigrationStatus,
  sunsetDate: z.optional(z.iso.datetime()),
  daysUntilSunset: z.optional(z.int()),
  replacementVersion: z.optional(z.string()),
  migrationGuideUrl: z.optional(z.string()),
  breakingChanges: z.optional(z.array(z.string())),
  migrationChecklist: z.optional(z.array(z.string())),
});

/**
 * Notification category enum
 */
export const zNotificationCategory = z.enum([
  "transactional",
  "marketing",
  "security",
  "system",
]);

/**
 * Notification channel enum
 */
export const zNotificationChannel = z.enum([
  "email",
  "sms",
  "whatsapp",
  "telegram",
  "push",
  "none",
]);

/**
 * Notification preferences model
 */
export const zNotificationPreferences = z.object({
  userId: z.string(),
  emailEnabled: z.boolean(),
  smsEnabled: z.boolean(),
  whatsappEnabled: z.boolean(),
  telegramEnabled: z.boolean(),
  pushEnabled: z.boolean(),
  marketingEnabled: z.boolean(),
  transactionalEnabled: z.boolean(),
  securityEnabled: z.boolean(),
  systemEnabled: z.boolean(),
  preferredEmail: z.optional(z.string()),
  preferredPhone: z.optional(z.string()),
  preferredTelegramId: z.optional(z.string()),
  quietHoursEnabled: z.boolean(),
  quietHoursStart: z.optional(z.string()),
  quietHoursEnd: z.optional(z.string()),
  quietHoursTimezone: z.optional(z.string()),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

/**
 * Notification priority enum
 */
export const zNotificationPriority = z.enum([
  "urgent",
  "high",
  "normal",
  "low",
]);

/**
 * Notification recipient information
 */
export const zNotificationRecipient = z.object({
  email: z.optional(z.string()),
  phone: z.optional(z.string()),
  telegramId: z.optional(z.string()),
});

/**
 * Notification status enum
 */
export const zNotificationStatus = z.enum([
  "pending",
  "queued",
  "processing",
  "sent",
  "delivered",
  "failed",
  "bounced",
]);

/**
 * Notification resource model
 */
export const zNotification = z.object({
  id: z.string(),
  userId: z.optional(z.string()),
  channel: zNotificationChannel,
  category: zNotificationCategory,
  priority: zNotificationPriority,
  status: zNotificationStatus,
  recipientEmail: z.optional(z.string()),
  recipientPhone: z.optional(z.string()),
  recipientTelegramId: z.optional(z.string()),
  templateId: z.optional(z.string()),
  subject: z.optional(z.string()),
  body: z.optional(z.string()),
  bodyHtml: z.optional(z.string()),
  templateData: z.optional(z.record(z.string(), z.unknown())),
  campaignId: z.optional(z.string()),
  provider: z.optional(z.string()),
  providerMessageId: z.optional(z.string()),
  sentAt: z.optional(z.iso.datetime()),
  deliveredAt: z.optional(z.iso.datetime()),
  failedAt: z.optional(z.iso.datetime()),
  readAt: z.optional(z.iso.datetime()),
  deletedAt: z.optional(z.iso.datetime()),
  retryCount: z.int(),
  maxRetries: z.int(),
  nextRetryAt: z.optional(z.iso.datetime()),
  statusMessage: z.optional(z.string()),
  metadata: z.optional(z.record(z.string(), z.unknown())),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

/**
 * Pagination links for navigating through paginated results
 */
export const zPaginationLinks = z.object({
  first: z.union([z.string(), z.null()]),
  previous: z.union([z.string(), z.null()]),
  next: z.union([z.string(), z.null()]),
  last: z.union([z.string(), z.null()]),
});

/**
 * Page-based pagination metadata for collection responses
 */
export const zPagination = z.object({
  page: z.int(),
  pageSize: z.int(),
  totalPages: z.int(),
  totalCount: z.int(),
  hasNext: z.boolean(),
  hasPrevious: z.boolean(),
  links: z.optional(zPaginationLinks),
  requestedPageSize: z.optional(z.int()),
});

/**
 * Permission actions
 */
export const zPermissionAction = z.enum([
  "read",
  "create",
  "update",
  "delete",
  "manage",
  "*",
]);

/**
 * Permission condition - when the permission applies
 *
 * Conditions enable dynamic, context-aware access control.
 */
export const zPermissionCondition = z.enum(["", "owner", "shared"]);

/**
 * Permission effect - whether to allow or deny access
 *
 * When a user has multiple roles, permissions are combined:
 * - If ANY role denies an action, it is denied (deny wins)
 * - If no role denies and ANY role allows, it is allowed
 * - If no rules match, access is denied (default deny)
 */
export const zPermissionEffect = z.enum(["allow", "deny"]);

/**
 * Permission definition
 *
 * Permissions define what actions can be performed on resources.
 * They support allow/deny effects and optional conditions.
 */
export const zPermission = z.object({
  resource: z.string(),
  action: z.union([zPermissionAction, z.string()]),
  effect: zPermissionEffect,
  condition: z.optional(zPermissionCondition),
});

/**
 * Permission input for creating/updating roles
 */
export const zPermissionInput = z.object({
  resource: z.string(),
  action: z.string(),
  effect: z.optional(zPermissionEffect),
  condition: z.optional(zPermissionCondition),
});

/**
 * Request to create a custom role
 */
export const zCreateRoleRequest = z.object({
  name: z.string().min(1).max(100),
  description: z.optional(z.string().max(500)),
  permissions: z.array(zPermissionInput).min(1),
});

/**
 * Billing period for subscription plans
 */
export const zPlanBillingPeriod = z.enum(["monthly", "yearly"]);

/**
 * Plan feature configuration
 */
export const zPlanFeatures = z.object({
  maxUsers: z.optional(z.int()),
  maxLocations: z.optional(z.int()),
  maxStorageGb: z.optional(z.int()),
  advancedReporting: z.optional(z.boolean()),
  apiAccess: z.optional(z.boolean()),
  customBranding: z.optional(z.boolean()),
  prioritySupport: z.optional(z.boolean()),
});

/**
 * Plan visibility level
 */
export const zPlanVisibility = z.enum(["public", "private", "archived"]);

/**
 * Create subscription plan request
 */
export const zCreatePlanRequest = z.object({
  applicationId: z.string(),
  name: z.string().min(1).max(100),
  slug: z.string().min(1).max(50),
  description: z.optional(z.string().max(500)),
  priceCents: z.int().gte(0),
  currency: z.optional(z.string()),
  billingPeriod: zPlanBillingPeriod,
  trialDays: z.optional(z.int().gte(0)),
  features: z.optional(zPlanFeatures),
  metadata: z.optional(z.record(z.string(), z.unknown())),
  sortOrder: z.optional(z.int()),
  visibility: z.optional(zPlanVisibility),
  isActive: z.optional(z.boolean()),
  isPopular: z.optional(z.boolean()),
});

/**
 * Request body for previewing an email template
 */
export const zPreviewEmailRequest = z.object({
  templateId: z.string(),
  templateData: z.optional(z.record(z.string(), z.unknown())),
});

/**
 * Column configuration for reports
 */
export const zReportColumnConfig = z.object({
  id: z.string(),
  header: z.string(),
  accessorKey: z.optional(z.string()),
  accessorFn: z.optional(z.string()),
  width: z.optional(z.int()),
  align: z.optional(zColumnAlignment),
  format: z.optional(zColumnFormat),
  formatPattern: z.optional(z.string()),
  hidden: z.optional(z.boolean()),
});

/**
 * Report output format
 */
export const zReportFormat = z.enum([
  "csv",
  "excel",
  "pdf",
  "thermal",
  "dotmatrix",
]);

/**
 * Page orientation for PDF reports
 */
export const zReportOrientation = z.enum(["portrait", "landscape"]);

/**
 * Page size for PDF reports
 */
export const zReportPageSize = z.enum(["a4", "letter", "legal", "a3"]);

/**
 * Report format-specific options
 */
export const zReportOptions = z.object({
  delimiter: z.optional(z.string()),
  includeHeaders: z.optional(z.boolean()),
  sheetName: z.optional(z.string()),
  autoFilter: z.optional(z.boolean()),
  freezeHeader: z.optional(z.boolean()),
  orientation: z.optional(zReportOrientation),
  pageSize: z.optional(zReportPageSize),
  marginTop: z.optional(z.int()),
  marginRight: z.optional(z.int()),
  marginBottom: z.optional(z.int()),
  marginLeft: z.optional(z.int()),
  title: z.optional(z.string()),
  subtitle: z.optional(z.string()),
  watermark: z.optional(z.string()),
  includePageNumbers: z.optional(z.boolean()),
  includeTimestamp: z.optional(z.boolean()),
  printerWidth: z.optional(z.int()),
  encoding: z.optional(z.string()),
  autoCut: z.optional(z.boolean()),
});

/**
 * Request body for creating a new report template
 */
export const zCreateReportTemplateRequest = z.object({
  name: z.string(),
  description: z.optional(z.string()),
  format: zReportFormat,
  templateContent: z.string(),
  options: z.optional(zReportOptions),
  dataSource: z.optional(zDataSourceConfig),
  columns: z.array(zReportColumnConfig),
  isPublic: z.optional(z.boolean()),
});

/**
 * Request body for triggering an export
 */
export const zExportRequest = z.object({
  templateId: z.optional(z.string()),
  format: z.optional(zReportFormat),
  data: z.optional(z.array(z.unknown())),
  columns: z.optional(z.array(zReportColumnConfig)),
  options: z.optional(zReportOptions),
  filters: z.optional(z.record(z.string(), z.unknown())),
  sort: z.optional(
    z.array(
      z.object({
        field: z.string(),
        direction: z.enum(["asc", "desc"]),
      }),
    ),
  ),
  parameters: z.optional(z.record(z.string(), z.unknown())),
  selectedIds: z.optional(z.array(z.string())),
  async: z.optional(z.boolean()),
});

/**
 * Report Template resource model
 *
 * Defines reusable report configurations with:
 * - Multiple output formats (CSV, Excel, PDF, Thermal, Dot-Matrix)
 * - Eta template engine for custom layouts
 * - Column definitions with formatting
 * - Data source configuration
 * - Multi-tenant scoping
 */
export const zReportTemplate = z.object({
  id: z.string(),
  orgId: z.string(),
  name: z.string(),
  description: z.optional(z.string()),
  format: zReportFormat,
  templateEngine: z.string(),
  templateContent: z.string(),
  options: z.optional(zReportOptions),
  dataSource: z.optional(zDataSourceConfig),
  columns: z.array(zReportColumnConfig),
  isPublic: z.boolean(),
  createdBy: z.string(),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
  deletedAt: z.optional(z.iso.datetime()),
});

/**
 * Response metadata included in all API responses
 */
export const zResponseMeta = z.object({
  requestId: z.string(),
  timestamp: z.iso.datetime(),
  apiVersion: z.optional(z.string()),
  tenantId: z.optional(z.string()),
  tenantName: z.optional(z.string()),
  durationMs: z.optional(z.int()),
});

/**
 * Acknowledge announcement response
 */
export const zAcknowledgeAnnouncementResponse = z.object({
  data: z.object({
    announcementId: z.string(),
    acknowledgedAt: z.iso.datetime(),
  }),
  meta: zResponseMeta,
});

/**
 * Active context response
 */
export const zActiveContextResponse = z.object({
  data: zActiveContext,
  meta: zResponseMeta,
});

/**
 * Announcement collection response
 */
export const zAnnouncementListResponse = z.object({
  data: z.array(zAnnouncementWithInteraction),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Single announcement response
 */
export const zAnnouncementResponse = z.object({
  data: zAnnouncement,
  meta: zResponseMeta,
});

/**
 * Announcement statistics response
 */
export const zAnnouncementStatsResponse = z.object({
  data: z.object({
    viewCount: z.int(),
    readCount: z.int(),
    acknowledgeCount: z.int(),
    dismissCount: z.int(),
    viewRate: z.number(),
    readRate: z.number(),
    acknowledgeRate: z.number(),
  }),
  meta: zResponseMeta,
});

/**
 * Announcement with interaction response
 */
export const zAnnouncementWithInteractionResponse = z.object({
  data: zAnnouncementWithInteraction,
  meta: zResponseMeta,
});

/**
 * Async export response (returns job info)
 */
export const zAsyncExportResponse = z.object({
  jobId: z.string(),
  status: z.enum(["pending", "processing", "completed", "failed", "cancelled"]),
  statusUrl: z.string(),
  estimatedCompletion: z.optional(z.iso.datetime()),
  meta: zResponseMeta,
});

/**
 * Response for async operations that return 202 Accepted
 */
export const zAsyncJobResponse = z.object({
  jobId: z.string(),
  status: z.enum(["pending", "processing", "completed", "failed"]),
  statusUrl: z.string(),
  estimatedCompletion: z.optional(z.iso.datetime()),
  meta: zResponseMeta,
});

/**
 * Audit log list response
 */
export const zAuditLogListResponse = z.object({
  data: z.array(zAuditLog),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Single audit log response
 */
export const zAuditLogResponse = z.object({
  data: zAuditLog,
  meta: zResponseMeta,
});

/**
 * Batch delete response envelope
 */
export const zBatchDeleteResponse = z.object({
  results: z.array(zBatchDeleteResult),
  summary: zBatchSummary,
  meta: zResponseMeta,
});

/**
 * Coupon list response
 */
export const zCouponListResponse = z.object({
  data: z.array(zCoupon),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Coupon response
 */
export const zCouponResponse = z.object({
  data: zCoupon,
  meta: zResponseMeta,
});

/**
 * Dismiss announcement response
 */
export const zDismissAnnouncementResponse = z.object({
  data: z.object({
    announcementId: z.string(),
    dismissedAt: z.iso.datetime(),
  }),
  meta: zResponseMeta,
});

/**
 * Comment collection response
 */
export const zExampleCommentListResponse = z.object({
  data: z.array(zExampleComment),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Single comment response
 */
export const zExampleCommentResponse = z.object({
  data: zExampleComment,
  meta: zResponseMeta,
});

/**
 * Post collection response (cursor-based)
 *
 * Used for streaming/real-time scenarios or large datasets
 */
export const zExamplePostCursorListResponse = z.object({
  data: z.array(zExamplePost),
  pagination: zCursorPagination,
  meta: zResponseMeta,
});

/**
 * Post collection response (page-based)
 */
export const zExamplePostListResponse = z.object({
  data: z.array(zExamplePost),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Single post response
 */
export const zExamplePostResponse = z.object({
  data: zExamplePost,
  meta: zResponseMeta,
});

/**
 * File deletion response
 */
export const zFileDeleteResponse = z.object({
  data: z.object({
    id: z.string(),
    deletedAt: z.iso.datetime(),
    deletedBy: z.string(),
  }),
  meta: zResponseMeta,
});

/**
 * Response with presigned URL for direct upload to storage
 */
export const zInitiateUploadResponse = z.object({
  data: z.object({
    uploadId: z.string(),
    presignedUrl: z.string(),
    method: z.enum(["PUT"]),
    headers: z.record(z.string(), z.string()),
    expiresAt: z.iso.datetime(),
    maxSize: z.coerce.bigint(),
  }),
  meta: zResponseMeta,
});

/**
 * Job list response
 */
export const zJobListResponse = z.object({
  data: z.array(zJob),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Job status response
 */
export const zJobResponse = z.object({
  data: zJob,
  meta: zResponseMeta,
});

/**
 * Mark all as read response
 */
export const zMarkAllReadResponse = z.object({
  data: z.object({
    markedCount: z.int(),
  }),
  meta: zResponseMeta,
});

/**
 * Mark as read response
 */
export const zMarkReadResponse = z.object({
  data: z.object({
    announcementId: z.string(),
    readAt: z.iso.datetime(),
  }),
  meta: zResponseMeta,
});

/**
 * Mark as viewed response
 */
export const zMarkViewedResponse = z.object({
  data: z.object({
    announcementId: z.string(),
    viewedAt: z.iso.datetime(),
  }),
  meta: zResponseMeta,
});

/**
 * Notification collection response
 */
export const zNotificationListResponse = z.object({
  data: z.array(zNotification),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Notification preferences response
 */
export const zNotificationPreferencesResponse = z.object({
  data: zNotificationPreferences,
  meta: zResponseMeta,
});

/**
 * Single notification response
 */
export const zNotificationResponse = z.object({
  data: zNotification,
  meta: zResponseMeta,
});

/**
 * Email preview response
 */
export const zPreviewEmailResponse = z.object({
  data: z.object({
    html: z.string(),
    text: z.string(),
    subject: z.string(),
  }),
  meta: zResponseMeta,
});

/**
 * Report template collection response (page-based)
 */
export const zReportTemplateListResponse = z.object({
  data: z.array(zReportTemplate),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Single report template response
 */
export const zReportTemplateResponse = z.object({
  data: zReportTemplate,
  meta: zResponseMeta,
});

/**
 * Role resource model
 *
 * Roles can be:
 * - **Global roles**: App-scoped (tenantId is null), apply across all tenants
 * - **Tenant roles**: Scoped to a specific organization
 *
 * Users can have multiple roles, and permissions are combined with
 * deny-override semantics.
 */
export const zRole = z.object({
  id: z.string(),
  applicationId: z.string(),
  tenantId: z.optional(z.string()),
  name: z.string(),
  description: z.optional(z.string()),
  permissions: z.array(zPermission),
  isSystemRole: z.boolean(),
  isGlobalRole: z.boolean(),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
  createdBy: z.optional(z.string()),
});

/**
 * Role list response
 */
export const zRoleListResponse = z.object({
  data: z.array(zRole),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Single role response
 */
export const zRoleResponse = z.object({
  data: zRole,
  meta: zResponseMeta,
});

/**
 * Schedule frequency
 */
export const zScheduleFrequency = z.enum([
  "once",
  "daily",
  "weekly",
  "monthly",
  "custom",
]);

/**
 * Request body for sending a notification
 */
export const zSendNotificationRequest = z.object({
  channel: zNotificationChannel,
  category: zNotificationCategory,
  priority: z.optional(zNotificationPriority),
  recipient: zNotificationRecipient,
  templateId: z.optional(z.string()),
  templateData: z.optional(z.record(z.string(), z.unknown())),
  subject: z.optional(z.string()),
  body: z.optional(z.string()),
  bodyHtml: z.optional(z.string()),
  metadata: z.optional(z.record(z.string(), z.unknown())),
});

/**
 * Send notification success response
 */
export const zSendNotificationResponse = z.object({
  data: z.object({
    messageId: z.string(),
    provider: z.string(),
  }),
  meta: zResponseMeta,
});

/**
 * Response for soft delete operations
 *
 * Includes resource ID, deletion metadata, and restore information
 */
export const zSoftDeleteResponse = z.object({
  data: z.object({
    id: z.string(),
    deletedAt: z.iso.datetime(),
    deletedBy: z.string(),
    deletionReason: z.optional(z.string()),
    canRestore: z.boolean(),
    restoreUntil: z.optional(z.iso.datetime()),
  }),
  meta: zResponseMeta,
});

/**
 * Storage delivery configuration
 */
export const zStorageDeliveryConfig = z.object({
  pathTemplate: z.string(),
  provider: z.optional(z.string()),
  bucket: z.optional(z.string()),
});

/**
 * Storage delivery configuration
 */
export const zStorageDeliveryConfigUpdate = z.object({
  pathTemplate: z.optional(z.string()),
  provider: z.optional(z.string()),
  bucket: z.optional(z.string()),
});

/**
 * Request body for streaming export
 */
export const zStreamExportRequest = z.object({
  templateId: z.optional(z.string()),
  format: z.enum(["csv", "excel"]),
  filters: z.optional(z.record(z.string(), z.unknown())),
  sort: z.optional(
    z.array(
      z.object({
        field: z.string(),
        direction: z.enum(["asc", "desc"]),
      }),
    ),
  ),
  batchSize: z.optional(z.int()),
});

/**
 * Subscription plan
 *
 * Represents a pricing tier with features and limits.
 */
export const zSubscriptionPlan = z.object({
  id: z.string(),
  applicationId: z.string(),
  name: z.string().min(1).max(100),
  slug: z.string().min(1).max(50),
  description: z.optional(z.string().max(500)),
  priceCents: z.int().gte(0),
  currency: z.string(),
  billingPeriod: zPlanBillingPeriod,
  trialDays: z.optional(z.int().gte(0)),
  features: z.optional(zPlanFeatures),
  metadata: z.optional(z.union([z.record(z.string(), z.unknown()), z.null()])),
  sortOrder: z.optional(z.int()),
  visibility: zPlanVisibility,
  isActive: z.boolean(),
  isPopular: z.optional(z.boolean()),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

/**
 * Subscription plan list response
 */
export const zPlanListResponse = z.object({
  data: z.array(zSubscriptionPlan),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Subscription plan response
 */
export const zPlanResponse = z.object({
  data: zSubscriptionPlan,
  meta: zResponseMeta,
});

/**
 * Subscription status
 */
export const zSubscriptionStatus = z.enum([
  "trialing",
  "active",
  "past_due",
  "canceled",
  "paused",
  "expired",
]);

/**
 * Organization subscription
 *
 * Represents an active subscription for an organization.
 */
export const zSubscription = z.object({
  id: z.string(),
  organizationId: z.string(),
  applicationId: z.string(),
  planId: z.string(),
  status: zSubscriptionStatus,
  trialStartsAt: z.optional(z.iso.datetime()),
  trialEndsAt: z.optional(z.iso.datetime()),
  currentPeriodStart: z.iso.datetime(),
  currentPeriodEnd: z.iso.datetime(),
  couponId: z.optional(z.string()),
  discountPercent: z.optional(z.int().gte(0).lte(100)),
  discountAmountCents: z.optional(z.int().gte(0)),
  cancelAtPeriodEnd: z.boolean(),
  canceledAt: z.optional(z.iso.datetime()),
  providerSubscriptionId: z.optional(z.string()),
  providerCustomerId: z.optional(z.string()),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
  plan: z.optional(zSubscriptionPlan),
});

/**
 * Subscription creation response (with payment link)
 */
export const zCreateSubscriptionResponse = z.object({
  data: zSubscription,
  linkingUrl: z.optional(z.string()),
  meta: zResponseMeta,
});

/**
 * Subscription response
 */
export const zSubscriptionResponse = z.object({
  data: zSubscription,
  meta: zResponseMeta,
});

/**
 * Request to switch active context (application and/or tenant)
 */
export const zSwitchContextRequest = z.object({
  applicationId: z.optional(z.string()),
  tenantId: z.optional(z.string()),
});

/**
 * Context switch response
 */
export const zSwitchContextResponse = z.object({
  data: z.object({
    applicationId: z.string(),
    tenantId: z.optional(z.string()),
    tenantName: z.optional(z.string()),
    roles: z.array(z.string()),
    permissions: z.array(zPermission),
  }),
  meta: zResponseMeta,
});

/**
 * Unread announcement count response
 */
export const zUnreadAnnouncementsResponse = z.object({
  data: z.object({
    unreadCount: z.int(),
    criticalCount: z.int(),
  }),
  meta: zResponseMeta,
});

/**
 * Unread count response
 */
export const zUnreadCountResponse = z.object({
  data: z.object({
    unreadCount: z.int(),
  }),
  meta: zResponseMeta,
});

/**
 * Request body for updating an announcement
 */
export const zUpdateAnnouncementRequest = z.object({
  title: z.optional(z.string().min(1).max(200)),
  content: z.optional(z.string().min(1).max(5000)),
  linkUrl: z.optional(z.string()),
  linkText: z.optional(z.string()),
  priority: z.optional(zAnnouncementPriority),
  targetRoles: z.optional(z.array(zAnnouncementTargetRole)),
  isDismissible: z.optional(z.boolean()),
  publishAt: z.optional(z.iso.datetime()),
  expiresAt: z.optional(z.iso.datetime()),
  isActive: z.optional(z.boolean()),
});

/**
 * Update coupon request
 */
export const zUpdateCouponRequest = z.object({
  name: z.optional(z.string().max(200)),
  percentOff: z.optional(z.int().gte(1).lte(100)),
  amountOffCents: z.optional(z.int().gte(1)),
  trialExtensionDays: z.optional(z.int().gte(1)),
  isActive: z.optional(z.boolean()),
  startsAt: z.optional(z.iso.datetime()),
  expiresAt: z.optional(z.iso.datetime()),
  maxRedemptions: z.optional(z.int().gte(1)),
  firstTimeOnly: z.optional(z.boolean()),
  planIds: z.optional(z.string()),
});

/**
 * Request body for updating a comment
 */
export const zUpdateExampleCommentRequest = z.object({
  content: z.optional(z.string()),
});

/**
 * Request body for updating a post
 */
export const zUpdateExamplePostRequest = z.object({
  title: z.optional(z.string()),
  content: z.optional(z.string()),
  status: z.optional(zExamplePostStatus),
});

/**
 * Request to update file properties
 */
export const zUpdateFileRequest = z.object({
  access: z.optional(zFileAccess),
});

/**
 * Update subscription plan request
 */
export const zUpdatePlanRequest = z.object({
  name: z.optional(z.string().min(1).max(100)),
  slug: z.optional(z.string().min(1).max(50)),
  description: z.optional(z.string().max(500)),
  priceCents: z.optional(z.int().gte(0)),
  currency: z.optional(z.string()),
  billingPeriod: z.optional(zPlanBillingPeriod),
  trialDays: z.optional(z.int().gte(0)),
  features: z.optional(zPlanFeatures),
  metadata: z.optional(z.record(z.string(), z.unknown())),
  sortOrder: z.optional(z.int()),
  visibility: z.optional(zPlanVisibility),
  isActive: z.optional(z.boolean()),
  isPopular: z.optional(z.boolean()),
});

/**
 * Request body for updating notification preferences
 */
export const zUpdatePreferencesRequest = z.object({
  emailEnabled: z.optional(z.boolean()),
  smsEnabled: z.optional(z.boolean()),
  whatsappEnabled: z.optional(z.boolean()),
  telegramEnabled: z.optional(z.boolean()),
  pushEnabled: z.optional(z.boolean()),
  marketingEnabled: z.optional(z.boolean()),
  transactionalEnabled: z.optional(z.boolean()),
  securityEnabled: z.optional(z.boolean()),
  systemEnabled: z.optional(z.boolean()),
  preferredEmail: z.optional(z.string()),
  preferredPhone: z.optional(z.string()),
  preferredTelegramId: z.optional(z.string()),
  quietHoursEnabled: z.optional(z.boolean()),
  quietHoursStart: z.optional(z.string()),
  quietHoursEnd: z.optional(z.string()),
  quietHoursTimezone: z.optional(z.string()),
});

/**
 * Request body for updating a report template
 */
export const zUpdateReportTemplateRequest = z.object({
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  format: z.optional(zReportFormat),
  templateContent: z.optional(z.string()),
  options: z.optional(zReportOptions),
  dataSource: z.optional(zDataSourceConfigUpdate),
  columns: z.optional(z.array(zReportColumnConfig)),
  isPublic: z.optional(z.boolean()),
});

/**
 * Request to update a role
 */
export const zUpdateRoleRequest = z.object({
  name: z.optional(z.string().min(1).max(100)),
  description: z.optional(z.string().max(500)),
  permissions: z.optional(z.array(zPermissionInput)),
});

/**
 * Update subscription request
 */
export const zUpdateSubscriptionRequest = z.object({
  planId: z.optional(z.string()),
  cancelAtPeriodEnd: z.optional(z.boolean()),
});

/**
 * Request to update a webhook
 */
export const zUpdateWebhookRequest = z.object({
  url: z.optional(z.url()),
  name: z.optional(z.string().max(100)),
  description: z.optional(z.string().max(500)),
  events: z.optional(z.array(z.string())),
  isActive: z.optional(z.boolean()),
});

/**
 * User's context across applications and tenants
 */
export const zUserContext = z.object({
  applicationId: z.string(),
  applicationName: z.string(),
  tenantId: z.string(),
  tenantName: z.string(),
  roles: z.array(z.string()),
});

/**
 * User available contexts response (all apps/tenants user belongs to)
 */
export const zUserContextListResponse = z.object({
  data: z.array(zUserContext),
  meta: zResponseMeta,
});

/**
 * User's effective permissions
 *
 * Represents the combined permissions from all roles assigned to a user
 * within a specific application and tenant context.
 */
export const zUserEffectivePermissions = z.object({
  userId: z.string(),
  applicationId: z.string(),
  tenantId: z.optional(z.string()),
  globalRoles: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      permissions: z.array(zPermission),
    }),
  ),
  tenantRoles: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      permissions: z.array(zPermission),
    }),
  ),
  effectivePermissions: z.array(zPermission),
  allowedActions: z.array(z.string()),
});

/**
 * User effective permissions response
 */
export const zUserEffectivePermissionsResponse = z.object({
  data: zUserEffectivePermissions,
  meta: zResponseMeta,
});

/**
 * User's role assignment
 *
 * Represents a single role assigned to a user within a specific
 * application and optional tenant context.
 */
export const zUserRoleAssignment = z.object({
  id: z.string(),
  userId: z.string(),
  applicationId: z.string(),
  tenantId: z.optional(z.string()),
  roleId: z.string(),
  roleName: z.string(),
  isGlobalRole: z.boolean(),
  assignedAt: z.iso.datetime(),
  assignedBy: z.optional(z.string()),
});

/**
 * User role assignments list response
 */
export const zUserRoleAssignmentListResponse = z.object({
  data: z.array(zUserRoleAssignment),
  meta: zResponseMeta,
});

/**
 * User role assignment response
 */
export const zUserRoleAssignmentResponse = z.object({
  data: zUserRoleAssignment,
  meta: zResponseMeta,
});

/**
 * Validate coupon request
 */
export const zValidateCouponRequest = z.object({
  code: z.string().min(1).max(50),
  planId: z.string(),
});

/**
 * Coupon validation response
 */
export const zValidateCouponResponse = z.object({
  valid: z.boolean(),
  coupon: z.optional(zCoupon),
  discountAmount: z.optional(z.int()),
  message: z.optional(z.string()),
});

/**
 * Virus scan status for uploaded files
 */
export const zVirusScanStatus = z.enum([
  "pending",
  "scanning",
  "clean",
  "infected",
  "failed",
]);

/**
 * File resource model
 *
 * Represents an uploaded file with metadata, security status, and access info.
 */
export const zFile = z.object({
  id: z.string(),
  filename: z.string(),
  size: z.coerce.bigint(),
  mimeType: z.string(),
  storagePath: z.string(),
  url: z.optional(z.string()),
  metadata: z.optional(z.record(z.string(), z.string())),
  uploadedBy: z.string(),
  uploadedAt: z.iso.datetime(),
  virusScanStatus: zVirusScanStatus,
  virusScanCompletedAt: z.optional(z.iso.datetime()),
  access: zFileAccess,
  isDeleted: z.boolean(),
  deletedAt: z.optional(z.iso.datetime()),
  deletedBy: z.optional(z.string()),
});

/**
 * File list response with pagination
 */
export const zFileListResponse = z.object({
  data: z.array(zFile),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Single file response
 */
export const zFileResponse = z.object({
  data: zFile,
  meta: zResponseMeta,
});

/**
 * Webhook configuration
 *
 * Defines an endpoint to receive event notifications.
 */
export const zWebhook = z.object({
  id: z.string(),
  tenantId: z.string(),
  url: z.string(),
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  events: z.array(z.string()),
  secret: z.string(),
  isActive: z.boolean(),
  consecutiveFailures: z.int(),
  lastTriggeredAt: z.optional(z.iso.datetime()),
  lastSuccessAt: z.optional(z.iso.datetime()),
  lastFailureAt: z.optional(z.iso.datetime()),
  createdBy: z.string(),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

/**
 * Webhook received acknowledgment
 */
export const zWebhookAcknowledgment = z.object({
  received: z.boolean(),
  eventId: z.optional(z.string()),
  note: z.optional(z.string()),
});

/**
 * Webhook delivery configuration
 */
export const zWebhookDeliveryConfig = z.object({
  url: z.string(),
  headers: z.optional(z.record(z.string(), z.string())),
  attachmentMode: z.optional(z.enum(["attachment", "base64"])),
});

/**
 * Combined delivery configuration
 */
export const zDeliveryConfig = z.object({
  email: z.optional(zEmailDeliveryConfig),
  webhook: z.optional(zWebhookDeliveryConfig),
  storage: z.optional(zStorageDeliveryConfig),
});

/**
 * Request body for creating a scheduled report
 */
export const zCreateScheduledReportRequest = z.object({
  templateId: z.string(),
  name: z.string(),
  description: z.optional(z.string()),
  frequency: zScheduleFrequency,
  cronExpression: z.optional(z.string()),
  dayOfWeek: z.optional(zDayOfWeek),
  dayOfMonth: z.optional(z.int()),
  hour: z.optional(z.int()),
  minute: z.optional(z.int()),
  timezone: z.optional(z.string()),
  startDate: z.optional(z.iso.datetime()),
  endDate: z.optional(z.iso.datetime()),
  deliveryMethod: zDeliveryMethod,
  deliveryConfig: z.optional(zDeliveryConfig),
  parameters: z.optional(z.record(z.string(), z.unknown())),
  isActive: z.optional(z.boolean()),
});

/**
 * Scheduled Report resource model
 *
 * Defines automated report generation with:
 * - Flexible scheduling (daily, weekly, monthly, custom cron)
 * - Multiple delivery methods (email, webhook, storage)
 * - Template-based generation
 * - Multi-tenant scoping
 */
export const zScheduledReport = z.object({
  id: z.string(),
  orgId: z.string(),
  templateId: z.string(),
  name: z.string(),
  description: z.optional(z.string()),
  frequency: zScheduleFrequency,
  cronExpression: z.optional(z.string()),
  dayOfWeek: z.optional(zDayOfWeek),
  dayOfMonth: z.optional(z.int()),
  hour: z.optional(z.int()),
  minute: z.optional(z.int()),
  timezone: z.string(),
  startDate: z.iso.datetime(),
  endDate: z.optional(z.iso.datetime()),
  deliveryMethod: zDeliveryMethod,
  deliveryConfig: z.optional(zDeliveryConfig),
  parameters: z.optional(z.record(z.string(), z.unknown())),
  isActive: z.boolean(),
  lastRunAt: z.optional(z.iso.datetime()),
  nextRunAt: z.optional(z.iso.datetime()),
  failureCount: z.int(),
  createdBy: z.string(),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
  deletedAt: z.optional(z.iso.datetime()),
});

/**
 * Scheduled report collection response (page-based)
 */
export const zScheduledReportListResponse = z.object({
  data: z.array(zScheduledReport),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Single scheduled report response
 */
export const zScheduledReportResponse = z.object({
  data: zScheduledReport,
  meta: zResponseMeta,
});

/**
 * Webhook delivery configuration
 */
export const zWebhookDeliveryConfigUpdate = z.object({
  url: z.optional(z.string()),
  headers: z.optional(z.record(z.string(), z.string())),
  attachmentMode: z.optional(z.enum(["attachment", "base64"])),
});

/**
 * Combined delivery configuration
 */
export const zDeliveryConfigUpdate = z.object({
  email: z.optional(zEmailDeliveryConfigUpdate),
  webhook: z.optional(zWebhookDeliveryConfigUpdate),
  storage: z.optional(zStorageDeliveryConfigUpdate),
});

/**
 * Request body for updating a scheduled report
 */
export const zUpdateScheduledReportRequest = z.object({
  templateId: z.optional(z.string()),
  name: z.optional(z.string()),
  description: z.optional(z.string()),
  frequency: z.optional(zScheduleFrequency),
  cronExpression: z.optional(z.string()),
  dayOfWeek: z.optional(zDayOfWeek),
  dayOfMonth: z.optional(z.int()),
  hour: z.optional(z.int()),
  minute: z.optional(z.int()),
  timezone: z.optional(z.string()),
  startDate: z.optional(z.iso.datetime()),
  endDate: z.optional(z.iso.datetime()),
  deliveryMethod: z.optional(zDeliveryMethod),
  deliveryConfig: z.optional(zDeliveryConfigUpdate),
  parameters: z.optional(z.record(z.string(), z.unknown())),
  isActive: z.optional(z.boolean()),
});

/**
 * Webhook delivery status
 */
export const zWebhookDeliveryStatus = z.enum([
  "pending",
  "delivered",
  "failed",
  "exhausted",
]);

/**
 * Webhook delivery attempt record
 *
 * Tracks each attempt to deliver a webhook payload.
 */
export const zWebhookDelivery = z.object({
  id: z.string(),
  webhookId: z.string(),
  eventId: z.string(),
  eventType: z.string(),
  status: zWebhookDeliveryStatus,
  attemptCount: z.int(),
  httpStatus: z.optional(z.int()),
  responseBody: z.optional(z.string()),
  errorMessage: z.optional(z.string()),
  durationMs: z.optional(z.int()),
  nextRetryAt: z.optional(z.iso.datetime()),
  createdAt: z.iso.datetime(),
  lastAttemptAt: z.optional(z.iso.datetime()),
  completedAt: z.optional(z.iso.datetime()),
});

/**
 * Webhook delivery list response
 */
export const zWebhookDeliveryListResponse = z.object({
  data: z.array(zWebhookDelivery),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Webhook delivery response
 */
export const zWebhookDeliveryResponse = z.object({
  data: zWebhookDelivery,
  meta: zResponseMeta,
});

/**
 * Available webhook event types
 */
export const zWebhookEventTypesResponse = z.object({
  data: z.object({
    eventTypes: z.record(z.string(), z.array(z.string())),
  }),
  meta: zResponseMeta,
});

/**
 * Webhook list response
 */
export const zWebhookListResponse = z.object({
  data: z.array(zWebhook),
  pagination: zPagination,
  meta: zResponseMeta,
});

/**
 * Webhook response (secret masked)
 */
export const zWebhookResponse = z.object({
  data: zWebhook,
  meta: zResponseMeta,
});

/**
 * Webhook with unmasked secret (only returned on creation)
 */
export const zWebhookWithSecret = z.object({
  id: z.string(),
  tenantId: z.string(),
  url: z.string(),
  name: z.optional(z.string()),
  events: z.array(z.string()),
  secret: z.string(),
  isActive: z.boolean(),
  createdAt: z.iso.datetime(),
});

/**
 * Webhook creation response (includes secret once)
 */
export const zWebhookCreatedResponse = z.object({
  data: zWebhookWithSecret,
  meta: zResponseMeta,
});

export const zHealthCheckData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zHealthCheckResponse = z.object({
  status: z.enum(["ok", "degraded", "down"]),
  timestamp: z.iso.datetime(),
  version: z.optional(z.string()),
  services: z.optional(
    z.object({
      database: z.optional(z.enum(["ok", "degraded", "down"])),
      cache: z.optional(z.enum(["ok", "degraded", "down"])),
      storage: z.optional(z.enum(["ok", "degraded", "down"])),
    }),
  ),
});

export const zCouponsAdminListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      type: z.optional(zCouponType),
      isActive: z.optional(z.boolean()),
      code: z.optional(z.string()),
      sortBy: z.optional(z.string()).default("createdAt"),
      sortOrder: z.optional(z.string()).default("desc"),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zCouponsAdminListResponse = z.union([
  zCouponListResponse,
  zErrorResponse,
]);

export const zCouponsAdminCreateData = z.object({
  body: zCreateCouponRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zCouponsAdminCreateResponse = z.union([
  zErrorResponse,
  zCouponResponse,
]);

export const zCouponsAdminDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    couponId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zCouponsAdminDeleteResponse = z.union([
  zSoftDeleteResponse,
  zErrorResponse,
]);

export const zCouponsAdminGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    couponId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zCouponsAdminGetResponse = z.union([
  zCouponResponse,
  zErrorResponse,
]);

export const zCouponsAdminUpdateData = z.object({
  body: zUpdateCouponRequest,
  path: z.object({
    couponId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zCouponsAdminUpdateResponse = z.union([
  zCouponResponse,
  zErrorResponse,
]);

export const zSubscriptionPlansAdminListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      applicationId: z.optional(z.string()),
      visibility: z.optional(zPlanVisibility),
      isActive: z.optional(z.boolean()),
      billingPeriod: z.optional(zPlanBillingPeriod),
      sortBy: z.optional(z.string()).default("sortOrder"),
      sortOrder: z.optional(z.string()).default("asc"),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionPlansAdminListResponse = z.union([
  zPlanListResponse,
  zErrorResponse,
]);

export const zSubscriptionPlansAdminCreateData = z.object({
  body: zCreatePlanRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zSubscriptionPlansAdminCreateResponse = z.union([
  zErrorResponse,
  zPlanResponse,
]);

export const zSubscriptionPlansAdminDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    planId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionPlansAdminDeleteResponse = z.union([
  zSoftDeleteResponse,
  zErrorResponse,
]);

export const zSubscriptionPlansAdminGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    planId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionPlansAdminGetResponse = z.union([
  zPlanResponse,
  zErrorResponse,
]);

export const zSubscriptionPlansAdminUpdateData = z.object({
  body: zUpdatePlanRequest,
  path: z.object({
    planId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionPlansAdminUpdateResponse = z.union([
  zPlanResponse,
  zErrorResponse,
]);

export const zMigrationGetStatusData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zMigrationGetStatusResponse = zMigrationStatusResponse;

export const zNotificationsListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(20),
      channel: z.optional(zNotificationChannel),
      category: z.optional(zNotificationCategory),
      status: z.optional(zNotificationStatus),
      readStatus: z.optional(z.enum(["read", "unread"])),
      orderBy: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zNotificationsListResponse = z.union([
  zNotificationListResponse,
  zErrorResponse,
]);

export const zNotificationsMarkAllReadData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zNotificationsMarkAllReadResponse = z.union([
  zMarkAllReadResponse,
  zErrorResponse,
]);

export const zNotificationsPreviewEmailData = z.object({
  body: zPreviewEmailRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zNotificationsPreviewEmailResponse = z.union([
  zPreviewEmailResponse,
  zErrorResponse,
]);

export const zNotificationsSendData = z.object({
  body: zSendNotificationRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zNotificationsSendResponse = z.union([
  zSendNotificationResponse,
  zErrorResponse,
]);

export const zNotificationsGetUnreadCountData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zNotificationsGetUnreadCountResponse = z.union([
  zUnreadCountResponse,
  zErrorResponse,
]);

export const zNotificationsDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zNotificationsDeleteResponse = z.union([zErrorResponse, z.void()]);

export const zNotificationsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zNotificationsGetResponse = z.union([
  zNotificationResponse,
  zErrorResponse,
]);

export const zNotificationsMarkReadData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zNotificationsMarkReadResponse = z.union([
  zErrorResponse,
  z.void(),
]);

export const zNotificationsRestoreData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zNotificationsRestoreResponse = z.union([
  zErrorResponse,
  z.void(),
]);

export const zNotificationsMarkUnreadData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zNotificationsMarkUnreadResponse = z.union([
  zErrorResponse,
  z.void(),
]);

export const zAnnouncementsListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(20),
      priority: z.optional(zAnnouncementPriority),
      scope: z.optional(zAnnouncementScope),
      readStatus: z.optional(z.enum(["read", "unread"])),
      dismissedStatus: z.optional(z.enum(["dismissed", "not-dismissed"])),
      includeExpired: z.optional(z.boolean()).default(false),
      includeInactive: z.optional(z.boolean()).default(false),
      orderBy: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsListResponse = z.union([
  zAnnouncementListResponse,
  zErrorResponse,
]);

export const zAnnouncementsCreateData = z.object({
  body: zCreateAnnouncementRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zAnnouncementsCreateResponse = z.union([
  zErrorResponse,
  zAnnouncementResponse,
]);

export const zAnnouncementsGetUnreadCountData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsGetUnreadCountResponse = z.union([
  zUnreadAnnouncementsResponse,
  zErrorResponse,
]);

export const zAnnouncementsDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    announcementId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsDeleteResponse = z.union([
  zSoftDeleteResponse,
  zErrorResponse,
]);

export const zAnnouncementsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    announcementId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsGetResponse = z.union([
  zAnnouncementWithInteractionResponse,
  zErrorResponse,
]);

export const zAnnouncementsUpdateData = z.object({
  body: zUpdateAnnouncementRequest,
  path: z.object({
    orgId: z.string(),
    announcementId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsUpdateResponse = z.union([
  zAnnouncementResponse,
  zErrorResponse,
]);

export const zAnnouncementsAcknowledgeData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    announcementId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsAcknowledgeResponse = z.union([
  zAcknowledgeAnnouncementResponse,
  zErrorResponse,
]);

export const zAnnouncementsDismissData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    announcementId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsDismissResponse = z.union([
  zDismissAnnouncementResponse,
  zErrorResponse,
]);

export const zAnnouncementsMarkReadData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    announcementId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsMarkReadResponse = z.union([
  zMarkReadResponse,
  zErrorResponse,
]);

export const zAnnouncementsGetStatsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    announcementId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsGetStatsResponse = z.union([
  zAnnouncementStatsResponse,
  zErrorResponse,
]);

export const zAnnouncementsMarkViewedData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    announcementId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAnnouncementsMarkViewedResponse = z.union([
  zMarkViewedResponse,
  zErrorResponse,
]);

export const zAuditLogsListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      eventType: z.optional(z.string()),
      actorId: z.optional(z.string()),
      actorType: z.optional(zAuditActorType),
      resourceType: z.optional(z.string()),
      resourceId: z.optional(z.string()),
      timestampAfter: z.optional(z.iso.datetime()),
      timestampBefore: z.optional(z.iso.datetime()),
      ipAddress: z.optional(z.string()),
      requestId: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zAuditLogsListResponse = z.union([
  zAuditLogListResponse,
  zErrorResponse,
]);

export const zAuditLogsExportData = z.object({
  body: z.object({
    format: z.enum(["csv", "json"]),
    timestampAfter: z.optional(z.iso.datetime()),
    timestampBefore: z.optional(z.iso.datetime()),
    eventTypes: z.optional(z.array(z.string())),
  }),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zAuditLogsExportResponse = z.union([
  z.union([
    z.object({
      data: z.object({
        downloadUrl: z.string(),
        eventCount: z.int(),
        expiresAt: z.iso.datetime(),
      }),
      meta: zResponseMeta,
    }),
    zErrorResponse,
  ]),
  zAsyncJobResponse,
]);

export const zAuditLogsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    eventId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAuditLogsGetResponse = z.union([
  zAuditLogResponse,
  zErrorResponse,
]);

export const zExamplePostsListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      orderBy: z.optional(z.string()),
      fields: z.optional(z.string()),
      include: z.optional(z.string()),
      search: z.optional(z.string()),
      status: z.optional(zExamplePostStatus),
      statusNe: z.optional(z.string()),
      statusIn: z.optional(z.string()),
      authorId: z.optional(z.string()),
      titleContains: z.optional(z.string()),
      contentContains: z.optional(z.string()),
      createdAfter: z.optional(z.iso.datetime()),
      createdBefore: z.optional(z.iso.datetime()),
      publishedAfter: z.optional(z.iso.datetime()),
      publishedBefore: z.optional(z.iso.datetime()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListResponse = z.union([
  zExamplePostListResponse,
  zErrorResponse,
]);

export const zExamplePostsCreateData = z.object({
  body: zCreateExamplePostRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zExamplePostsCreateResponse = z.union([
  zErrorResponse,
  zExamplePostResponse,
]);

export const zExamplePostsBatchUpdateData = z.object({
  body: z.object({
    items: z.optional(
      z.array(
        z.object({
          id: z.string(),
          updates: zUpdateExamplePostRequest,
        }),
      ),
    ),
    options: z.optional(zBatchOptions),
  }),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchUpdateResponse = z.union([
  z.object({
    results: z.array(
      z.object({
        index: z.int(),
        status: z.enum(["success", "error", "skipped"]),
        data: z.optional(zExamplePost),
        error: z.optional(
          z.object({
            code: z.string(),
            message: z.string(),
          }),
        ),
        input: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
    summary: zBatchSummary,
    meta: zResponseMeta,
  }),
  zErrorResponse,
]);

export const zExamplePostsBatchCreateData = z.object({
  body: z.object({
    items: z.array(zCreateExamplePostRequest),
    options: z.optional(zBatchOptions),
  }),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zExamplePostsBatchCreateResponse = z.union([
  zErrorResponse,
  z.object({
    results: z.array(
      z.object({
        index: z.int(),
        status: z.enum(["success", "error", "skipped"]),
        data: z.optional(zExamplePost),
        error: z.optional(
          z.object({
            code: z.string(),
            message: z.string(),
          }),
        ),
        input: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
    summary: zBatchSummary,
    meta: zResponseMeta,
  }),
]);

export const zExamplePostsBatchRestoreData = z.object({
  body: z.object({
    ids: z.array(z.string()),
    options: z.optional(zBatchOptions),
  }),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchRestoreResponse = z.union([
  z.object({
    results: z.array(
      z.object({
        index: z.int(),
        status: z.enum(["success", "error", "skipped"]),
        data: z.optional(zExamplePost),
        error: z.optional(
          z.object({
            code: z.string(),
            message: z.string(),
          }),
        ),
        input: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
    summary: zBatchSummary,
    meta: zResponseMeta,
  }),
  zErrorResponse,
]);

export const zExamplePostsBatchSoftDeleteData = z.object({
  body: z.object({
    ids: z.array(z.string()),
    options: z.optional(zBatchOptions),
  }),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchSoftDeleteResponse = z.union([
  zBatchDeleteResponse,
  zErrorResponse,
]);

export const zExamplePostsListCursorData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      cursor: z.optional(z.string()),
      limit: z.optional(z.int()).default(50),
      orderBy: z.optional(z.string()),
      status: z.optional(zExamplePostStatus),
      authorId: z.optional(z.string()),
      search: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListCursorResponse = z.union([
  zExamplePostCursorListResponse,
  zErrorResponse,
]);

export const zExamplePostsListDeletedData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListDeletedResponse = z.union([
  zExamplePostListResponse,
  zErrorResponse,
]);

export const zExamplePostsDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsDeleteResponse = z.union([
  zSoftDeleteResponse,
  zErrorResponse,
]);

export const zExamplePostsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      fields: z.optional(z.string()),
      include: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsGetResponse = z.union([
  zExamplePostResponse,
  zErrorResponse,
]);

export const zExamplePostsUpdateData = z.object({
  body: zUpdateExamplePostRequest,
  path: z.object({
    orgId: z.string(),
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsUpdateResponse = z.union([
  zExamplePostResponse,
  zErrorResponse,
]);

export const zExamplePostsDeletePermanentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zExamplePostsDeletePermanentResponse = z.union([
  zErrorResponse,
  z.void(),
]);

export const zExamplePostsRestoreData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExamplePostsRestoreResponse = z.union([
  zExamplePostResponse,
  zErrorResponse,
]);

export const zExampleCommentsListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      orderBy: z.optional(z.string()),
      fields: z.optional(z.string()),
      authorId: z.optional(z.string()),
      contentContains: z.optional(z.string()),
      createdAfter: z.optional(z.iso.datetime()),
      createdBefore: z.optional(z.iso.datetime()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsListResponse = z.union([
  zExampleCommentListResponse,
  zErrorResponse,
]);

export const zExampleCommentsCreateData = z.object({
  body: zCreateExampleCommentRequest,
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zExampleCommentsCreateResponse = z.union([
  zErrorResponse,
  zExampleCommentResponse,
]);

export const zExampleCommentsBatchCreateData = z.object({
  body: z.object({
    items: z.array(zCreateExampleCommentRequest),
    options: z.optional(zBatchOptions),
  }),
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zExampleCommentsBatchCreateResponse = z.union([
  zErrorResponse,
  z.object({
    results: z.array(
      z.object({
        index: z.int(),
        status: z.enum(["success", "error", "skipped"]),
        data: z.optional(zExampleComment),
        error: z.optional(
          z.object({
            code: z.string(),
            message: z.string(),
          }),
        ),
        input: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
    summary: zBatchSummary,
    meta: zResponseMeta,
  }),
]);

export const zExampleCommentsBatchSoftDeleteData = z.object({
  body: z.object({
    ids: z.array(z.string()),
    options: z.optional(zBatchOptions),
  }),
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsBatchSoftDeleteResponse = z.union([
  zBatchDeleteResponse,
  zErrorResponse,
]);

export const zExampleCommentsDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsDeleteResponse = z.union([
  zSoftDeleteResponse,
  zErrorResponse,
]);

export const zExampleCommentsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
    id: z.string(),
  }),
  query: z.optional(
    z.object({
      fields: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsGetResponse = z.union([
  zExampleCommentResponse,
  zErrorResponse,
]);

export const zExampleCommentsUpdateData = z.object({
  body: zUpdateExampleCommentRequest,
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsUpdateResponse = z.union([
  zExampleCommentResponse,
  zErrorResponse,
]);

export const zExampleCommentsDeletePermanentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zExampleCommentsDeletePermanentResponse = z.union([
  zErrorResponse,
  z.void(),
]);

export const zExampleCommentsRestoreData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    postId: z.string(),
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsRestoreResponse = z.union([
  zExampleCommentResponse,
  zErrorResponse,
]);

export const zFilesListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      orderBy: z.optional(z.string()),
      fields: z.optional(z.string()),
      mimeType: z.optional(z.string()),
      virusScanStatus: z.optional(zVirusScanStatus),
      access: z.optional(zFileAccess),
      uploadedAfter: z.optional(z.iso.datetime()),
      uploadedBefore: z.optional(z.iso.datetime()),
      uploadedBy: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zFilesListResponse = z.union([zFileListResponse, zErrorResponse]);

export const zFilesDirectUploadData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zFilesDirectUploadResponse = z.union([
  zErrorResponse,
  zFileResponse,
]);

export const zFilesInitiateUploadData = z.object({
  body: zInitiateUploadRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zFilesInitiateUploadResponse = z.union([
  zInitiateUploadResponse,
  zErrorResponse,
]);

export const zFilesConfirmUploadData = z.object({
  body: zConfirmUploadRequest,
  path: z.object({
    orgId: z.string(),
    uploadId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zFilesConfirmUploadResponse = z.union([
  zErrorResponse,
  zFileResponse,
]);

export const zFilesDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    fileId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zFilesDeleteResponse = z.union([
  zFileDeleteResponse,
  zErrorResponse,
]);

export const zFilesGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    fileId: z.string(),
  }),
  query: z.optional(
    z.object({
      fields: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zFilesGetResponse = z.union([zFileResponse, zErrorResponse]);

export const zFilesUpdateData = z.object({
  body: zUpdateFileRequest,
  path: z.object({
    orgId: z.string(),
    fileId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zFilesUpdateResponse = z.union([zFileResponse, zErrorResponse]);

export const zFilesDownloadData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    fileId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zFilesDownloadResponse = zErrorResponse;

export const zFilesDeletePermanentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    fileId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zFilesDeletePermanentResponse = z.union([
  zErrorResponse,
  z.void(),
]);

export const zJobsListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      status: z.optional(zJobStatus),
      type: z.optional(z.string()),
      format: z.optional(z.string()),
      templateId: z.optional(z.string()),
      createdAfter: z.optional(z.iso.datetime()),
      createdBefore: z.optional(z.iso.datetime()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zJobsListResponse = z.union([zJobListResponse, zErrorResponse]);

export const zJobsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    jobId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zJobsGetResponse = z.union([zJobResponse, zErrorResponse]);

export const zJobsCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    jobId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zJobsCancelResponse = z.union([zJobResponse, zErrorResponse]);

export const zJobsDownloadData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    jobId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zJobsDownloadResponse = zErrorResponse;

export const zJobsRetryData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    jobId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zJobsRetryResponse = z.union([zJobResponse, zErrorResponse]);

export const zReportExportsExportData = z.object({
  body: zExportRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zReportExportsExportResponse = z.union([
  zAsyncExportResponse,
  zErrorResponse,
]);

export const zReportExportsPreviewExportData = z.object({
  body: z.object({
    templateId: z.optional(z.string()),
    format: z.optional(zReportFormat),
    data: z.optional(z.array(z.unknown())),
    columns: z.optional(z.array(zReportColumnConfig)),
    options: z.optional(zReportOptions),
    filters: z.optional(z.record(z.string(), z.unknown())),
    sort: z.optional(
      z.array(
        z.object({
          field: z.string(),
          direction: z.enum(["asc", "desc"]),
        }),
      ),
    ),
    parameters: z.optional(z.record(z.string(), z.unknown())),
    selectedIds: z.optional(z.array(z.string())),
    async: z.optional(z.boolean()),
    limit: z.optional(z.int()),
  }),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zReportExportsPreviewExportResponse = z.union([
  z.object({
    data: z.object({
      rows: z.array(z.unknown()),
      totalCount: z.optional(z.int()),
      columns: z.array(z.string()),
    }),
    meta: zResponseMeta,
  }),
  zErrorResponse,
]);

export const zReportExportsStreamExportData = z.object({
  body: zStreamExportRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zReportExportsStreamExportResponse = zErrorResponse;

export const zScheduledReportsListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      orderBy: z.optional(z.string()),
      templateId: z.optional(z.string()),
      frequency: z.optional(zScheduleFrequency),
      deliveryMethod: z.optional(zDeliveryMethod),
      isActive: z.optional(z.boolean()),
      search: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsListResponse = z.union([
  zScheduledReportListResponse,
  zErrorResponse,
]);

export const zScheduledReportsCreateData = z.object({
  body: zCreateScheduledReportRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zScheduledReportsCreateResponse = z.union([
  zErrorResponse,
  zScheduledReportResponse,
]);

export const zScheduledReportsDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    scheduleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsDeleteResponse = z.union([
  zSoftDeleteResponse,
  zErrorResponse,
]);

export const zScheduledReportsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    scheduleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsGetResponse = z.union([
  zScheduledReportResponse,
  zErrorResponse,
]);

export const zScheduledReportsUpdateData = z.object({
  body: zUpdateScheduledReportRequest,
  path: z.object({
    orgId: z.string(),
    scheduleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsUpdateResponse = z.union([
  zScheduledReportResponse,
  zErrorResponse,
]);

export const zScheduledReportsGetHistoryData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    scheduleId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(20),
      status: z.optional(zJobStatus),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsGetHistoryResponse = z.union([
  zJobListResponse,
  zErrorResponse,
]);

export const zScheduledReportsPauseData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    scheduleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsPauseResponse = z.union([
  zScheduledReportResponse,
  zErrorResponse,
]);

export const zScheduledReportsResumeData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    scheduleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsResumeResponse = z.union([
  zScheduledReportResponse,
  zErrorResponse,
]);

export const zScheduledReportsRunNowData = z.object({
  body: z.optional(
    z.object({
      parameters: z.optional(z.record(z.string(), z.unknown())),
    }),
  ),
  path: z.object({
    orgId: z.string(),
    scheduleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zScheduledReportsRunNowResponse = z.union([
  zJobResponse,
  zErrorResponse,
]);

export const zReportTemplatesListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      orderBy: z.optional(z.string()),
      format: z.optional(zReportFormat),
      isPublic: z.optional(z.boolean()),
      search: z.optional(z.string()),
      createdBy: z.optional(z.string()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesListResponse = z.union([
  zReportTemplateListResponse,
  zErrorResponse,
]);

export const zReportTemplatesCreateData = z.object({
  body: zCreateReportTemplateRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zReportTemplatesCreateResponse = z.union([
  zErrorResponse,
  zReportTemplateResponse,
]);

export const zReportTemplatesDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    templateId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesDeleteResponse = z.union([
  zSoftDeleteResponse,
  zErrorResponse,
]);

export const zReportTemplatesGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    templateId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesGetResponse = z.union([
  zReportTemplateResponse,
  zErrorResponse,
]);

export const zReportTemplatesUpdateData = z.object({
  body: zUpdateReportTemplateRequest,
  path: z.object({
    orgId: z.string(),
    templateId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesUpdateResponse = z.union([
  zReportTemplateResponse,
  zErrorResponse,
]);

export const zReportTemplatesCloneData = z.object({
  body: z.object({
    name: z.string(),
    description: z.optional(z.string()),
  }),
  path: z.object({
    orgId: z.string(),
    templateId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zReportTemplatesCloneResponse = z.union([
  zErrorResponse,
  zReportTemplateResponse,
]);

export const zReportTemplatesTestData = z.object({
  body: z.object({
    sampleData: z.optional(z.array(z.unknown())),
    sampleRows: z.optional(z.int()),
    parameters: z.optional(z.record(z.string(), z.unknown())),
  }),
  path: z.object({
    orgId: z.string(),
    templateId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zReportTemplatesTestResponse = z.union([
  zAsyncExportResponse,
  zErrorResponse,
]);

export const zTenantRolesListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      isSystemRole: z.optional(z.boolean()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zTenantRolesListResponse = z.union([
  zRoleListResponse,
  zErrorResponse,
]);

export const zTenantRolesCreateData = z.object({
  body: zCreateRoleRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zTenantRolesCreateResponse = z.union([
  zErrorResponse,
  zRoleResponse,
]);

export const zTenantRolesDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    roleId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zTenantRolesDeleteResponse = z.union([zErrorResponse, z.void()]);

export const zTenantRolesGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    roleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zTenantRolesGetResponse = z.union([zRoleResponse, zErrorResponse]);

export const zTenantRolesUpdateData = z.object({
  body: zUpdateRoleRequest,
  path: z.object({
    orgId: z.string(),
    roleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zTenantRolesUpdateResponse = z.union([
  zRoleResponse,
  zErrorResponse,
]);

export const zSubscriptionsCreateData = z.object({
  body: zCreateSubscriptionRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zSubscriptionsCreateResponse = z.union([
  zErrorResponse,
  zCreateSubscriptionResponse,
]);

export const zSubscriptionsGetCurrentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.object({
    applicationId: z.string(),
  }),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionsGetCurrentResponse = z.union([
  zSubscriptionResponse,
  zErrorResponse,
]);

export const zSubscriptionsValidateCouponData = z.object({
  body: zValidateCouponRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionsValidateCouponResponse = z.union([
  zValidateCouponResponse,
  zErrorResponse,
]);

export const zSubscriptionsUpdateData = z.object({
  body: zUpdateSubscriptionRequest,
  path: z.object({
    orgId: z.string(),
    subscriptionId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionsUpdateResponse = z.union([
  zSubscriptionResponse,
  zErrorResponse,
]);

export const zSubscriptionsCancelData = z.object({
  body: z.optional(zCancelSubscriptionRequest),
  path: z.object({
    orgId: z.string(),
    subscriptionId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionsCancelResponse = z.union([
  zSubscriptionResponse,
  zErrorResponse,
]);

export const zSubscriptionsApplyCouponData = z.object({
  body: zApplyCouponRequest,
  path: z.object({
    orgId: z.string(),
    subscriptionId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionsApplyCouponResponse = z.union([
  zSubscriptionResponse,
  zErrorResponse,
]);

export const zSubscriptionsResumeData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    subscriptionId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zSubscriptionsResumeResponse = z.union([
  zSubscriptionResponse,
  zErrorResponse,
]);

export const zUserPermissionsGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    userId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zUserPermissionsGetResponse = z.union([
  zUserEffectivePermissionsResponse,
  zErrorResponse,
]);

export const zUserTenantRolesListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    userId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zUserTenantRolesListResponse = z.union([
  zUserRoleAssignmentListResponse,
  zErrorResponse,
]);

export const zUserTenantRolesAssignData = z.object({
  body: zAssignRoleRequest,
  path: z.object({
    orgId: z.string(),
    userId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zUserTenantRolesAssignResponse = z.union([
  zErrorResponse,
  zUserRoleAssignmentResponse,
]);

export const zUserTenantRolesRemoveData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    userId: z.string(),
    roleId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zUserTenantRolesRemoveResponse = z.union([
  zErrorResponse,
  z.void(),
]);

export const zWebhooksListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      isActive: z.optional(z.boolean()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zWebhooksListResponse = z.union([
  zWebhookListResponse,
  zErrorResponse,
]);

export const zWebhooksCreateData = z.object({
  body: zCreateWebhookRequest,
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zWebhooksCreateResponse = z.union([
  zErrorResponse,
  zWebhookCreatedResponse,
]);

export const zWebhooksListEventTypesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zWebhooksListEventTypesResponse = z.union([
  zWebhookEventTypesResponse,
  zErrorResponse,
]);

export const zWebhooksDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    webhookId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zWebhooksDeleteResponse = z.union([zErrorResponse, z.void()]);

export const zWebhooksGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    webhookId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zWebhooksGetResponse = z.union([zWebhookResponse, zErrorResponse]);

export const zWebhooksUpdateData = z.object({
  body: zUpdateWebhookRequest,
  path: z.object({
    orgId: z.string(),
    webhookId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zWebhooksUpdateResponse = z.union([
  zWebhookResponse,
  zErrorResponse,
]);

export const zWebhooksListDeliveriesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    webhookId: z.string(),
  }),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      status: z.optional(zWebhookDeliveryStatus),
      eventType: z.optional(z.string()),
      createdAfter: z.optional(z.iso.datetime()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zWebhooksListDeliveriesResponse = z.union([
  zWebhookDeliveryListResponse,
  zErrorResponse,
]);

export const zWebhooksGetDeliveryData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    webhookId: z.string(),
    deliveryId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zWebhooksGetDeliveryResponse = z.union([
  zWebhookDeliveryResponse,
  zErrorResponse,
]);

export const zWebhooksRetryDeliveryData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    webhookId: z.string(),
    deliveryId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zWebhooksRetryDeliveryResponse = z.union([
  zWebhookDeliveryResponse,
  zErrorResponse,
]);

export const zWebhooksRotateSecretData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    webhookId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zWebhooksRotateSecretResponse = z.union([
  zWebhookCreatedResponse,
  zErrorResponse,
]);

export const zWebhooksTestData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    orgId: z.string(),
    webhookId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zWebhooksTestResponse = z.union([
  z.object({
    data: z.object({
      success: z.boolean(),
      httpStatus: z.optional(z.int()),
      durationMs: z.optional(z.int()),
      error: z.optional(z.string()),
    }),
    meta: zResponseMeta,
  }),
  zErrorResponse,
]);

export const zNotificationPreferencesRoutesGetPreferencesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zNotificationPreferencesRoutesGetPreferencesResponse = z.union([
  zNotificationPreferencesResponse,
  zErrorResponse,
]);

export const zNotificationPreferencesRoutesUpdatePreferencesData = z.object({
  body: zUpdatePreferencesRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zNotificationPreferencesRoutesUpdatePreferencesResponse = z.union([
  zNotificationPreferencesResponse,
  zErrorResponse,
]);

export const zPublicPricingListPublicPlansData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      applicationId: z.optional(z.string()),
      billingPeriod: z.optional(zPlanBillingPeriod),
      includePopular: z.optional(z.boolean()).default(true),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zPublicPricingListPublicPlansResponse = z.union([
  zPlanListResponse,
  zErrorResponse,
]);

export const zGlobalRolesListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      page: z.optional(z.int()).default(1),
      pageSize: z.optional(z.int()).default(50),
      isSystemRole: z.optional(z.boolean()),
    }),
  ),
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesListResponse = z.union([
  zRoleListResponse,
  zErrorResponse,
]);

export const zGlobalRolesCreateData = z.object({
  body: zCreateRoleRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zGlobalRolesCreateResponse = z.union([
  zErrorResponse,
  zRoleResponse,
]);

export const zGlobalRolesDeleteData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zGlobalRolesDeleteResponse = z.union([zErrorResponse, z.void()]);

export const zGlobalRolesGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesGetResponse = z.union([zRoleResponse, zErrorResponse]);

export const zGlobalRolesUpdateData = z.object({
  body: zUpdateRoleRequest,
  path: z.object({
    roleId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesUpdateResponse = z.union([
  zRoleResponse,
  zErrorResponse,
]);

export const zAvailableContextsListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAvailableContextsListResponse = z.union([
  zUserContextListResponse,
  zErrorResponse,
]);

export const zCurrentUserContextGetData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zCurrentUserContextGetResponse = z.union([
  zActiveContextResponse,
  zErrorResponse,
]);

export const zContextSwitchSwitchData = z.object({
  body: zSwitchContextRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zContextSwitchSwitchResponse = z.union([
  zSwitchContextResponse,
  zErrorResponse,
]);

export const zAllUserRolesListData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    userId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zAllUserRolesListResponse = z.union([
  zUserRoleAssignmentListResponse,
  zErrorResponse,
]);

export const zPaymentWebhooksHandleMidtransData = z.object({
  body: z.record(z.string(), z.unknown()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * The request has succeeded.
 */
export const zPaymentWebhooksHandleMidtransResponse = z.union([
  zWebhookAcknowledgment,
  zErrorResponse,
]);

export const zPaymentWebhooksHandleXenditData = z.object({
  body: z.record(z.string(), z.unknown()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
  headers: z.object({
    "x-callback-token": z.string(),
  }),
});

/**
 * The request has succeeded.
 */
export const zPaymentWebhooksHandleXenditResponse = z.union([
  zWebhookAcknowledgment,
  zErrorResponse,
]);
