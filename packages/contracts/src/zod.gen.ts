// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * API Key resource model
 *
 * Used for service accounts and automation.
 * The actual key value is only returned once at creation.
 */
export const zApiKey = z.object({
    id: z.string(),
    tenantId: z.string(),
    name: z.string(),
    description: z.string().optional(),
    permissions: z.array(z.string()),
    keyPrefix: z.string(),
    lastUsedAt: z.string().datetime().optional(),
    lastUsedIp: z.string().optional(),
    expiresAt: z.string().datetime().optional(),
    isActive: z.boolean(),
    createdBy: z.string(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime()
});

/**
 * API Key with the actual secret (only returned on creation)
 */
export const zApiKeyWithSecret = z.object({
    id: z.string(),
    tenantId: z.string(),
    name: z.string(),
    description: z.string().optional(),
    permissions: z.array(z.string()),
    key: z.string(),
    expiresAt: z.string().datetime().optional(),
    createdAt: z.string().datetime()
});

/**
 * Request to assign a role to a user
 */
export const zAssignRoleRequest = z.object({
    roleId: z.string()
});

/**
 * Actor type - who performed the action
 */
export const zAuditActorType = z.enum([
    'user',
    'service',
    'system'
]);

/**
 * Actor who performed the action
 */
export const zAuditActor = z.object({
    type: zAuditActorType,
    id: z.string(),
    email: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional()
});

/**
 * Change record for a single field
 */
export const zAuditChange = z.object({
    old: z.unknown(),
    new: z.unknown()
});

/**
 * Additional metadata for the audit event
 */
export const zAuditMetadata = z.object({
    requestId: z.string().optional(),
    sessionId: z.string().optional(),
    reason: z.string().optional(),
    extra: z.record(z.unknown()).optional()
});

/**
 * Resource affected by the action
 */
export const zAuditResource = z.object({
    type: z.string(),
    id: z.string(),
    endpoint: z.string().optional(),
    method: z.string().optional()
});

/**
 * Audit log entry
 *
 * Immutable record of an action in the system.
 */
export const zAuditLog = z.object({
    eventId: z.string(),
    eventType: z.string(),
    timestamp: z.string().datetime(),
    tenantId: z.string(),
    actor: zAuditActor,
    resource: zAuditResource,
    changes: z.record(zAuditChange).optional(),
    resourceBefore: z.record(z.unknown()).optional(),
    resourceAfter: z.record(z.unknown()).optional(),
    metadata: zAuditMetadata.optional()
});

/**
 * Request to confirm an upload completed successfully
 */
export const zConfirmUploadRequest = z.object({
    etag: z.string().optional()
});

/**
 * Request to create a new API key
 */
export const zCreateApiKeyRequest = z.object({
    name: z.string().min(1).max(100),
    description: z.string().max(500).optional(),
    permissions: z.array(z.string()).min(1),
    expiresAt: z.string().datetime().optional()
});

/**
 * Request to create a custom role
 */
export const zCreateRoleRequest = z.object({
    name: z.string().min(1).max(100),
    description: z.string().max(500).optional(),
    permissions: z.array(z.string()).min(1)
});

/**
 * Request body for creating a new user
 */
export const zCreateUserRequest = z.object({
    email: z.string(),
    name: z.string(),
    password: z.string().min(8),
    isActive: z.boolean().optional()
});

/**
 * Request to create a webhook
 */
export const zCreateWebhookRequest = z.object({
    url: z.string().url(),
    name: z.string().max(100).optional(),
    description: z.string().max(500).optional(),
    events: z.array(z.string()).min(1),
    isActive: z.boolean().optional()
});

/**
 * Detailed error information for a specific field or validation
 */
export const zErrorDetail = z.object({
    field: z.string(),
    code: z.string(),
    message: z.string(),
    metadata: z.record(z.unknown()).optional()
});

/**
 * Standard error object
 */
export const zError = z.object({
    code: z.string(),
    message: z.string(),
    details: z.array(zErrorDetail).optional(),
    requestId: z.string(),
    documentationUrl: z.string().optional()
});

/**
 * Standard error response envelope
 */
export const zErrorResponse = z.object({
    error: zError
});

/**
 * File access level
 */
export const zFileAccess = z.enum(['private', 'public']);

/**
 * Request to initiate a presigned URL upload
 */
export const zInitiateUploadRequest = z.object({
    filename: z.string().min(1).max(255),
    contentType: z.string(),
    size: z.coerce.bigint().gte(BigInt(1)),
    metadata: z.record(z.string()).optional()
});

/**
 * Job status
 */
export const zJobStatus = z.enum([
    'pending',
    'processing',
    'completed',
    'failed',
    'cancelled'
]);

/**
 * Async job resource
 *
 * Represents a long-running operation that can be polled for status.
 */
export const zJob = z.object({
    jobId: z.string(),
    tenantId: z.string(),
    type: z.string(),
    status: zJobStatus,
    progress: z.number().int().gte(0).lte(100).optional(),
    message: z.string().optional(),
    result: z.record(z.unknown()).optional(),
    error: z.object({
        code: z.string(),
        message: z.string(),
        details: z.record(z.unknown()).optional()
    }).optional(),
    createdBy: z.string(),
    createdAt: z.string().datetime(),
    startedAt: z.string().datetime().optional(),
    completedAt: z.string().datetime().optional(),
    estimatedCompletion: z.string().datetime().optional()
});

/**
 * Pagination links for navigating through paginated results
 */
export const zPaginationLinks = z.object({
    first: z.union([
        z.string(),
        z.null()
    ]),
    previous: z.union([
        z.string(),
        z.null()
    ]),
    next: z.union([
        z.string(),
        z.null()
    ]),
    last: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Page-based pagination metadata for collection responses
 */
export const zPagination = z.object({
    page: z.number().int(),
    pageSize: z.number().int(),
    totalPages: z.number().int(),
    totalCount: z.number().int(),
    hasNext: z.boolean(),
    hasPrevious: z.boolean(),
    links: zPaginationLinks.optional(),
    requestedPageSize: z.number().int().optional()
});

/**
 * Response metadata included in all API responses
 */
export const zResponseMeta = z.object({
    requestId: z.string(),
    timestamp: z.string().datetime(),
    apiVersion: z.string().optional(),
    tenantId: z.string().optional(),
    tenantName: z.string().optional(),
    durationMs: z.number().int().optional()
});

/**
 * API key creation response (includes secret once)
 */
export const zApiKeyCreatedResponse = z.object({
    data: zApiKeyWithSecret,
    meta: zResponseMeta
});

/**
 * API key list response
 */
export const zApiKeyListResponse = z.object({
    data: z.array(zApiKey),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * API key response (without secret)
 */
export const zApiKeyResponse = z.object({
    data: zApiKey,
    meta: zResponseMeta
});

/**
 * Response for async operations that return 202 Accepted
 */
export const zAsyncJobResponse = z.object({
    jobId: z.string(),
    status: z.enum([
        'pending',
        'processing',
        'completed',
        'failed'
    ]),
    statusUrl: z.string(),
    estimatedCompletion: z.string().datetime().optional(),
    meta: zResponseMeta
});

/**
 * Audit log list response
 */
export const zAuditLogListResponse = z.object({
    data: z.array(zAuditLog),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single audit log response
 */
export const zAuditLogResponse = z.object({
    data: zAuditLog,
    meta: zResponseMeta
});

/**
 * File deletion response
 */
export const zFileDeleteResponse = z.object({
    data: z.object({
        id: z.string(),
        deletedAt: z.string().datetime(),
        deletedBy: z.string()
    }),
    meta: zResponseMeta
});

/**
 * Response with presigned URL for direct upload to storage
 */
export const zInitiateUploadResponse = z.object({
    data: z.object({
        uploadId: z.string(),
        presignedUrl: z.string(),
        method: z.enum(['PUT']),
        headers: z.record(z.string()),
        expiresAt: z.string().datetime(),
        maxSize: z.coerce.bigint()
    }),
    meta: zResponseMeta
});

/**
 * Job list response
 */
export const zJobListResponse = z.object({
    data: z.array(zJob),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Job status response
 */
export const zJobResponse = z.object({
    data: zJob,
    meta: zResponseMeta
});

/**
 * Role resource model
 *
 * Roles are tenant-scoped and contain a set of permissions.
 */
export const zRole = z.object({
    id: z.string(),
    tenantId: z.string(),
    name: z.string(),
    description: z.string().optional(),
    permissions: z.array(z.string()),
    isSystemRole: z.boolean(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime()
});

/**
 * Role list response
 */
export const zRoleListResponse = z.object({
    data: z.array(zRole),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single role response
 */
export const zRoleResponse = z.object({
    data: zRole,
    meta: zResponseMeta
});

/**
 * Response for soft delete operations
 *
 * Includes resource ID, deletion metadata, and restore information
 */
export const zSoftDeleteResponse = z.object({
    data: z.object({
        id: z.string(),
        deletedAt: z.string().datetime(),
        deletedBy: z.string(),
        deletionReason: z.string().optional(),
        canRestore: z.boolean(),
        restoreUntil: z.string().datetime().optional()
    }),
    meta: zResponseMeta
});

/**
 * Request to switch active tenant
 */
export const zSwitchTenantRequest = z.object({
    tenantId: z.string()
});

/**
 * Tenant switch response with new token
 */
export const zSwitchTenantResponse = z.object({
    data: z.object({
        tenantId: z.string(),
        tenantName: z.string(),
        roles: z.array(z.string()),
        permissions: z.array(z.string()),
        accessToken: z.string()
    }),
    meta: zResponseMeta
});

/**
 * Request to update an API key
 */
export const zUpdateApiKeyRequest = z.object({
    name: z.string().min(1).max(100).optional(),
    description: z.string().max(500).optional(),
    permissions: z.array(z.string()).optional(),
    isActive: z.boolean().optional()
});

/**
 * Request to update a role
 */
export const zUpdateRoleRequest = z.object({
    name: z.string().min(1).max(100).optional(),
    description: z.string().max(500).optional(),
    permissions: z.array(z.string()).optional()
});

/**
 * Request body for updating a user
 */
export const zUpdateUserRequest = z.object({
    name: z.string().optional(),
    isActive: z.boolean().optional()
});

/**
 * Request to update a webhook
 */
export const zUpdateWebhookRequest = z.object({
    url: z.string().url().optional(),
    name: z.string().max(100).optional(),
    description: z.string().max(500).optional(),
    events: z.array(z.string()).optional(),
    isActive: z.boolean().optional()
});

/**
 * User resource model
 */
export const zUser = z.object({
    id: z.string(),
    email: z.string(),
    name: z.string(),
    isActive: z.boolean(),
    isVerified: z.boolean(),
    isDeleted: z.boolean(),
    deletedAt: z.string().datetime().optional(),
    deletedBy: z.string().optional(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime(),
    lastLoginAt: z.string().datetime().optional()
});

/**
 * User collection response
 */
export const zUserListResponse = z.object({
    data: z.array(zUser),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * User's permissions within a tenant
 */
export const zUserPermissions = z.object({
    userId: z.string(),
    tenantId: z.string(),
    roles: z.array(z.object({
        id: z.string(),
        name: z.string(),
        permissions: z.array(z.string())
    })),
    effectivePermissions: z.array(z.string())
});

/**
 * User permissions response
 */
export const zUserPermissionsResponse = z.object({
    data: zUserPermissions,
    meta: zResponseMeta
});

/**
 * Single user response
 */
export const zUserResponse = z.object({
    data: zUser,
    meta: zResponseMeta
});

/**
 * User's role assignment within a tenant
 */
export const zUserRole = z.object({
    userId: z.string(),
    tenantId: z.string(),
    roleId: z.string(),
    roleName: z.string(),
    assignedAt: z.string().datetime(),
    assignedBy: z.string()
});

/**
 * User role assignment response
 */
export const zUserRoleResponse = z.object({
    data: zUserRole,
    meta: zResponseMeta
});

/**
 * User's roles across all tenants
 */
export const zUserTenantRoles = z.object({
    tenantId: z.string(),
    tenantName: z.string(),
    roles: z.array(z.string())
});

/**
 * User tenant roles response (all tenants)
 */
export const zUserTenantRolesResponse = z.object({
    data: z.array(zUserTenantRoles),
    meta: zResponseMeta
});

/**
 * Virus scan status for uploaded files
 */
export const zVirusScanStatus = z.enum([
    'pending',
    'scanning',
    'clean',
    'infected',
    'failed'
]);

/**
 * File resource model
 *
 * Represents an uploaded file with metadata, security status, and access info.
 */
export const zFile = z.object({
    id: z.string(),
    filename: z.string(),
    size: z.coerce.bigint(),
    mimeType: z.string(),
    storagePath: z.string(),
    url: z.string().optional(),
    metadata: z.record(z.string()).optional(),
    uploadedBy: z.string(),
    uploadedAt: z.string().datetime(),
    virusScanStatus: zVirusScanStatus,
    virusScanCompletedAt: z.string().datetime().optional(),
    access: zFileAccess,
    isDeleted: z.boolean(),
    deletedAt: z.string().datetime().optional(),
    deletedBy: z.string().optional()
});

/**
 * File list response with pagination
 */
export const zFileListResponse = z.object({
    data: z.array(zFile),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single file response
 */
export const zFileResponse = z.object({
    data: zFile,
    meta: zResponseMeta
});

/**
 * Webhook configuration
 *
 * Defines an endpoint to receive event notifications.
 */
export const zWebhook = z.object({
    id: z.string(),
    tenantId: z.string(),
    url: z.string(),
    name: z.string().optional(),
    description: z.string().optional(),
    events: z.array(z.string()),
    secret: z.string(),
    isActive: z.boolean(),
    consecutiveFailures: z.number().int(),
    lastTriggeredAt: z.string().datetime().optional(),
    lastSuccessAt: z.string().datetime().optional(),
    lastFailureAt: z.string().datetime().optional(),
    createdBy: z.string(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime()
});

/**
 * Webhook delivery status
 */
export const zWebhookDeliveryStatus = z.enum([
    'pending',
    'delivered',
    'failed',
    'exhausted'
]);

/**
 * Webhook delivery attempt record
 *
 * Tracks each attempt to deliver a webhook payload.
 */
export const zWebhookDelivery = z.object({
    id: z.string(),
    webhookId: z.string(),
    eventId: z.string(),
    eventType: z.string(),
    status: zWebhookDeliveryStatus,
    attemptCount: z.number().int(),
    httpStatus: z.number().int().optional(),
    responseBody: z.string().optional(),
    errorMessage: z.string().optional(),
    durationMs: z.number().int().optional(),
    nextRetryAt: z.string().datetime().optional(),
    createdAt: z.string().datetime(),
    lastAttemptAt: z.string().datetime().optional(),
    completedAt: z.string().datetime().optional()
});

/**
 * Webhook delivery list response
 */
export const zWebhookDeliveryListResponse = z.object({
    data: z.array(zWebhookDelivery),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Webhook delivery response
 */
export const zWebhookDeliveryResponse = z.object({
    data: zWebhookDelivery,
    meta: zResponseMeta
});

/**
 * Available webhook event types
 */
export const zWebhookEventTypesResponse = z.object({
    data: z.object({
        eventTypes: z.record(z.array(z.string()))
    }),
    meta: zResponseMeta
});

/**
 * Webhook list response
 */
export const zWebhookListResponse = z.object({
    data: z.array(zWebhook),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Webhook response (secret masked)
 */
export const zWebhookResponse = z.object({
    data: zWebhook,
    meta: zResponseMeta
});

/**
 * Webhook with unmasked secret (only returned on creation)
 */
export const zWebhookWithSecret = z.object({
    id: z.string(),
    tenantId: z.string(),
    url: z.string(),
    name: z.string().optional(),
    events: z.array(z.string()),
    secret: z.string(),
    isActive: z.boolean(),
    createdAt: z.string().datetime()
});

/**
 * Webhook creation response (includes secret once)
 */
export const zWebhookCreatedResponse = z.object({
    data: zWebhookWithSecret,
    meta: zResponseMeta
});

export const zHealthCheckData = z.object({
    body: z.never().optional(),
    path: z.never().optional(),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zHealthCheckResponse = z.object({
    status: z.enum([
        'ok',
        'degraded',
        'down'
    ]),
    timestamp: z.string().datetime(),
    version: z.string().optional(),
    services: z.object({
        database: z.enum([
            'ok',
            'degraded',
            'down'
        ]).optional(),
        cache: z.enum([
            'ok',
            'degraded',
            'down'
        ]).optional(),
        storage: z.enum([
            'ok',
            'degraded',
            'down'
        ]).optional()
    }).optional()
});

export const zApiKeysListData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.object({
        page: z.number().int().optional().default(1),
        pageSize: z.number().int().optional().default(50),
        isActive: z.boolean().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zApiKeysListResponse = z.union([
    zApiKeyListResponse,
    zErrorResponse
]);

export const zApiKeysCreateData = z.object({
    body: zCreateApiKeyRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

export const zApiKeysCreateResponse = z.union([
    zErrorResponse,
    zApiKeyCreatedResponse
]);

export const zApiKeysRevokeData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        keyId: z.string()
    }),
    query: z.never().optional()
});

export const zApiKeysRevokeResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zApiKeysGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        keyId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zApiKeysGetResponse = z.union([
    zApiKeyResponse,
    zErrorResponse
]);

export const zApiKeysUpdateData = z.object({
    body: zUpdateApiKeyRequest,
    path: z.object({
        orgId: z.string(),
        keyId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zApiKeysUpdateResponse = z.union([
    zApiKeyResponse,
    zErrorResponse
]);

export const zApiKeysRotateData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        keyId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zApiKeysRotateResponse = z.union([
    zApiKeyCreatedResponse,
    zErrorResponse
]);

export const zAuditLogsListData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.object({
        page: z.number().int().optional().default(1),
        pageSize: z.number().int().optional().default(50),
        eventType: z.string().optional(),
        actorId: z.string().optional(),
        actorType: zAuditActorType.optional(),
        resourceType: z.string().optional(),
        resourceId: z.string().optional(),
        timestampAfter: z.string().datetime().optional(),
        timestampBefore: z.string().datetime().optional(),
        ipAddress: z.string().optional(),
        requestId: z.string().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zAuditLogsListResponse = z.union([
    zAuditLogListResponse,
    zErrorResponse
]);

export const zAuditLogsExportData = z.object({
    body: z.object({
        format: z.enum(['csv', 'json']),
        timestampAfter: z.string().datetime().optional(),
        timestampBefore: z.string().datetime().optional(),
        eventTypes: z.array(z.string()).optional()
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

export const zAuditLogsExportResponse = z.union([
    z.union([
        z.object({
            data: z.object({
                downloadUrl: z.string(),
                eventCount: z.number().int(),
                expiresAt: z.string().datetime()
            }),
            meta: zResponseMeta
        }),
        zErrorResponse
    ]),
    zAsyncJobResponse
]);

export const zAuditLogsGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        eventId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zAuditLogsGetResponse = z.union([
    zAuditLogResponse,
    zErrorResponse
]);

export const zFilesListData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.object({
        page: z.number().int().optional().default(1),
        pageSize: z.number().int().optional().default(50),
        orderBy: z.string().optional(),
        fields: z.string().optional(),
        mimeType: z.string().optional(),
        virusScanStatus: zVirusScanStatus.optional(),
        access: zFileAccess.optional(),
        uploadedAfter: z.string().datetime().optional(),
        uploadedBefore: z.string().datetime().optional(),
        uploadedBy: z.string().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zFilesListResponse = z.union([
    zFileListResponse,
    zErrorResponse
]);

export const zFilesDirectUploadData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

export const zFilesDirectUploadResponse = z.union([
    zErrorResponse,
    zFileResponse
]);

export const zFilesInitiateUploadData = z.object({
    body: zInitiateUploadRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zFilesInitiateUploadResponse = z.union([
    zInitiateUploadResponse,
    zErrorResponse
]);

export const zFilesConfirmUploadData = z.object({
    body: zConfirmUploadRequest,
    path: z.object({
        orgId: z.string(),
        uploadId: z.string()
    }),
    query: z.never().optional()
});

export const zFilesConfirmUploadResponse = z.union([
    zErrorResponse,
    zFileResponse
]);

export const zFilesDeleteData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zFilesDeleteResponse = z.union([
    zFileDeleteResponse,
    zErrorResponse
]);

export const zFilesGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.object({
        fields: z.string().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zFilesGetResponse = z.union([
    zFileResponse,
    zErrorResponse
]);

export const zFilesDownloadData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zFilesDownloadResponse = zErrorResponse;

export const zFilesDeletePermanentData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.never().optional()
});

export const zFilesDeletePermanentResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zJobsListData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.object({
        page: z.number().int().optional().default(1),
        pageSize: z.number().int().optional().default(50),
        status: zJobStatus.optional(),
        type: z.string().optional(),
        createdAfter: z.string().datetime().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zJobsListResponse = z.union([
    zJobListResponse,
    zErrorResponse
]);

export const zJobsGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zJobsGetResponse = z.union([
    zJobResponse,
    zErrorResponse
]);

export const zJobsCancelData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zJobsCancelResponse = z.union([
    zJobResponse,
    zErrorResponse
]);

export const zRolesListData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.object({
        page: z.number().int().optional().default(1),
        pageSize: z.number().int().optional().default(50),
        isSystemRole: z.boolean().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zRolesListResponse = z.union([
    zRoleListResponse,
    zErrorResponse
]);

export const zRolesCreateData = z.object({
    body: zCreateRoleRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

export const zRolesCreateResponse = z.union([
    zErrorResponse,
    zRoleResponse
]);

export const zRolesDeleteData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.never().optional()
});

export const zRolesDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zRolesGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zRolesGetResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zRolesUpdateData = z.object({
    body: zUpdateRoleRequest,
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zRolesUpdateResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zUsersListData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.object({
        page: z.number().int().optional().default(1),
        pageSize: z.number().int().optional().default(50),
        orderBy: z.string().optional(),
        fields: z.string().optional(),
        include: z.string().optional(),
        search: z.string().optional(),
        status: z.string().optional(),
        statusNe: z.string().optional(),
        statusIn: z.string().optional(),
        isVerified: z.boolean().optional(),
        isActive: z.boolean().optional(),
        role: z.string().optional(),
        roleIn: z.string().optional(),
        emailContains: z.string().optional(),
        emailStartsWith: z.string().optional(),
        emailEndsWith: z.string().optional(),
        nameContains: z.string().optional(),
        createdAfter: z.string().datetime().optional(),
        createdBefore: z.string().datetime().optional(),
        updatedAfter: z.string().datetime().optional(),
        updatedBefore: z.string().datetime().optional(),
        lastLoginAfter: z.string().datetime().optional(),
        lastLoginBefore: z.string().datetime().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zUsersListResponse = z.union([
    zUserListResponse,
    zErrorResponse
]);

export const zUsersCreateData = z.object({
    body: zCreateUserRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

export const zUsersCreateResponse = z.union([
    zErrorResponse,
    zUserResponse
]);

export const zUsersBatchUpdateData = z.object({
    body: z.object({
        users: z.array(z.object({
            id: z.string(),
            updates: zUpdateUserRequest
        })).optional()
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zUsersBatchUpdateResponse = z.union([
    z.object({
        data: z.object({
            updated: z.array(zUser),
            failed: z.array(z.object({
                id: z.string(),
                error: zError
            }))
        }),
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zUsersBatchCreateData = z.object({
    body: z.object({
        users: z.array(zCreateUserRequest)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

export const zUsersBatchCreateResponse = z.union([
    zErrorResponse,
    z.object({
        data: z.object({
            created: z.array(zUser),
            failed: z.array(z.object({
                index: z.number().int(),
                error: zError
            }))
        }),
        meta: zResponseMeta
    })
]);

export const zUsersBatchSoftDeleteData = z.object({
    body: z.object({
        ids: z.array(z.string())
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zUsersBatchSoftDeleteResponse = z.union([
    z.object({
        data: z.object({
            deleted: z.array(z.object({
                id: z.string(),
                deletedAt: z.string().datetime()
            })),
            failed: z.array(z.object({
                id: z.string(),
                error: zError
            }))
        }),
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zUsersDeleteData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zUsersDeleteResponse = z.union([
    zSoftDeleteResponse,
    zErrorResponse
]);

export const zUsersGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.object({
        fields: z.string().optional(),
        include: z.string().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zUsersGetResponse = z.union([
    zUserResponse,
    zErrorResponse
]);

export const zUsersUpdateData = z.object({
    body: zUpdateUserRequest,
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zUsersUpdateResponse = z.union([
    zUserResponse,
    zErrorResponse
]);

export const zUsersResetPasswordData = z.object({
    body: z.object({
        email: z.string().optional(),
        sendEmail: z.boolean().optional()
    }),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zUsersResetPasswordResponse = z.union([
    z.object({
        data: z.object({
            userId: z.string(),
            resetTokenSent: z.boolean(),
            expiresAt: z.string().datetime()
        }),
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zUsersDeletePermanentData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.never().optional()
});

export const zUsersDeletePermanentResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zUsersRestoreData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zUsersRestoreResponse = z.union([
    zUserResponse,
    zErrorResponse
]);

export const zUserPermissionsEndpointGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zUserPermissionsEndpointGetResponse = z.union([
    zUserPermissionsResponse,
    zErrorResponse
]);

export const zUserRolesListData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zUserRolesListResponse = z.union([
    z.object({
        data: z.array(zUserRole),
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zUserRolesAssignData = z.object({
    body: zAssignRoleRequest,
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.never().optional()
});

export const zUserRolesAssignResponse = z.union([
    zErrorResponse,
    zUserRoleResponse
]);

export const zUserRolesRemoveData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        userId: z.string(),
        roleId: z.string()
    }),
    query: z.never().optional()
});

export const zUserRolesRemoveResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zWebhooksListData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.object({
        page: z.number().int().optional().default(1),
        pageSize: z.number().int().optional().default(50),
        isActive: z.boolean().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksListResponse = z.union([
    zWebhookListResponse,
    zErrorResponse
]);

export const zWebhooksCreateData = z.object({
    body: zCreateWebhookRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

export const zWebhooksCreateResponse = z.union([
    zErrorResponse,
    zWebhookCreatedResponse
]);

export const zWebhooksListEventTypesData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksListEventTypesResponse = z.union([
    zWebhookEventTypesResponse,
    zErrorResponse
]);

export const zWebhooksDeleteData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

export const zWebhooksDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zWebhooksGetData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksGetResponse = z.union([
    zWebhookResponse,
    zErrorResponse
]);

export const zWebhooksUpdateData = z.object({
    body: zUpdateWebhookRequest,
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksUpdateResponse = z.union([
    zWebhookResponse,
    zErrorResponse
]);

export const zWebhooksListDeliveriesData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.object({
        page: z.number().int().optional().default(1),
        pageSize: z.number().int().optional().default(50),
        status: zWebhookDeliveryStatus.optional(),
        eventType: z.string().optional(),
        createdAfter: z.string().datetime().optional()
    }).optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksListDeliveriesResponse = z.union([
    zWebhookDeliveryListResponse,
    zErrorResponse
]);

export const zWebhooksGetDeliveryData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string(),
        deliveryId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksGetDeliveryResponse = z.union([
    zWebhookDeliveryResponse,
    zErrorResponse
]);

export const zWebhooksRetryDeliveryData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string(),
        deliveryId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksRetryDeliveryResponse = z.union([
    zWebhookDeliveryResponse,
    zErrorResponse
]);

export const zWebhooksRotateSecretData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksRotateSecretResponse = z.union([
    zWebhookCreatedResponse,
    zErrorResponse
]);

export const zWebhooksTestData = z.object({
    body: z.never().optional(),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zWebhooksTestResponse = z.union([
    z.object({
        data: z.object({
            success: z.boolean(),
            httpStatus: z.number().int().optional(),
            durationMs: z.number().int().optional(),
            error: z.string().optional()
        }),
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zTenantSwitchSwitchData = z.object({
    body: zSwitchTenantRequest,
    path: z.object({
        userId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zTenantSwitchSwitchResponse = z.union([
    zSwitchTenantResponse,
    zErrorResponse
]);

export const zCrossTenantRolesListData = z.object({
    body: z.never().optional(),
    path: z.object({
        userId: z.string()
    }),
    query: z.never().optional()
});

/**
 * The request has succeeded.
 */
export const zCrossTenantRolesListResponse = z.union([
    zUserTenantRolesResponse,
    zErrorResponse
]);
