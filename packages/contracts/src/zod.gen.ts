// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * User's active context (current app/tenant selection)
 */
export const zActiveContext = z.object({
    userId: z.string(),
    activeApplicationId: z.string(),
    activeTenantId: z.optional(z.string()),
    updatedAt: z.iso.datetime()
});

/**
 * Request to assign a role to a user
 */
export const zAssignRoleRequest = z.object({
    roleId: z.string()
});

/**
 * Actor type - who performed the action
 */
export const zAuditActorType = z.enum([
    'user',
    'service',
    'system'
]);

/**
 * Actor who performed the action
 */
export const zAuditActor = z.object({
    type: zAuditActorType,
    id: z.string(),
    email: z.optional(z.string()),
    ipAddress: z.optional(z.string()),
    userAgent: z.optional(z.string())
});

/**
 * Change record for a single field
 */
export const zAuditChange = z.object({
    old: z.unknown(),
    new: z.unknown()
});

/**
 * Additional metadata for the audit event
 */
export const zAuditMetadata = z.object({
    requestId: z.optional(z.string()),
    sessionId: z.optional(z.string()),
    reason: z.optional(z.string()),
    extra: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Resource affected by the action
 */
export const zAuditResource = z.object({
    type: z.string(),
    id: z.string(),
    endpoint: z.optional(z.string()),
    method: z.optional(z.string())
});

/**
 * Audit log entry
 *
 * Immutable record of an action in the system.
 */
export const zAuditLog = z.object({
    eventId: z.string(),
    eventType: z.string(),
    timestamp: z.iso.datetime(),
    tenantId: z.string(),
    actor: zAuditActor,
    resource: zAuditResource,
    changes: z.optional(z.record(z.string(), zAuditChange)),
    resourceBefore: z.optional(z.record(z.string(), z.unknown())),
    resourceAfter: z.optional(z.record(z.string(), z.unknown())),
    metadata: z.optional(zAuditMetadata)
});

/**
 * Batch delete result (soft delete)
 */
export const zBatchDeleteResult = z.object({
    index: z.int(),
    status: z.enum([
        'success',
        'error',
        'skipped'
    ]),
    data: z.optional(z.object({
        id: z.string(),
        deletedAt: z.iso.datetime()
    })),
    error: z.optional(z.object({
        code: z.string(),
        message: z.string()
    }))
});

/**
 * Options for batch operations
 */
export const zBatchOptions = z.object({
    atomic: z.optional(z.boolean()),
    returnRecords: z.optional(z.boolean()),
    skipDuplicates: z.optional(z.boolean()),
    validateOnly: z.optional(z.boolean())
});

/**
 * Summary of batch operation results
 */
export const zBatchSummary = z.object({
    total: z.int(),
    successful: z.int(),
    failed: z.int(),
    skipped: z.int()
});

/**
 * Request to confirm an upload completed successfully
 */
export const zConfirmUploadRequest = z.object({
    etag: z.optional(z.string())
});

/**
 * Request body for creating a new comment
 */
export const zCreateExampleCommentRequest = z.object({
    content: z.string(),
    authorId: z.string()
});

/**
 * Request to create a webhook
 */
export const zCreateWebhookRequest = z.object({
    url: z.url(),
    name: z.optional(z.string().max(100)),
    description: z.optional(z.string().max(500)),
    events: z.array(z.string()).min(1),
    isActive: z.optional(z.boolean())
});

/**
 * Cursor-based pagination for large datasets or real-time data
 */
export const zCursorPagination = z.object({
    limit: z.int(),
    hasNext: z.boolean(),
    nextCursor: z.union([
        z.string(),
        z.null()
    ]),
    previousCursor: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Detailed error information for a specific field or validation
 */
export const zErrorDetail = z.object({
    field: z.string(),
    code: z.string(),
    message: z.string(),
    metadata: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Standard error object
 */
export const zError = z.object({
    code: z.string(),
    message: z.string(),
    details: z.optional(z.array(zErrorDetail)),
    requestId: z.string(),
    documentationUrl: z.optional(z.string())
});

/**
 * Standard error response envelope
 */
export const zErrorResponse = z.object({
    error: zError
});

/**
 * ExampleComment resource model (nested under ExamplePost)
 *
 * Demonstrates:
 * - Nested sub-resource pattern (belongs to a post)
 * - Multi-tenant scoping (orgId)
 * - Soft delete with restore capability
 */
export const zExampleComment = z.object({
    id: z.string(),
    orgId: z.string(),
    postId: z.string(),
    content: z.string(),
    authorId: z.string(),
    isDeleted: z.boolean(),
    deletedAt: z.optional(z.iso.datetime()),
    deletedBy: z.optional(z.string()),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * Post status enum
 */
export const zExamplePostStatus = z.enum([
    'draft',
    'published',
    'archived'
]);

/**
 * Request body for creating a new post
 */
export const zCreateExamplePostRequest = z.object({
    title: z.string(),
    content: z.string(),
    authorId: z.string(),
    status: z.optional(zExamplePostStatus)
});

/**
 * ExamplePost resource model
 *
 * Demonstrates a typical content resource with:
 * - Multi-tenant scoping (orgId)
 * - Status workflow (draft → published → archived)
 * - Soft delete with restore capability
 */
export const zExamplePost = z.object({
    id: z.string(),
    orgId: z.string(),
    title: z.string(),
    content: z.string(),
    authorId: z.string(),
    status: zExamplePostStatus,
    publishedAt: z.optional(z.iso.datetime()),
    isDeleted: z.boolean(),
    deletedAt: z.optional(z.iso.datetime()),
    deletedBy: z.optional(z.string()),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * File access level
 */
export const zFileAccess = z.enum(['private', 'public']);

/**
 * Request to initiate a presigned URL upload
 */
export const zInitiateUploadRequest = z.object({
    filename: z.string().min(1).max(255),
    contentType: z.string(),
    size: z.coerce.bigint().gte(BigInt(1)),
    metadata: z.optional(z.record(z.string(), z.string()))
});

/**
 * Job status
 */
export const zJobStatus = z.enum([
    'pending',
    'processing',
    'completed',
    'failed',
    'cancelled'
]);

/**
 * Async job resource
 *
 * Represents a long-running operation that can be polled for status.
 */
export const zJob = z.object({
    jobId: z.string(),
    tenantId: z.string(),
    type: z.string(),
    status: zJobStatus,
    progress: z.optional(z.int().gte(0).lte(100)),
    message: z.optional(z.string()),
    result: z.optional(z.record(z.string(), z.unknown())),
    error: z.optional(z.object({
        code: z.string(),
        message: z.string(),
        details: z.optional(z.record(z.string(), z.unknown()))
    })),
    createdBy: z.string(),
    createdAt: z.iso.datetime(),
    startedAt: z.optional(z.iso.datetime()),
    completedAt: z.optional(z.iso.datetime()),
    estimatedCompletion: z.optional(z.iso.datetime())
});

/**
 * Version lifecycle status
 */
export const zMigrationStatus = z.enum([
    'current',
    'deprecated',
    'sunset'
]);

/**
 * Migration status for an API version
 */
export const zMigrationStatusResponse = z.object({
    version: z.string(),
    status: zMigrationStatus,
    sunsetDate: z.optional(z.iso.datetime()),
    daysUntilSunset: z.optional(z.int()),
    replacementVersion: z.optional(z.string()),
    migrationGuideUrl: z.optional(z.string()),
    breakingChanges: z.optional(z.array(z.string())),
    migrationChecklist: z.optional(z.array(z.string()))
});

/**
 * Notification category enum
 */
export const zNotificationCategory = z.enum([
    'transactional',
    'marketing',
    'security',
    'system'
]);

/**
 * Notification channel enum
 */
export const zNotificationChannel = z.enum([
    'email',
    'sms',
    'whatsapp',
    'telegram',
    'push'
]);

/**
 * Notification preferences model
 */
export const zNotificationPreferences = z.object({
    userId: z.string(),
    emailEnabled: z.boolean(),
    smsEnabled: z.boolean(),
    whatsappEnabled: z.boolean(),
    telegramEnabled: z.boolean(),
    pushEnabled: z.boolean(),
    marketingEnabled: z.boolean(),
    transactionalEnabled: z.boolean(),
    securityEnabled: z.boolean(),
    systemEnabled: z.boolean(),
    preferredEmail: z.optional(z.string()),
    preferredPhone: z.optional(z.string()),
    preferredTelegramId: z.optional(z.string()),
    quietHoursEnabled: z.boolean(),
    quietHoursStart: z.optional(z.string()),
    quietHoursEnd: z.optional(z.string()),
    quietHoursTimezone: z.optional(z.string()),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * Notification priority enum
 */
export const zNotificationPriority = z.enum([
    'urgent',
    'high',
    'normal',
    'low'
]);

/**
 * Notification recipient information
 */
export const zNotificationRecipient = z.object({
    email: z.optional(z.string()),
    phone: z.optional(z.string()),
    telegramId: z.optional(z.string())
});

/**
 * Notification status enum
 */
export const zNotificationStatus = z.enum([
    'pending',
    'queued',
    'processing',
    'sent',
    'delivered',
    'failed',
    'bounced'
]);

/**
 * Notification resource model
 */
export const zNotification = z.object({
    id: z.string(),
    userId: z.optional(z.string()),
    channel: zNotificationChannel,
    category: zNotificationCategory,
    priority: zNotificationPriority,
    status: zNotificationStatus,
    recipientEmail: z.optional(z.string()),
    recipientPhone: z.optional(z.string()),
    recipientTelegramId: z.optional(z.string()),
    templateId: z.optional(z.string()),
    subject: z.optional(z.string()),
    body: z.optional(z.string()),
    bodyHtml: z.optional(z.string()),
    templateData: z.optional(z.record(z.string(), z.unknown())),
    campaignId: z.optional(z.string()),
    provider: z.optional(z.string()),
    providerMessageId: z.optional(z.string()),
    sentAt: z.optional(z.iso.datetime()),
    deliveredAt: z.optional(z.iso.datetime()),
    failedAt: z.optional(z.iso.datetime()),
    readAt: z.optional(z.iso.datetime()),
    deletedAt: z.optional(z.iso.datetime()),
    retryCount: z.int(),
    maxRetries: z.int(),
    nextRetryAt: z.optional(z.iso.datetime()),
    statusMessage: z.optional(z.string()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * Pagination links for navigating through paginated results
 */
export const zPaginationLinks = z.object({
    first: z.union([
        z.string(),
        z.null()
    ]),
    previous: z.union([
        z.string(),
        z.null()
    ]),
    next: z.union([
        z.string(),
        z.null()
    ]),
    last: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * Page-based pagination metadata for collection responses
 */
export const zPagination = z.object({
    page: z.int(),
    pageSize: z.int(),
    totalPages: z.int(),
    totalCount: z.int(),
    hasNext: z.boolean(),
    hasPrevious: z.boolean(),
    links: z.optional(zPaginationLinks),
    requestedPageSize: z.optional(z.int())
});

/**
 * Permission actions
 */
export const zPermissionAction = z.enum([
    'read',
    'create',
    'update',
    'delete',
    'manage',
    '*'
]);

/**
 * Permission condition - when the permission applies
 *
 * Conditions enable dynamic, context-aware access control.
 */
export const zPermissionCondition = z.enum([
    '',
    'owner',
    'shared'
]);

/**
 * Permission effect - whether to allow or deny access
 *
 * When a user has multiple roles, permissions are combined:
 * - If ANY role denies an action, it is denied (deny wins)
 * - If no role denies and ANY role allows, it is allowed
 * - If no rules match, access is denied (default deny)
 */
export const zPermissionEffect = z.enum(['allow', 'deny']);

/**
 * Permission definition
 *
 * Permissions define what actions can be performed on resources.
 * They support allow/deny effects and optional conditions.
 */
export const zPermission = z.object({
    resource: z.string(),
    action: z.union([
        zPermissionAction,
        z.string()
    ]),
    effect: zPermissionEffect,
    condition: z.optional(zPermissionCondition)
});

/**
 * Permission input for creating/updating roles
 */
export const zPermissionInput = z.object({
    resource: z.string(),
    action: z.string(),
    effect: z.optional(zPermissionEffect),
    condition: z.optional(zPermissionCondition)
});

/**
 * Request to create a custom role
 */
export const zCreateRoleRequest = z.object({
    name: z.string().min(1).max(100),
    description: z.optional(z.string().max(500)),
    permissions: z.array(zPermissionInput).min(1)
});

/**
 * Response metadata included in all API responses
 */
export const zResponseMeta = z.object({
    requestId: z.string(),
    timestamp: z.iso.datetime(),
    apiVersion: z.optional(z.string()),
    tenantId: z.optional(z.string()),
    tenantName: z.optional(z.string()),
    durationMs: z.optional(z.int())
});

/**
 * Active context response
 */
export const zActiveContextResponse = z.object({
    data: zActiveContext,
    meta: zResponseMeta
});

/**
 * Response for async operations that return 202 Accepted
 */
export const zAsyncJobResponse = z.object({
    jobId: z.string(),
    status: z.enum([
        'pending',
        'processing',
        'completed',
        'failed'
    ]),
    statusUrl: z.string(),
    estimatedCompletion: z.optional(z.iso.datetime()),
    meta: zResponseMeta
});

/**
 * Audit log list response
 */
export const zAuditLogListResponse = z.object({
    data: z.array(zAuditLog),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single audit log response
 */
export const zAuditLogResponse = z.object({
    data: zAuditLog,
    meta: zResponseMeta
});

/**
 * Batch delete response envelope
 */
export const zBatchDeleteResponse = z.object({
    results: z.array(zBatchDeleteResult),
    summary: zBatchSummary,
    meta: zResponseMeta
});

/**
 * Comment collection response
 */
export const zExampleCommentListResponse = z.object({
    data: z.array(zExampleComment),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single comment response
 */
export const zExampleCommentResponse = z.object({
    data: zExampleComment,
    meta: zResponseMeta
});

/**
 * Post collection response (cursor-based)
 *
 * Used for streaming/real-time scenarios or large datasets
 */
export const zExamplePostCursorListResponse = z.object({
    data: z.array(zExamplePost),
    pagination: zCursorPagination,
    meta: zResponseMeta
});

/**
 * Post collection response (page-based)
 */
export const zExamplePostListResponse = z.object({
    data: z.array(zExamplePost),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single post response
 */
export const zExamplePostResponse = z.object({
    data: zExamplePost,
    meta: zResponseMeta
});

/**
 * File deletion response
 */
export const zFileDeleteResponse = z.object({
    data: z.object({
        id: z.string(),
        deletedAt: z.iso.datetime(),
        deletedBy: z.string()
    }),
    meta: zResponseMeta
});

/**
 * Response with presigned URL for direct upload to storage
 */
export const zInitiateUploadResponse = z.object({
    data: z.object({
        uploadId: z.string(),
        presignedUrl: z.string(),
        method: z.enum(['PUT']),
        headers: z.record(z.string(), z.string()),
        expiresAt: z.iso.datetime(),
        maxSize: z.coerce.bigint()
    }),
    meta: zResponseMeta
});

/**
 * Job list response
 */
export const zJobListResponse = z.object({
    data: z.array(zJob),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Job status response
 */
export const zJobResponse = z.object({
    data: zJob,
    meta: zResponseMeta
});

/**
 * Mark all as read response
 */
export const zMarkAllReadResponse = z.object({
    data: z.object({
        markedCount: z.int()
    }),
    meta: zResponseMeta
});

/**
 * Notification collection response
 */
export const zNotificationListResponse = z.object({
    data: z.array(zNotification),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Notification preferences response
 */
export const zNotificationPreferencesResponse = z.object({
    data: zNotificationPreferences,
    meta: zResponseMeta
});

/**
 * Single notification response
 */
export const zNotificationResponse = z.object({
    data: zNotification,
    meta: zResponseMeta
});

/**
 * Role resource model
 *
 * Roles can be:
 * - **Global roles**: App-scoped (tenantId is null), apply across all tenants
 * - **Tenant roles**: Scoped to a specific organization
 *
 * Users can have multiple roles, and permissions are combined with
 * deny-override semantics.
 */
export const zRole = z.object({
    id: z.string(),
    applicationId: z.string(),
    tenantId: z.optional(z.string()),
    name: z.string(),
    description: z.optional(z.string()),
    permissions: z.array(zPermission),
    isSystemRole: z.boolean(),
    isGlobalRole: z.boolean(),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime(),
    createdBy: z.optional(z.string())
});

/**
 * Role list response
 */
export const zRoleListResponse = z.object({
    data: z.array(zRole),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single role response
 */
export const zRoleResponse = z.object({
    data: zRole,
    meta: zResponseMeta
});

/**
 * Request body for sending a notification
 */
export const zSendNotificationRequest = z.object({
    channel: zNotificationChannel,
    category: zNotificationCategory,
    priority: z.optional(zNotificationPriority),
    recipient: zNotificationRecipient,
    templateId: z.optional(z.string()),
    templateData: z.optional(z.record(z.string(), z.unknown())),
    subject: z.optional(z.string()),
    body: z.optional(z.string()),
    bodyHtml: z.optional(z.string()),
    metadata: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * Send notification success response
 */
export const zSendNotificationResponse = z.object({
    data: z.object({
        messageId: z.string(),
        provider: z.string()
    }),
    meta: zResponseMeta
});

/**
 * Response for soft delete operations
 *
 * Includes resource ID, deletion metadata, and restore information
 */
export const zSoftDeleteResponse = z.object({
    data: z.object({
        id: z.string(),
        deletedAt: z.iso.datetime(),
        deletedBy: z.string(),
        deletionReason: z.optional(z.string()),
        canRestore: z.boolean(),
        restoreUntil: z.optional(z.iso.datetime())
    }),
    meta: zResponseMeta
});

/**
 * Request to switch active context (application and/or tenant)
 */
export const zSwitchContextRequest = z.object({
    applicationId: z.optional(z.string()),
    tenantId: z.optional(z.string())
});

/**
 * Context switch response
 */
export const zSwitchContextResponse = z.object({
    data: z.object({
        applicationId: z.string(),
        tenantId: z.optional(z.string()),
        tenantName: z.optional(z.string()),
        roles: z.array(z.string()),
        permissions: z.array(zPermission)
    }),
    meta: zResponseMeta
});

/**
 * Unread count response
 */
export const zUnreadCountResponse = z.object({
    data: z.object({
        unreadCount: z.int()
    }),
    meta: zResponseMeta
});

/**
 * Request body for updating a comment
 */
export const zUpdateExampleCommentRequest = z.object({
    content: z.optional(z.string())
});

/**
 * Request body for updating a post
 */
export const zUpdateExamplePostRequest = z.object({
    title: z.optional(z.string()),
    content: z.optional(z.string()),
    status: z.optional(zExamplePostStatus)
});

/**
 * Request to update file properties
 */
export const zUpdateFileRequest = z.object({
    access: z.optional(zFileAccess)
});

/**
 * Request body for updating notification preferences
 */
export const zUpdatePreferencesRequest = z.object({
    emailEnabled: z.optional(z.boolean()),
    smsEnabled: z.optional(z.boolean()),
    whatsappEnabled: z.optional(z.boolean()),
    telegramEnabled: z.optional(z.boolean()),
    pushEnabled: z.optional(z.boolean()),
    marketingEnabled: z.optional(z.boolean()),
    transactionalEnabled: z.optional(z.boolean()),
    securityEnabled: z.optional(z.boolean()),
    systemEnabled: z.optional(z.boolean()),
    preferredEmail: z.optional(z.string()),
    preferredPhone: z.optional(z.string()),
    preferredTelegramId: z.optional(z.string()),
    quietHoursEnabled: z.optional(z.boolean()),
    quietHoursStart: z.optional(z.string()),
    quietHoursEnd: z.optional(z.string()),
    quietHoursTimezone: z.optional(z.string())
});

/**
 * Request to update a role
 */
export const zUpdateRoleRequest = z.object({
    name: z.optional(z.string().min(1).max(100)),
    description: z.optional(z.string().max(500)),
    permissions: z.optional(z.array(zPermissionInput))
});

/**
 * Request to update a webhook
 */
export const zUpdateWebhookRequest = z.object({
    url: z.optional(z.url()),
    name: z.optional(z.string().max(100)),
    description: z.optional(z.string().max(500)),
    events: z.optional(z.array(z.string())),
    isActive: z.optional(z.boolean())
});

/**
 * User's context across applications and tenants
 */
export const zUserContext = z.object({
    applicationId: z.string(),
    applicationName: z.string(),
    tenantId: z.string(),
    tenantName: z.string(),
    roles: z.array(z.string())
});

/**
 * User available contexts response (all apps/tenants user belongs to)
 */
export const zUserContextListResponse = z.object({
    data: z.array(zUserContext),
    meta: zResponseMeta
});

/**
 * User's effective permissions
 *
 * Represents the combined permissions from all roles assigned to a user
 * within a specific application and tenant context.
 */
export const zUserEffectivePermissions = z.object({
    userId: z.string(),
    applicationId: z.string(),
    tenantId: z.optional(z.string()),
    globalRoles: z.array(z.object({
        id: z.string(),
        name: z.string(),
        permissions: z.array(zPermission)
    })),
    tenantRoles: z.array(z.object({
        id: z.string(),
        name: z.string(),
        permissions: z.array(zPermission)
    })),
    effectivePermissions: z.array(zPermission),
    allowedActions: z.array(z.string())
});

/**
 * User effective permissions response
 */
export const zUserEffectivePermissionsResponse = z.object({
    data: zUserEffectivePermissions,
    meta: zResponseMeta
});

/**
 * User's role assignment
 *
 * Represents a single role assigned to a user within a specific
 * application and optional tenant context.
 */
export const zUserRoleAssignment = z.object({
    id: z.string(),
    userId: z.string(),
    applicationId: z.string(),
    tenantId: z.optional(z.string()),
    roleId: z.string(),
    roleName: z.string(),
    isGlobalRole: z.boolean(),
    assignedAt: z.iso.datetime(),
    assignedBy: z.optional(z.string())
});

/**
 * User role assignments list response
 */
export const zUserRoleAssignmentListResponse = z.object({
    data: z.array(zUserRoleAssignment),
    meta: zResponseMeta
});

/**
 * User role assignment response
 */
export const zUserRoleAssignmentResponse = z.object({
    data: zUserRoleAssignment,
    meta: zResponseMeta
});

/**
 * Virus scan status for uploaded files
 */
export const zVirusScanStatus = z.enum([
    'pending',
    'scanning',
    'clean',
    'infected',
    'failed'
]);

/**
 * File resource model
 *
 * Represents an uploaded file with metadata, security status, and access info.
 */
export const zFile = z.object({
    id: z.string(),
    filename: z.string(),
    size: z.coerce.bigint(),
    mimeType: z.string(),
    storagePath: z.string(),
    url: z.optional(z.string()),
    metadata: z.optional(z.record(z.string(), z.string())),
    uploadedBy: z.string(),
    uploadedAt: z.iso.datetime(),
    virusScanStatus: zVirusScanStatus,
    virusScanCompletedAt: z.optional(z.iso.datetime()),
    access: zFileAccess,
    isDeleted: z.boolean(),
    deletedAt: z.optional(z.iso.datetime()),
    deletedBy: z.optional(z.string())
});

/**
 * File list response with pagination
 */
export const zFileListResponse = z.object({
    data: z.array(zFile),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Single file response
 */
export const zFileResponse = z.object({
    data: zFile,
    meta: zResponseMeta
});

/**
 * Webhook configuration
 *
 * Defines an endpoint to receive event notifications.
 */
export const zWebhook = z.object({
    id: z.string(),
    tenantId: z.string(),
    url: z.string(),
    name: z.optional(z.string()),
    description: z.optional(z.string()),
    events: z.array(z.string()),
    secret: z.string(),
    isActive: z.boolean(),
    consecutiveFailures: z.int(),
    lastTriggeredAt: z.optional(z.iso.datetime()),
    lastSuccessAt: z.optional(z.iso.datetime()),
    lastFailureAt: z.optional(z.iso.datetime()),
    createdBy: z.string(),
    createdAt: z.iso.datetime(),
    updatedAt: z.iso.datetime()
});

/**
 * Webhook delivery status
 */
export const zWebhookDeliveryStatus = z.enum([
    'pending',
    'delivered',
    'failed',
    'exhausted'
]);

/**
 * Webhook delivery attempt record
 *
 * Tracks each attempt to deliver a webhook payload.
 */
export const zWebhookDelivery = z.object({
    id: z.string(),
    webhookId: z.string(),
    eventId: z.string(),
    eventType: z.string(),
    status: zWebhookDeliveryStatus,
    attemptCount: z.int(),
    httpStatus: z.optional(z.int()),
    responseBody: z.optional(z.string()),
    errorMessage: z.optional(z.string()),
    durationMs: z.optional(z.int()),
    nextRetryAt: z.optional(z.iso.datetime()),
    createdAt: z.iso.datetime(),
    lastAttemptAt: z.optional(z.iso.datetime()),
    completedAt: z.optional(z.iso.datetime())
});

/**
 * Webhook delivery list response
 */
export const zWebhookDeliveryListResponse = z.object({
    data: z.array(zWebhookDelivery),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Webhook delivery response
 */
export const zWebhookDeliveryResponse = z.object({
    data: zWebhookDelivery,
    meta: zResponseMeta
});

/**
 * Available webhook event types
 */
export const zWebhookEventTypesResponse = z.object({
    data: z.object({
        eventTypes: z.record(z.string(), z.array(z.string()))
    }),
    meta: zResponseMeta
});

/**
 * Webhook list response
 */
export const zWebhookListResponse = z.object({
    data: z.array(zWebhook),
    pagination: zPagination,
    meta: zResponseMeta
});

/**
 * Webhook response (secret masked)
 */
export const zWebhookResponse = z.object({
    data: zWebhook,
    meta: zResponseMeta
});

/**
 * Webhook with unmasked secret (only returned on creation)
 */
export const zWebhookWithSecret = z.object({
    id: z.string(),
    tenantId: z.string(),
    url: z.string(),
    name: z.optional(z.string()),
    events: z.array(z.string()),
    secret: z.string(),
    isActive: z.boolean(),
    createdAt: z.iso.datetime()
});

/**
 * Webhook creation response (includes secret once)
 */
export const zWebhookCreatedResponse = z.object({
    data: zWebhookWithSecret,
    meta: zResponseMeta
});

export const zHealthCheckData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zHealthCheckResponse = z.object({
    status: z.enum([
        'ok',
        'degraded',
        'down'
    ]),
    timestamp: z.iso.datetime(),
    version: z.optional(z.string()),
    services: z.optional(z.object({
        database: z.optional(z.enum([
            'ok',
            'degraded',
            'down'
        ])),
        cache: z.optional(z.enum([
            'ok',
            'degraded',
            'down'
        ])),
        storage: z.optional(z.enum([
            'ok',
            'degraded',
            'down'
        ]))
    }))
});

export const zMigrationGetStatusData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zMigrationGetStatusResponse = zMigrationStatusResponse;

export const zNotificationsListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(20),
        channel: z.optional(zNotificationChannel),
        category: z.optional(zNotificationCategory),
        status: z.optional(zNotificationStatus),
        readStatus: z.optional(z.enum(['read', 'unread']))
    }))
});

/**
 * The request has succeeded.
 */
export const zNotificationsListResponse = z.union([
    zNotificationListResponse,
    zErrorResponse
]);

export const zNotificationsMarkAllReadData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsMarkAllReadResponse = z.union([
    zMarkAllReadResponse,
    zErrorResponse
]);

export const zNotificationsSendData = z.object({
    body: zSendNotificationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsSendResponse = z.union([
    zSendNotificationResponse,
    zErrorResponse
]);

export const zNotificationsGetUnreadCountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsGetUnreadCountResponse = z.union([
    zUnreadCountResponse,
    zErrorResponse
]);

export const zNotificationsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zNotificationsDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zNotificationsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationsGetResponse = z.union([
    zNotificationResponse,
    zErrorResponse
]);

export const zNotificationsMarkReadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zNotificationsMarkReadResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zNotificationsRestoreData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zNotificationsRestoreResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zNotificationsMarkUnreadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zNotificationsMarkUnreadResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zAuditLogsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        eventType: z.optional(z.string()),
        actorId: z.optional(z.string()),
        actorType: z.optional(zAuditActorType),
        resourceType: z.optional(z.string()),
        resourceId: z.optional(z.string()),
        timestampAfter: z.optional(z.iso.datetime()),
        timestampBefore: z.optional(z.iso.datetime()),
        ipAddress: z.optional(z.string()),
        requestId: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zAuditLogsListResponse = z.union([
    zAuditLogListResponse,
    zErrorResponse
]);

export const zAuditLogsExportData = z.object({
    body: z.object({
        format: z.enum(['csv', 'json']),
        timestampAfter: z.optional(z.iso.datetime()),
        timestampBefore: z.optional(z.iso.datetime()),
        eventTypes: z.optional(z.array(z.string()))
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zAuditLogsExportResponse = z.union([
    z.union([
        z.object({
            data: z.object({
                downloadUrl: z.string(),
                eventCount: z.int(),
                expiresAt: z.iso.datetime()
            }),
            meta: zResponseMeta
        }),
        zErrorResponse
    ]),
    zAsyncJobResponse
]);

export const zAuditLogsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        eventId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zAuditLogsGetResponse = z.union([
    zAuditLogResponse,
    zErrorResponse
]);

export const zExamplePostsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        fields: z.optional(z.string()),
        include: z.optional(z.string()),
        search: z.optional(z.string()),
        status: z.optional(zExamplePostStatus),
        statusNe: z.optional(z.string()),
        statusIn: z.optional(z.string()),
        authorId: z.optional(z.string()),
        titleContains: z.optional(z.string()),
        contentContains: z.optional(z.string()),
        createdAfter: z.optional(z.iso.datetime()),
        createdBefore: z.optional(z.iso.datetime()),
        publishedAfter: z.optional(z.iso.datetime()),
        publishedBefore: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListResponse = z.union([
    zExamplePostListResponse,
    zErrorResponse
]);

export const zExamplePostsCreateData = z.object({
    body: zCreateExamplePostRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zExamplePostsCreateResponse = z.union([
    zErrorResponse,
    zExamplePostResponse
]);

export const zExamplePostsBatchUpdateData = z.object({
    body: z.object({
        items: z.optional(z.array(z.object({
            id: z.string(),
            updates: zUpdateExamplePostRequest
        }))),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchUpdateResponse = z.union([
    z.object({
        results: z.array(z.object({
            index: z.int(),
            status: z.enum([
                'success',
                'error',
                'skipped'
            ]),
            data: z.optional(zExamplePost),
            error: z.optional(z.object({
                code: z.string(),
                message: z.string()
            })),
            input: z.optional(z.record(z.string(), z.unknown()))
        })),
        summary: zBatchSummary,
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zExamplePostsBatchCreateData = z.object({
    body: z.object({
        items: z.array(zCreateExamplePostRequest),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zExamplePostsBatchCreateResponse = z.union([
    zErrorResponse,
    z.object({
        results: z.array(z.object({
            index: z.int(),
            status: z.enum([
                'success',
                'error',
                'skipped'
            ]),
            data: z.optional(zExamplePost),
            error: z.optional(z.object({
                code: z.string(),
                message: z.string()
            })),
            input: z.optional(z.record(z.string(), z.unknown()))
        })),
        summary: zBatchSummary,
        meta: zResponseMeta
    })
]);

export const zExamplePostsBatchRestoreData = z.object({
    body: z.object({
        ids: z.array(z.string()),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchRestoreResponse = z.union([
    z.object({
        results: z.array(z.object({
            index: z.int(),
            status: z.enum([
                'success',
                'error',
                'skipped'
            ]),
            data: z.optional(zExamplePost),
            error: z.optional(z.object({
                code: z.string(),
                message: z.string()
            })),
            input: z.optional(z.record(z.string(), z.unknown()))
        })),
        summary: zBatchSummary,
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zExamplePostsBatchSoftDeleteData = z.object({
    body: z.object({
        ids: z.array(z.string()),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsBatchSoftDeleteResponse = z.union([
    zBatchDeleteResponse,
    zErrorResponse
]);

export const zExamplePostsListCursorData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        cursor: z.optional(z.string()),
        limit: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        status: z.optional(zExamplePostStatus),
        authorId: z.optional(z.string()),
        search: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListCursorResponse = z.union([
    zExamplePostCursorListResponse,
    zErrorResponse
]);

export const zExamplePostsListDeletedData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50)
    }))
});

/**
 * The request has succeeded.
 */
export const zExamplePostsListDeletedResponse = z.union([
    zExamplePostListResponse,
    zErrorResponse
]);

export const zExamplePostsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsDeleteResponse = z.union([
    zSoftDeleteResponse,
    zErrorResponse
]);

export const zExamplePostsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.object({
        fields: z.optional(z.string()),
        include: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zExamplePostsGetResponse = z.union([
    zExamplePostResponse,
    zErrorResponse
]);

export const zExamplePostsUpdateData = z.object({
    body: zUpdateExamplePostRequest,
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsUpdateResponse = z.union([
    zExamplePostResponse,
    zErrorResponse
]);

export const zExamplePostsDeletePermanentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zExamplePostsDeletePermanentResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zExamplePostsRestoreData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExamplePostsRestoreResponse = z.union([
    zExamplePostResponse,
    zErrorResponse
]);

export const zExampleCommentsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        fields: z.optional(z.string()),
        authorId: z.optional(z.string()),
        contentContains: z.optional(z.string()),
        createdAfter: z.optional(z.iso.datetime()),
        createdBefore: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsListResponse = z.union([
    zExampleCommentListResponse,
    zErrorResponse
]);

export const zExampleCommentsCreateData = z.object({
    body: zCreateExampleCommentRequest,
    path: z.object({
        orgId: z.string(),
        postId: z.string()
    }),
    query: z.optional(z.never())
});

export const zExampleCommentsCreateResponse = z.union([
    zErrorResponse,
    zExampleCommentResponse
]);

export const zExampleCommentsBatchCreateData = z.object({
    body: z.object({
        items: z.array(zCreateExampleCommentRequest),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string(),
        postId: z.string()
    }),
    query: z.optional(z.never())
});

export const zExampleCommentsBatchCreateResponse = z.union([
    zErrorResponse,
    z.object({
        results: z.array(z.object({
            index: z.int(),
            status: z.enum([
                'success',
                'error',
                'skipped'
            ]),
            data: z.optional(zExampleComment),
            error: z.optional(z.object({
                code: z.string(),
                message: z.string()
            })),
            input: z.optional(z.record(z.string(), z.unknown()))
        })),
        summary: zBatchSummary,
        meta: zResponseMeta
    })
]);

export const zExampleCommentsBatchSoftDeleteData = z.object({
    body: z.object({
        ids: z.array(z.string()),
        options: z.optional(zBatchOptions)
    }),
    path: z.object({
        orgId: z.string(),
        postId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsBatchSoftDeleteResponse = z.union([
    zBatchDeleteResponse,
    zErrorResponse
]);

export const zExampleCommentsDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsDeleteResponse = z.union([
    zSoftDeleteResponse,
    zErrorResponse
]);

export const zExampleCommentsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.object({
        fields: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsGetResponse = z.union([
    zExampleCommentResponse,
    zErrorResponse
]);

export const zExampleCommentsUpdateData = z.object({
    body: zUpdateExampleCommentRequest,
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsUpdateResponse = z.union([
    zExampleCommentResponse,
    zErrorResponse
]);

export const zExampleCommentsDeletePermanentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

export const zExampleCommentsDeletePermanentResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zExampleCommentsRestoreData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        postId: z.string(),
        id: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zExampleCommentsRestoreResponse = z.union([
    zExampleCommentResponse,
    zErrorResponse
]);

export const zFilesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        orderBy: z.optional(z.string()),
        fields: z.optional(z.string()),
        mimeType: z.optional(z.string()),
        virusScanStatus: z.optional(zVirusScanStatus),
        access: z.optional(zFileAccess),
        uploadedAfter: z.optional(z.iso.datetime()),
        uploadedBefore: z.optional(z.iso.datetime()),
        uploadedBy: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zFilesListResponse = z.union([
    zFileListResponse,
    zErrorResponse
]);

export const zFilesDirectUploadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zFilesDirectUploadResponse = z.union([
    zErrorResponse,
    zFileResponse
]);

export const zFilesInitiateUploadData = z.object({
    body: zInitiateUploadRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zFilesInitiateUploadResponse = z.union([
    zInitiateUploadResponse,
    zErrorResponse
]);

export const zFilesConfirmUploadData = z.object({
    body: zConfirmUploadRequest,
    path: z.object({
        orgId: z.string(),
        uploadId: z.string()
    }),
    query: z.optional(z.never())
});

export const zFilesConfirmUploadResponse = z.union([
    zErrorResponse,
    zFileResponse
]);

export const zFilesDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zFilesDeleteResponse = z.union([
    zFileDeleteResponse,
    zErrorResponse
]);

export const zFilesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.object({
        fields: z.optional(z.string())
    }))
});

/**
 * The request has succeeded.
 */
export const zFilesGetResponse = z.union([
    zFileResponse,
    zErrorResponse
]);

export const zFilesUpdateData = z.object({
    body: zUpdateFileRequest,
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zFilesUpdateResponse = z.union([
    zFileResponse,
    zErrorResponse
]);

export const zFilesDownloadData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zFilesDownloadResponse = zErrorResponse;

export const zFilesDeletePermanentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        fileId: z.string()
    }),
    query: z.optional(z.never())
});

export const zFilesDeletePermanentResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zJobsListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        status: z.optional(zJobStatus),
        type: z.optional(z.string()),
        createdAfter: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zJobsListResponse = z.union([
    zJobListResponse,
    zErrorResponse
]);

export const zJobsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zJobsGetResponse = z.union([
    zJobResponse,
    zErrorResponse
]);

export const zJobsCancelData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        jobId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zJobsCancelResponse = z.union([
    zJobResponse,
    zErrorResponse
]);

export const zTenantRolesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        isSystemRole: z.optional(z.boolean())
    }))
});

/**
 * The request has succeeded.
 */
export const zTenantRolesListResponse = z.union([
    zRoleListResponse,
    zErrorResponse
]);

export const zTenantRolesCreateData = z.object({
    body: zCreateRoleRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zTenantRolesCreateResponse = z.union([
    zErrorResponse,
    zRoleResponse
]);

export const zTenantRolesDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

export const zTenantRolesDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zTenantRolesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zTenantRolesGetResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zTenantRolesUpdateData = z.object({
    body: zUpdateRoleRequest,
    path: z.object({
        orgId: z.string(),
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zTenantRolesUpdateResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zUserPermissionsGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zUserPermissionsGetResponse = z.union([
    zUserEffectivePermissionsResponse,
    zErrorResponse
]);

export const zUserTenantRolesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zUserTenantRolesListResponse = z.union([
    zUserRoleAssignmentListResponse,
    zErrorResponse
]);

export const zUserTenantRolesAssignData = z.object({
    body: zAssignRoleRequest,
    path: z.object({
        orgId: z.string(),
        userId: z.string()
    }),
    query: z.optional(z.never())
});

export const zUserTenantRolesAssignResponse = z.union([
    zErrorResponse,
    zUserRoleAssignmentResponse
]);

export const zUserTenantRolesRemoveData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        userId: z.string(),
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

export const zUserTenantRolesRemoveResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zWebhooksListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        isActive: z.optional(z.boolean())
    }))
});

/**
 * The request has succeeded.
 */
export const zWebhooksListResponse = z.union([
    zWebhookListResponse,
    zErrorResponse
]);

export const zWebhooksCreateData = z.object({
    body: zCreateWebhookRequest,
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

export const zWebhooksCreateResponse = z.union([
    zErrorResponse,
    zWebhookCreatedResponse
]);

export const zWebhooksListEventTypesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksListEventTypesResponse = z.union([
    zWebhookEventTypesResponse,
    zErrorResponse
]);

export const zWebhooksDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

export const zWebhooksDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zWebhooksGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksGetResponse = z.union([
    zWebhookResponse,
    zErrorResponse
]);

export const zWebhooksUpdateData = z.object({
    body: zUpdateWebhookRequest,
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksUpdateResponse = z.union([
    zWebhookResponse,
    zErrorResponse
]);

export const zWebhooksListDeliveriesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        status: z.optional(zWebhookDeliveryStatus),
        eventType: z.optional(z.string()),
        createdAfter: z.optional(z.iso.datetime())
    }))
});

/**
 * The request has succeeded.
 */
export const zWebhooksListDeliveriesResponse = z.union([
    zWebhookDeliveryListResponse,
    zErrorResponse
]);

export const zWebhooksGetDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string(),
        deliveryId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksGetDeliveryResponse = z.union([
    zWebhookDeliveryResponse,
    zErrorResponse
]);

export const zWebhooksRetryDeliveryData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string(),
        deliveryId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksRetryDeliveryResponse = z.union([
    zWebhookDeliveryResponse,
    zErrorResponse
]);

export const zWebhooksRotateSecretData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksRotateSecretResponse = z.union([
    zWebhookCreatedResponse,
    zErrorResponse
]);

export const zWebhooksTestData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        orgId: z.string(),
        webhookId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zWebhooksTestResponse = z.union([
    z.object({
        data: z.object({
            success: z.boolean(),
            httpStatus: z.optional(z.int()),
            durationMs: z.optional(z.int()),
            error: z.optional(z.string())
        }),
        meta: zResponseMeta
    }),
    zErrorResponse
]);

export const zNotificationPreferencesRoutesGetPreferencesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationPreferencesRoutesGetPreferencesResponse = z.union([
    zNotificationPreferencesResponse,
    zErrorResponse
]);

export const zNotificationPreferencesRoutesUpdatePreferencesData = z.object({
    body: zUpdatePreferencesRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zNotificationPreferencesRoutesUpdatePreferencesResponse = z.union([
    zNotificationPreferencesResponse,
    zErrorResponse
]);

export const zGlobalRolesListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int()).default(1),
        pageSize: z.optional(z.int()).default(50),
        isSystemRole: z.optional(z.boolean())
    }))
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesListResponse = z.union([
    zRoleListResponse,
    zErrorResponse
]);

export const zGlobalRolesCreateData = z.object({
    body: zCreateRoleRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGlobalRolesCreateResponse = z.union([
    zErrorResponse,
    zRoleResponse
]);

export const zGlobalRolesDeleteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

export const zGlobalRolesDeleteResponse = z.union([
    zErrorResponse,
    z.void()
]);

export const zGlobalRolesGetData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesGetResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zGlobalRolesUpdateData = z.object({
    body: zUpdateRoleRequest,
    path: z.object({
        roleId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zGlobalRolesUpdateResponse = z.union([
    zRoleResponse,
    zErrorResponse
]);

export const zAvailableContextsListData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zAvailableContextsListResponse = z.union([
    zUserContextListResponse,
    zErrorResponse
]);

export const zCurrentUserContextGetData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zCurrentUserContextGetResponse = z.union([
    zActiveContextResponse,
    zErrorResponse
]);

export const zContextSwitchSwitchData = z.object({
    body: zSwitchContextRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zContextSwitchSwitchResponse = z.union([
    zSwitchContextResponse,
    zErrorResponse
]);

export const zAllUserRolesListData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The request has succeeded.
 */
export const zAllUserRolesListResponse = z.union([
    zUserRoleAssignmentListResponse,
    zErrorResponse
]);
